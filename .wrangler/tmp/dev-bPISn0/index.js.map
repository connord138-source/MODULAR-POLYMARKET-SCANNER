{
  "version": 3,
  "sources": ["../bundle-C8BKd5/checked-fetch.js", "../../../src/config.js", "../../../src/utils.js", "../../../src/wallets.js", "../../../src/learning.js", "../../../src/polymarket-api.js", "../../../src/signals.js", "../../../src/odds-api.js", "../../../src/settlement.js", "../../../src/trades.js", "../../../src/betting-splits.js", "../../../src/sharp-lines.js", "../../../src/edge-detector.js", "../../../src/index.js", "../../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-C8BKd5/middleware-insertion-facade.js", "../../../node_modules/wrangler/templates/middleware/common.ts", "../bundle-C8BKd5/middleware-loader.entry.ts"],
  "sourceRoot": "/home/project/.wrangler/tmp/dev-bPISn0",
  "sourcesContent": ["const urls = new Set();\n\nfunction checkURL(request, init) {\n\tconst url =\n\t\trequest instanceof URL\n\t\t\t? request\n\t\t\t: new URL(\n\t\t\t\t\t(typeof request === \"string\"\n\t\t\t\t\t\t? new Request(request, init)\n\t\t\t\t\t\t: request\n\t\t\t\t\t).url\n\t\t\t\t);\n\tif (url.port && url.port !== \"443\" && url.protocol === \"https:\") {\n\t\tif (!urls.has(url.toString())) {\n\t\t\turls.add(url.toString());\n\t\t\tconsole.warn(\n\t\t\t\t`WARNING: known issue with \\`fetch()\\` requests to custom HTTPS ports in published Workers:\\n` +\n\t\t\t\t\t` - ${url.toString()} - the custom port will be ignored when the Worker is published using the \\`wrangler deploy\\` command.\\n`\n\t\t\t);\n\t\t}\n\t}\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\tconst [request, init] = argArray;\n\t\tcheckURL(request, init);\n\t\treturn Reflect.apply(target, thisArg, argArray);\n\t},\n});\n", "// ============================================================\n// CONFIG.JS - Constants, Scores, and Configuration\n// v18.7.0 - Added Edge Detection System\n// ============================================================\n\nexport const POLYMARKET_API = \"https://data-api.polymarket.com\";\nexport const GAMMA_API = \"https://gamma-api.polymarket.com\";\nexport const CLOB_API = \"https://clob.polymarket.com\";\nexport const ODDS_API_BASE = \"https://api.the-odds-api.com/v4\";\n\n// External data sources\nexport const EXTERNAL_SOURCES = {\n  VSIN: \"https://data.vsin.com\",\n  DK_NETWORK: \"https://dknetwork.draftkings.com\"\n};\n\n// SCORING SYSTEM v8 - Adaptive Learning System\nexport const SCORES = {\n  // WHALE BET SIZE (single bet)\n  WHALE_BET_MASSIVE: 80,\n  WHALE_BET_LARGE: 60,\n  WHALE_BET_NOTABLE: 45,\n  WHALE_BET_MEDIUM: 30,\n  WHALE_BET_SMALL: 15,\n  \n  // CONCENTRATION\n  CONCENTRATION_SINGLE_WHALE: 25,\n  CONCENTRATION_WHALE_DUO: 15,\n  CONCENTRATION_HIGH: 10,\n  \n  // FRESH WALLET + MONEY\n  FRESH_WHALE_HUGE: 80,\n  FRESH_WHALE_LARGE: 60,\n  FRESH_WHALE_NOTABLE: 45,\n  FRESH_WHALE_MEDIUM: 30,\n  FRESH_WALLET_SMALL: 15,\n  \n  // COORDINATED\n  COORDINATED_WHALES: 30,\n  COORDINATED_LARGE: 15,\n  \n  // VOLUME\n  VOLUME_HUGE: 25,\n  VOLUME_NOTABLE: 15,\n  VOLUME_MODERATE: 8,\n  \n  // EXTREME ODDS\n  EXTREME_LONGSHOT: 35,\n  EXTREME_HEAVY_FAVORITE: 25,\n  MODERATE_LONGSHOT: 15,\n  MODERATE_FAVORITE: 10,\n  \n  // PROVEN WINNERS\n  PROVEN_WINNER_ELITE: 40,\n  PROVEN_WINNER_STRONG: 25,\n  PROVEN_WINNER_GOOD: 15,\n  PROVEN_WINNER_EDGE: 8,\n};\n\n// EDGE DETECTION SCORING (NEW!)\nexport const EDGE_SCORES = {\n  // Sharp money signals (from betting splits)\n  SHARP_MONEY_STRONG: 30,\n  SHARP_MONEY_MODERATE: 15,\n  \n  // Reverse line movement\n  RLM_STRONG: 25,\n  RLM_MODERATE: 12,\n  \n  // Pinnacle vs soft book divergence\n  PINNACLE_EDGE_LARGE: 20,  // 5%+ edge\n  PINNACLE_EDGE_MEDIUM: 10, // 3-5% edge\n  PINNACLE_EDGE_SMALL: 5,   // 2-3% edge\n  \n  // Steam moves\n  STEAM_MOVE: 35,\n  RAPID_LINE_MOVE: 15,\n  \n  // Polymarket divergence from Vegas\n  POLY_EDGE_HUGE: 25,       // 10%+ difference\n  POLY_EDGE_LARGE: 15,      // 5-10% difference\n  POLY_EDGE_MEDIUM: 8,      // 3-5% difference\n  \n  // Multiple signal confirmation\n  MULTI_SIGNAL_BONUS: 20,   // When 3+ signals agree\n  DUAL_SIGNAL_BONUS: 10,    // When 2 signals agree\n};\n\n// CONFIDENCE THRESHOLDS\nexport const CONFIDENCE_LEVELS = {\n  HIGH: 70,      // Strong recommendation\n  MEDIUM: 50,    // Worth considering\n  LOW: 30,       // Monitor\n  NOISE: 0       // Below threshold\n};\n\n// KV Storage Keys\nexport const KV_KEYS = {\n  PENDING_SIGNALS: \"pending_signals_v2\",\n  FACTOR_STATS: \"factor_stats_v2\",\n  SIGNALS_PREFIX: \"signal_\",\n  WALLETS_PREFIX: \"wallet:\",  // NOTE: colon not underscore - must match old format!\n  LAST_CRON_RUN: \"last_cron_run\",\n  CRON_STATS: \"cron_stats\",\n  // Edge detection keys (NEW!)\n  EDGE_CACHE_PREFIX: \"edge_detection_\",\n  LINE_MOVEMENT_PREFIX: \"line_movement_\",\n  BETTING_SPLITS_PREFIX: \"betting_splits_\",\n  SHARP_LINES_PREFIX: \"sharp_lines_\",\n};\n\nexport const KV_LINE_MOVEMENT_PREFIX = \"line_movement_\";\n\n// Wallet Tracking Configuration\nexport const WALLET_TRACK_RECORD = {\n  MIN_BETS_FOR_TRACKING: 3,\n  MIN_BETS_FOR_TIER: 5,\n  CACHE_HOURS: 24,\n  LOOKBACK_DAYS: 90,\n};\n\n// Wallet Tier Thresholds\nexport const WALLET_TIERS = {\n  INSIDER: { minWinRate: 75, minBets: 15, minVolume: 100000 },\n  ELITE: { minWinRate: 68, minBets: 10, minVolume: 50000 },\n  STRONG: { minWinRate: 60, minBets: 8, minVolume: 20000 },\n  AVERAGE: { minWinRate: 50, minBets: 5, minVolume: 0 },\n  FADE: { maxWinRate: 42, minBets: 8, minVolume: 0 },\n};\n\n// Sport key mapping for The Odds API\nexport const SPORT_KEY_MAP = {\n  'nfl': 'americanfootball_nfl',\n  'nba': 'basketball_nba',\n  'mlb': 'baseball_mlb',\n  'nhl': 'icehockey_nhl',\n  'ncaaf': 'americanfootball_ncaaf',\n  'cfb': 'americanfootball_ncaaf',  // Alias for Polymarket slug format\n  'ncaab': 'basketball_ncaab',\n  'cbb': 'basketball_ncaab',        // Alias for Polymarket slug format\n  'mma': 'mma_mixed_martial_arts',\n  'ufc': 'mma_mixed_martial_arts',\n  'epl': 'soccer_epl',\n  'ucl': 'soccer_uefa_champions_league',\n  'mls': 'soccer_usa_mls',\n  'wta': 'tennis_wta_australian_open',\n  'atp': 'tennis_atp_australian_open',\n  'lol': null,\n  'csgo': null,\n};\n\n// Book tier classification for edge detection\nexport const BOOK_TIERS = {\n  sharp: ['pinnacle', 'circa', 'bookmaker', 'betcris', 'betonline'],\n  soft: ['draftkings', 'fanduel', 'betmgm', 'caesars', 'pointsbet', 'wynnbet', 'espnbet', 'fanatics']\n};\n\n// Team name aliases for matching\nexport const TEAM_ALIASES = {\n  // NFL\n  'patriots': 'New England Patriots', 'ne': 'New England Patriots',\n  'broncos': 'Denver Broncos', 'den': 'Denver Broncos',\n  'chiefs': 'Kansas City Chiefs', 'kc': 'Kansas City Chiefs',\n  'bills': 'Buffalo Bills', 'buf': 'Buffalo Bills',\n  'dolphins': 'Miami Dolphins', 'mia': 'Miami Dolphins',\n  'jets': 'New York Jets', 'nyj': 'New York Jets',\n  'ravens': 'Baltimore Ravens', 'bal': 'Baltimore Ravens',\n  'steelers': 'Pittsburgh Steelers', 'pit': 'Pittsburgh Steelers',\n  'bengals': 'Cincinnati Bengals', 'cin': 'Cincinnati Bengals',\n  'browns': 'Cleveland Browns', 'cle': 'Cleveland Browns',\n  'texans': 'Houston Texans', 'hou': 'Houston Texans',\n  'colts': 'Indianapolis Colts', 'ind': 'Indianapolis Colts',\n  'jaguars': 'Jacksonville Jaguars', 'jax': 'Jacksonville Jaguars',\n  'titans': 'Tennessee Titans', 'ten': 'Tennessee Titans',\n  'cowboys': 'Dallas Cowboys', 'dal': 'Dallas Cowboys',\n  'eagles': 'Philadelphia Eagles', 'phi': 'Philadelphia Eagles',\n  'giants': 'New York Giants', 'nyg': 'New York Giants',\n  'commanders': 'Washington Commanders', 'was': 'Washington Commanders',\n  'bears': 'Chicago Bears', 'chi': 'Chicago Bears',\n  'lions': 'Detroit Lions', 'det': 'Detroit Lions',\n  'packers': 'Green Bay Packers', 'gb': 'Green Bay Packers',\n  'vikings': 'Minnesota Vikings', 'min': 'Minnesota Vikings',\n  'falcons': 'Atlanta Falcons', 'atl': 'Atlanta Falcons',\n  'panthers': 'Carolina Panthers', 'car': 'Carolina Panthers',\n  'saints': 'New Orleans Saints', 'no': 'New Orleans Saints',\n  'buccaneers': 'Tampa Bay Buccaneers', 'tb': 'Tampa Bay Buccaneers',\n  'cardinals': 'Arizona Cardinals', 'ari': 'Arizona Cardinals',\n  '49ers': 'San Francisco 49ers', 'sf': 'San Francisco 49ers',\n  'seahawks': 'Seattle Seahawks', 'sea': 'Seattle Seahawks',\n  'rams': 'Los Angeles Rams', 'lar': 'Los Angeles Rams',\n  'chargers': 'Los Angeles Chargers', 'lac': 'Los Angeles Chargers',\n  'raiders': 'Las Vegas Raiders', 'lv': 'Las Vegas Raiders',\n  // NBA\n  'lakers': 'Los Angeles Lakers', 'lal': 'Los Angeles Lakers',\n  'celtics': 'Boston Celtics', 'bos': 'Boston Celtics',\n  'warriors': 'Golden State Warriors', 'gsw': 'Golden State Warriors',\n  'bucks': 'Milwaukee Bucks', 'mil': 'Milwaukee Bucks',\n  'heat': 'Miami Heat',\n  'nuggets': 'Denver Nuggets',\n  'suns': 'Phoenix Suns', 'phx': 'Phoenix Suns',\n  'mavericks': 'Dallas Mavericks',\n  'clippers': 'Los Angeles Clippers',\n  'sixers': 'Philadelphia 76ers',\n  '76ers': 'Philadelphia 76ers',\n  'nets': 'Brooklyn Nets', 'bkn': 'Brooklyn Nets',\n  'knicks': 'New York Knicks', 'nyk': 'New York Knicks',\n  'raptors': 'Toronto Raptors', 'tor': 'Toronto Raptors',\n  'bulls': 'Chicago Bulls',\n  'cavaliers': 'Cleveland Cavaliers', 'cavs': 'Cleveland Cavaliers',\n  'pistons': 'Detroit Pistons',\n  'pacers': 'Indiana Pacers',\n  'hawks': 'Atlanta Hawks',\n  'hornets': 'Charlotte Hornets', 'cha': 'Charlotte Hornets',\n  'magic': 'Orlando Magic', 'orl': 'Orlando Magic',\n  'wizards': 'Washington Wizards',\n  'timberwolves': 'Minnesota Timberwolves', 'wolves': 'Minnesota Timberwolves',\n  'thunder': 'Oklahoma City Thunder', 'okc': 'Oklahoma City Thunder',\n  'blazers': 'Portland Trail Blazers', 'por': 'Portland Trail Blazers',\n  'jazz': 'Utah Jazz', 'uta': 'Utah Jazz',\n  'grizzlies': 'Memphis Grizzlies', 'mem': 'Memphis Grizzlies',\n  'pelicans': 'New Orleans Pelicans', 'nop': 'New Orleans Pelicans',\n  'spurs': 'San Antonio Spurs', 'sas': 'San Antonio Spurs',\n  'rockets': 'Houston Rockets',\n  'kings': 'Sacramento Kings', 'sac': 'Sacramento Kings',\n};\n\n// CORS Headers\nexport const corsHeaders = {\n  \"Access-Control-Allow-Origin\": \"*\",\n  \"Access-Control-Allow-Methods\": \"GET, POST, OPTIONS\",\n  \"Access-Control-Allow-Headers\": \"Content-Type\",\n};\n\n// Version\nexport const VERSION = \"18.12.0 - Directional odds + event timing + bet tracking\";\n", "// ============================================================\n// UTILS.JS - Helper Functions\n// v18.5.2 - Add college basketball (cbb) and college football (cfb) support\n// ============================================================\n\nimport { TEAM_ALIASES } from './config.js';\n\n// Get full team name from code\nexport function getTeamFullName(code) {\n  if (!code) return code;\n  return TEAM_ALIASES[code.toLowerCase()] || code;\n}\n\n// Detect sport from Polymarket slug\nexport function detectSportFromSlug(slug) {\n  if (!slug) return null;\n  const slugLower = slug.toLowerCase();\n  \n  // Pro leagues\n  if (slugLower.startsWith('nfl-') || slugLower.includes('-nfl-')) return 'nfl';\n  if (slugLower.startsWith('nba-') || slugLower.includes('-nba-')) return 'nba';\n  if (slugLower.startsWith('mlb-') || slugLower.includes('-mlb-')) return 'mlb';\n  if (slugLower.startsWith('nhl-') || slugLower.includes('-nhl-')) return 'nhl';\n  \n  // College sports - Polymarket uses 'cbb' and 'cfb' (not ncaab/ncaaf)\n  if (slugLower.startsWith('cbb-') || slugLower.includes('-cbb-')) return 'ncaab';\n  if (slugLower.startsWith('cfb-') || slugLower.includes('-cfb-')) return 'ncaaf';\n  // Also check legacy formats\n  if (slugLower.startsWith('ncaab-') || slugLower.includes('college-basketball')) return 'ncaab';\n  if (slugLower.startsWith('ncaaf-') || slugLower.includes('college-football')) return 'ncaaf';\n  \n  // Other sports\n  if (slugLower.startsWith('ufc-') || slugLower.startsWith('mma-')) return 'mma';\n  if (slugLower.startsWith('epl-') || slugLower.includes('premier-league')) return 'epl';\n  if (slugLower.startsWith('wta-')) return 'wta';\n  if (slugLower.startsWith('atp-')) return 'atp';\n  if (slugLower.startsWith('lol-')) return 'lol';\n  \n  return null;\n}\n\n// Extract team codes from Polymarket slug\nexport function extractTeamsFromSlug(slug) {\n  if (!slug) return null;\n  \n  // Match various formats: nba-lal-gsw-2026-01-28, cbb-duke-unc-2026-01-31\n  const match = slug.match(/^(?:nfl|nba|mlb|nhl|ncaaf|ncaab|cbb|cfb)-([a-z0-9]+)-([a-z0-9]+)-\\d{4}-\\d{2}-\\d{2}/i);\n  if (match) {\n    return { away: match[1].toLowerCase(), home: match[2].toLowerCase() };\n  }\n  return null;\n}\n\n// Convert American odds to implied probability\nexport function americanToProb(odds) {\n  if (odds > 0) {\n    return 100 / (odds + 100);\n  } else {\n    return Math.abs(odds) / (Math.abs(odds) + 100);\n  }\n}\n\n// Convert probability to American odds\nexport function probToAmerican(prob) {\n  if (prob >= 0.5) {\n    return Math.round(-100 * prob / (1 - prob));\n  } else {\n    return Math.round(100 * (1 - prob) / prob);\n  }\n}\n\n// ============================================================\n// MARKET CLASSIFICATION - Determines if market is a real game\n// ============================================================\n\n// Keywords that indicate FUTURES/PROPS (NOT actual games)\nconst FUTURES_KEYWORDS = [\n  // Season/Championship futures\n  'win the', 'winner', 'championship', 'super bowl winner', 'world series winner',\n  'stanley cup winner', 'nba champion', 'nfl champion', 'mlb champion',\n  'premier league winner', 'premier league', 'champions league winner',\n  'win the 20', 'win 20', // \"Will X win the 2025 championship\"\n  'ncaa tournament winner', 'march madness winner', 'final four',\n  \n  // Awards\n  'mvp', 'most valuable', 'rookie of the year', 'cy young', 'heisman',\n  'ballon d\\'or', 'dpoy', 'defensive player', 'coach of the year',\n  'naismith', 'player of the year',\n  \n  // Season totals\n  'win total', 'season wins', 'over/under wins', 'regular season',\n  'make the playoffs', 'miss the playoffs', 'playoff seed',\n  'division winner', 'conference winner', 'win the division',\n  'win the conference', 'first pick', 'draft',\n  'big east', 'big ten', 'big 12', 'acc', 'sec', 'pac-12', // Conference futures\n  \n  // Player props (season-long)\n  'passing yards', 'rushing yards', 'receiving yards', 'touchdowns',\n  'home runs', 'batting average', 'era', 'strikeouts',\n  'points per game', 'assists per game', 'rebounds per game',\n  'goals scored', 'clean sheets',\n  \n  // Transfer/Team news\n  'sign with', 'trade to', 'leave the', 'join the', 'transfer',\n  'retire', 'fired', 'hired', 'contract',\n  \n  // Other futures\n  'before', 'by the end of', 'this season', 'this year',\n  'all-star', 'pro bowl', 'hall of fame'\n];\n\n// Keywords that indicate ACTUAL GAMES\nconst GAME_KEYWORDS = [\n  'vs', 'vs.', '@', 'at',\n  'spread', 'moneyline', 'money line', 'ml',\n  'over/under', 'o/u', 'total points', 'total runs', 'total goals',\n  'game', 'match', 'bout', 'fight'\n];\n\n// Patterns for actual game slugs (team-team-date format)\nconst GAME_SLUG_PATTERNS = [\n  /^(nfl|nba|mlb|nhl|ncaaf|ncaab|cbb|cfb)-[a-z]+-[a-z]+-\\d{4}-\\d{2}-\\d{2}/i,  // nba-lal-gsw-2026-01-28, cbb-duke-unc-2026-01-31\n  /^(ufc|mma)-[a-z]+-vs-[a-z]+-/i,  // ufc-jones-vs-miocic\n  /\\d{4}-\\d{2}-\\d{2}/  // Contains a specific date\n];\n\n/**\n * Determines if a market is an actual sports game (not futures/props)\n * @returns {object} { isGame: boolean, marketType: string, reason: string }\n */\nexport function classifyMarket(title, slug) {\n  const titleLower = (title || '').toLowerCase();\n  const slugLower = (slug || '').toLowerCase();\n  \n  // Check for futures keywords first (these disqualify as games)\n  for (const keyword of FUTURES_KEYWORDS) {\n    if (titleLower.includes(keyword)) {\n      return {\n        isGame: false,\n        marketType: 'futures',\n        reason: `Contains futures keyword: \"${keyword}\"`\n      };\n    }\n  }\n  \n  // Check slug pattern for game format\n  for (const pattern of GAME_SLUG_PATTERNS) {\n    if (pattern.test(slugLower)) {\n      return {\n        isGame: true,\n        marketType: 'game',\n        reason: 'Matches game slug pattern'\n      };\n    }\n  }\n  \n  // Check for game keywords\n  for (const keyword of GAME_KEYWORDS) {\n    if (titleLower.includes(keyword)) {\n      // Double-check it's not a futures market in disguise\n      if (!titleLower.includes('season') && !titleLower.includes('winner') && !titleLower.includes('champion')) {\n        return {\n          isGame: true,\n          marketType: 'game',\n          reason: `Contains game keyword: \"${keyword}\"`\n        };\n      }\n    }\n  }\n  \n  // Check for \"Team A vs Team B\" or \"Team A @ Team B\" patterns in title\n  if (/\\b[A-Z][a-z]+\\s+(vs\\.?|@|at)\\s+[A-Z][a-z]+\\b/.test(title)) {\n    return {\n      isGame: true,\n      marketType: 'game',\n      reason: 'Contains team vs team pattern'\n    };\n  }\n  \n  // Default: not a game\n  return {\n    isGame: false,\n    marketType: 'other',\n    reason: 'No game indicators found'\n  };\n}\n\n/**\n * Check if market should be included in sports scanner\n * Returns true only for actual games with dates\n */\nexport function isSportsGame(title, slug) {\n  const classification = classifyMarket(title, slug);\n  return classification.isGame;\n}\n\n// Detect market type from title (enhanced version)\nexport function detectMarketType(title, slug) {\n  if (!title) return \"other\";\n  const t = title.toLowerCase();\n  const s = (slug || '').toLowerCase();\n  \n  // Check if it's an actual sports game first\n  const classification = classifyMarket(title, slug);\n  if (classification.isGame) {\n    // Determine which sport\n    if (t.includes('nba') || s.includes('nba-')) return 'sports-nba';\n    if (t.includes('nfl') || s.includes('nfl-')) return 'sports-nfl';\n    if (t.includes('mlb') || s.includes('mlb-')) return 'sports-mlb';\n    if (t.includes('nhl') || s.includes('nhl-')) return 'sports-nhl';\n    // College sports - check for cbb/cfb slugs\n    if (s.startsWith('cbb-') || t.includes('college basketball') || t.includes('ncaab')) return 'sports-ncaab';\n    if (s.startsWith('cfb-') || t.includes('college football') || t.includes('ncaaf')) return 'sports-ncaaf';\n    if (t.includes('ncaa') || t.includes('college')) return 'sports-ncaa';\n    if (t.includes('ufc') || t.includes('mma')) return 'sports-mma';\n    if (t.includes('soccer') || t.includes('premier') || t.includes('champions league')) return 'sports-soccer';\n    return 'sports-other';\n  }\n  \n  // Check for futures/props (sports but not games)\n  if (classification.marketType === 'futures') {\n    return 'sports-futures';\n  }\n  \n  // Non-sports categories\n  if (t.includes(\"president\") || t.includes(\"election\") || t.includes(\"trump\") || \n      t.includes(\"biden\") || t.includes(\"democrat\") || t.includes(\"republican\") ||\n      t.includes(\"governor\") || t.includes(\"senate\") || t.includes(\"congress\")) {\n    return \"politics\";\n  }\n  if (t.includes(\"bitcoin\") || t.includes(\"ethereum\") || t.includes(\"crypto\") || \n      t.includes(\"btc\") || t.includes(\"eth\") || t.includes(\"sol\") || t.includes(\"doge\")) {\n    return \"crypto\";\n  }\n  if (t.includes(\"fed\") || t.includes(\"interest rate\") || t.includes(\"inflation\") ||\n      t.includes(\"stock\") || t.includes(\"s&p\") || t.includes(\"nasdaq\")) {\n    return \"finance\";\n  }\n  \n  return \"other\";\n}\n\n// Check if event has already started\nexport function hasEventStarted(title, slug, avgPrice) {\n  const now = Date.now();\n  const EST_OFFSET = -5 * 60 * 60 * 1000;\n  const estNow = new Date(now + EST_OFFSET);\n  const currentHourEST = estNow.getUTCHours();\n  \n  const todayYear = estNow.getUTCFullYear();\n  const todayMonth = estNow.getUTCMonth() + 1;\n  const todayDay = estNow.getUTCDate();\n  const todayStr = `${todayYear}-${String(todayMonth).padStart(2, '0')}-${String(todayDay).padStart(2, '0')}`;\n  \n  const dateMatch = (slug || '').match(/(\\d{4})-(\\d{2})-(\\d{2})/);\n  \n  if (dateMatch) {\n    const eventDateStr = dateMatch[0];\n    const eventYear = parseInt(dateMatch[1]);\n    const eventMonth = parseInt(dateMatch[2]);\n    const eventDay = parseInt(dateMatch[3]);\n    \n    // If event date is before today, it's definitely started\n    if (eventDateStr < todayStr) {\n      return true;\n    }\n    \n    // If event is today, check time\n    if (eventDateStr === todayStr) {\n      // Most sports games start in evening (after 6pm EST)\n      // During day, assume not started. After 8pm, assume started.\n      if (currentHourEST >= 20) {\n        return true;\n      }\n      // Between 6pm-8pm, check price\n      if (currentHourEST >= 18 && (avgPrice > 90 || avgPrice < 10)) {\n        return true;\n      }\n    }\n  }\n  \n  // Check for extreme prices indicating completion\n  if (avgPrice > 95 || avgPrice < 5) {\n    return true;\n  }\n  \n  return false;\n}\n\n// Format currency\nexport function formatCurrency(amount) {\n  if (amount >= 1000000) {\n    return `$${(amount / 1000000).toFixed(1)}M`;\n  } else if (amount >= 1000) {\n    return `$${(amount / 1000).toFixed(0)}k`;\n  }\n  return `$${amount.toFixed(0)}`;\n}\n\n// Generate unique ID\nexport function generateId() {\n  return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);\n}", "// ============================================================\n// WALLETS.JS - Wallet Tracking (WINNER FOCUSED)\n// v18.9.0 - Only persist winning wallets, prune losers\n// ============================================================\n\nimport { KV_KEYS, WALLET_TIERS, WALLET_TRACK_RECORD } from './config.js';\n\n// Minimum thresholds for keeping a wallet\nconst KEEPER_THRESHOLDS = {\n  MIN_BETS: 3,           // Need at least 3 bets to evaluate\n  MIN_WIN_RATE: 55,      // Must be above 55% to keep long-term\n  MIN_VOLUME: 5000,      // Must have bet at least $5k total\n  ELITE_WIN_RATE: 65,    // Elite threshold\n  INSIDER_WIN_RATE: 75,  // Insider threshold\n};\n\n// NBA/Sports team name mappings for readable titles\nconst TEAM_ABBREVS = {\n  'lal': 'Lakers', 'lac': 'Clippers', 'gsw': 'Warriors', 'sac': 'Kings',\n  'phx': 'Suns', 'den': 'Nuggets', 'min': 'Timberwolves', 'okc': 'Thunder',\n  'por': 'Trail Blazers', 'uta': 'Jazz', 'dal': 'Mavericks', 'hou': 'Rockets',\n  'sas': 'Spurs', 'mem': 'Grizzlies', 'nop': 'Pelicans', 'bos': 'Celtics',\n  'bkn': 'Nets', 'nyk': 'Knicks', 'phi': 'Sixers', 'tor': 'Raptors',\n  'chi': 'Bulls', 'cle': 'Cavaliers', 'det': 'Pistons', 'ind': 'Pacers',\n  'mil': 'Bucks', 'atl': 'Hawks', 'cha': 'Hornets', 'mia': 'Heat',\n  'orl': 'Magic', 'was': 'Wizards', 'elc': 'Celtics', 'bar': 'Barcelona',\n  'bun': 'Bucks', 'dor': 'Dortmund', 'hei': 'Heat', 'cel': 'Celtics',\n  'hor': 'Hornets', 'pel': 'Pelicans'\n};\n\n// Format market title to be human-readable\nfunction formatMarketTitle(title) {\n  if (!title) return 'Unknown Market';\n  \n  // If it's already a readable title (contains spaces and no dates), return it\n  if (title.includes(' ') && !title.match(/^\\w{3}\\s\\w{3}\\s\\w{3}\\s\\d{4}/)) {\n    return title;\n  }\n  \n  // Try to parse slug format: \"lal-elc-bar-2026-01-31\" or \"lal elc bar 2026 01 31\"\n  const parts = title.toLowerCase().replace(/-/g, ' ').split(' ').filter(p => p);\n  \n  // Extract date if present\n  let dateStr = '';\n  const dateMatch = title.match(/(\\d{4})[-\\s](\\d{2})[-\\s](\\d{2})/);\n  if (dateMatch) {\n    const [, year, month, day] = dateMatch;\n    const date = new Date(year, parseInt(month) - 1, day);\n    dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });\n  }\n  \n  // Try to identify team abbreviations and expand them\n  const teams = [];\n  for (const part of parts) {\n    if (part.length === 3 && TEAM_ABBREVS[part]) {\n      teams.push(TEAM_ABBREVS[part]);\n    } else if (part.length === 3 && /^[a-z]+$/.test(part)) {\n      // Unknown 3-letter abbrev, capitalize it\n      teams.push(part.toUpperCase());\n    }\n  }\n  \n  if (teams.length >= 2) {\n    // Format as \"Team1 vs Team2 - Date\"\n    const matchup = `${teams[0]} vs ${teams[1]}`;\n    return dateStr ? `${matchup} - ${dateStr}` : matchup;\n  }\n  \n  // Fallback: just clean up the title\n  return title\n    .replace(/-/g, ' ')\n    .replace(/\\d{4}\\s?\\d{2}\\s?\\d{2}/g, '') // Remove dates\n    .split(' ')\n    .filter(w => w.length > 0)\n    .map(w => w.charAt(0).toUpperCase() + w.slice(1))\n    .join(' ')\n    .trim() || 'Unknown Market';\n}\n\n// Get wallet tier based on performance\nexport function getWalletTier(stats) {\n  if (!stats) return null;\n  \n  const { wins, losses, totalBets, totalVolume, winRate } = stats;\n  const calculatedWinRate = totalBets > 0 ? (wins / totalBets) * 100 : 0;\n  const wr = winRate || calculatedWinRate;\n  \n  if (totalBets < KEEPER_THRESHOLDS.MIN_BETS) return null;\n  \n  if (wr >= WALLET_TIERS.INSIDER.minWinRate && totalBets >= WALLET_TIERS.INSIDER.minBets && totalVolume >= WALLET_TIERS.INSIDER.minVolume) {\n    return { tier: 'INSIDER', winRate: wr, emoji: '\uD83C\uDFAF' };\n  }\n  if (wr >= WALLET_TIERS.ELITE.minWinRate && totalBets >= WALLET_TIERS.ELITE.minBets && totalVolume >= WALLET_TIERS.ELITE.minVolume) {\n    return { tier: 'ELITE', winRate: wr, emoji: '\uD83C\uDFC6' };\n  }\n  if (wr >= WALLET_TIERS.STRONG.minWinRate && totalBets >= WALLET_TIERS.STRONG.minBets && totalVolume >= WALLET_TIERS.STRONG.minVolume) {\n    return { tier: 'STRONG', winRate: wr, emoji: '\uD83D\uDCAA' };\n  }\n  if (wr >= WALLET_TIERS.AVERAGE.minWinRate && totalBets >= WALLET_TIERS.AVERAGE.minBets) {\n    return { tier: 'AVERAGE', winRate: wr, emoji: '\uD83D\uDCCA' };\n  }\n  if (wr <= WALLET_TIERS.FADE.maxWinRate && totalBets >= WALLET_TIERS.FADE.minBets) {\n    return { tier: 'FADE', winRate: wr, emoji: '\uD83D\uDEAB' };\n  }\n  \n  return null;\n}\n\n// Track a new wallet bet with FULL individual trade data\nexport async function trackWalletBet(env, walletAddress, betData) {\n  if (!env.SIGNALS_CACHE || !walletAddress) return null;\n  \n  const key = KV_KEYS.WALLETS_PREFIX + walletAddress.toLowerCase();\n  const tradesKey = `wallet_trades_${walletAddress.toLowerCase()}`;\n  \n  try {\n    let stats = await env.SIGNALS_CACHE.get(key, { type: \"json\" });\n    \n    if (!stats) {\n      stats = {\n        address: walletAddress.toLowerCase(),\n        firstSeen: new Date().toISOString(),\n        totalBets: 0,\n        wins: 0,\n        losses: 0,\n        pending: 0,\n        totalVolume: 0,\n        winRate: 0,\n        profitLoss: 0,\n        tier: null,\n        currentStreak: 0,\n        bestStreak: 0,\n        recentBets: []\n      };\n    }\n    \n    // Generate unique trade ID\n    const tradeId = `${betData.signalId || betData.market}-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;\n    \n    // Check for duplicate bet (same market + similar amount within 5 minutes)\n    const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);\n    const isDuplicate = stats.recentBets.some(existing => {\n      const sameMarket = (existing.market || '').toLowerCase() === (betData.market || '').toLowerCase() ||\n                         existing.signalId === betData.signalId;\n      const sameAmount = Math.abs((existing.amount || 0) - (betData.amount || 0)) < 10;\n      const recentEnough = new Date(existing.timestamp).getTime() > fiveMinutesAgo;\n      return sameMarket && sameAmount && recentEnough;\n    });\n    \n    if (isDuplicate) {\n      console.log(`Skipping duplicate bet for wallet ${walletAddress.slice(0,8)}... on ${betData.market}`);\n      return stats;\n    }\n    \n    // Create detailed trade record\n    const tradeRecord = {\n      id: tradeId,\n      signalId: betData.signalId,\n      market: betData.market,\n      marketTitle: betData.marketTitle || betData.market,\n      direction: betData.direction,\n      amount: betData.amount || 0,\n      price: betData.price || 0,\n      timestamp: new Date().toISOString(),\n      outcome: null,\n      settledAt: null,\n      // P&L tracking fields\n      invested: betData.amount || 0,\n      returned: 0,\n      pnl: 0,\n      roi: 0,\n      // Current value tracking (for open positions)\n      currentPrice: betData.price || 0,\n      currentValue: betData.amount || 0,\n      unrealizedPnl: 0\n    };\n    \n    stats.pending += 1;\n    stats.totalVolume += betData.amount || 0;\n    stats.lastBetAt = new Date().toISOString();\n    \n    // Add to recent bets (keep last 50 for display)\n    stats.recentBets.unshift(tradeRecord);\n    if (stats.recentBets.length > 50) {\n      stats.recentBets = stats.recentBets.slice(0, 50);\n    }\n    \n    // ALSO store in separate trades storage (for full history)\n    await storeIndividualTrade(env, walletAddress, tradeRecord);\n    \n    await env.SIGNALS_CACHE.put(key, JSON.stringify(stats), {\n      expirationTtl: 90 * 24 * 60 * 60\n    });\n    \n    await addToWalletIndex(env, walletAddress);\n    \n    return stats;\n  } catch (e) {\n    console.error(\"Error tracking wallet bet:\", e.message);\n    return null;\n  }\n}\n\n// Store individual trade in separate KV for full history\nasync function storeIndividualTrade(env, walletAddress, trade) {\n  if (!env.SIGNALS_CACHE) return;\n  \n  const tradesKey = `wallet_trades_${walletAddress.toLowerCase()}`;\n  \n  try {\n    let trades = await env.SIGNALS_CACHE.get(tradesKey, { type: 'json' }) || { \n      open: [], \n      resolved: [],\n      lastUpdated: null \n    };\n    \n    // Add to open trades\n    trades.open.unshift(trade);\n    \n    // Keep last 100 open trades max\n    if (trades.open.length > 100) {\n      trades.open = trades.open.slice(0, 100);\n    }\n    \n    trades.lastUpdated = new Date().toISOString();\n    \n    await env.SIGNALS_CACHE.put(tradesKey, JSON.stringify(trades), {\n      expirationTtl: 180 * 24 * 60 * 60  // 6 months\n    });\n  } catch (e) {\n    console.error(\"Error storing individual trade:\", e.message);\n  }\n}\n\n// Record bet outcome with FULL P&L calculation\nexport async function recordWalletOutcome(env, walletAddress, outcome, profitLoss, marketType, betAmount, signalId) {\n  if (!env.SIGNALS_CACHE || !walletAddress) return null;\n  \n  const key = KV_KEYS.WALLETS_PREFIX + walletAddress.toLowerCase();\n  const tradesKey = `wallet_trades_${walletAddress.toLowerCase()}`;\n  \n  try {\n    let stats = await env.SIGNALS_CACHE.get(key, { type: \"json\" });\n    if (!stats) return null;\n    \n    // Calculate actual P&L based on outcome\n    // If WIN: returned = invested / price (shares bought), P&L = returned - invested\n    // If LOSS: returned = 0, P&L = -invested\n    let calculatedPnl = profitLoss || 0;\n    let returnedAmount = 0;\n    \n    // Find the bet in recentBets and update it\n    let betFound = false;\n    if (stats.recentBets) {\n      for (let i = 0; i < stats.recentBets.length; i++) {\n        const bet = stats.recentBets[i];\n        if ((signalId && bet.signalId === signalId) || \n            (bet.market && bet.market.toLowerCase().includes(signalId?.toLowerCase())) &&\n            bet.outcome === null) {\n          \n          const invested = bet.amount || betAmount || 0;\n          const entryPrice = bet.price || 0.5;\n          \n          if (outcome === \"WIN\") {\n            // Shares = invested / price, Return = shares * 1.0 (winning outcome pays $1)\n            const shares = invested / entryPrice;\n            returnedAmount = shares;\n            calculatedPnl = returnedAmount - invested;\n          } else if (outcome === \"LOSS\") {\n            returnedAmount = 0;\n            calculatedPnl = -invested;\n          }\n          \n          // Update the bet record with settlement info\n          stats.recentBets[i].outcome = outcome;\n          stats.recentBets[i].settledAt = new Date().toISOString();\n          stats.recentBets[i].returned = returnedAmount;\n          stats.recentBets[i].pnl = calculatedPnl;\n          stats.recentBets[i].roi = invested > 0 ? Math.round((calculatedPnl / invested) * 100) : 0;\n          \n          betFound = true;\n          break;\n        }\n      }\n    }\n    \n    // Also update in trades storage\n    await updateTradeOutcome(env, walletAddress, signalId, outcome, calculatedPnl, returnedAmount);\n    \n    stats.totalBets += 1;\n    stats.pending = Math.max(0, stats.pending - 1);\n    \n    if (outcome === \"WIN\") {\n      stats.wins += 1;\n      stats.currentStreak = Math.max(0, stats.currentStreak) + 1;\n      stats.bestStreak = Math.max(stats.bestStreak || 0, stats.currentStreak);\n    } else if (outcome === \"LOSS\") {\n      stats.losses += 1;\n      stats.currentStreak = Math.min(0, stats.currentStreak) - 1;\n    }\n    \n    stats.profitLoss = (stats.profitLoss || 0) + calculatedPnl;\n    stats.winRate = stats.totalBets > 0 ? Math.round((stats.wins / stats.totalBets) * 100) : 0;\n    stats.tier = getWalletTier(stats)?.tier || null;\n    \n    // Determine if wallet should be kept or pruned\n    const shouldKeep = evaluateWalletForKeeping(stats);\n    \n    if (shouldKeep) {\n      await env.SIGNALS_CACHE.put(key, JSON.stringify(stats), {\n        expirationTtl: 90 * 24 * 60 * 60\n      });\n      \n      // Update winning wallets cache if this is a winner\n      if (stats.winRate >= KEEPER_THRESHOLDS.MIN_WIN_RATE && stats.totalBets >= KEEPER_THRESHOLDS.MIN_BETS) {\n        await updateWinningWalletsCache(env, walletAddress, stats);\n      }\n    } else if (stats.totalBets >= 5 && stats.winRate < 45) {\n      // Prune consistent losers after 5+ bets\n      console.log(`Pruning losing wallet ${walletAddress.slice(0,8)}... (${stats.winRate}% over ${stats.totalBets} bets)`);\n      await removeFromWalletIndex(env, walletAddress);\n      await env.SIGNALS_CACHE.delete(key);\n    }\n    \n    return stats;\n  } catch (e) {\n    console.error(\"Error recording wallet outcome:\", e.message);\n    return null;\n  }\n}\n\n// Update trade outcome in separate trades storage\nasync function updateTradeOutcome(env, walletAddress, signalId, outcome, pnl, returned) {\n  if (!env.SIGNALS_CACHE) return;\n  \n  const tradesKey = `wallet_trades_${walletAddress.toLowerCase()}`;\n  \n  try {\n    let trades = await env.SIGNALS_CACHE.get(tradesKey, { type: 'json' });\n    if (!trades) return;\n    \n    // Find and move trade from open to resolved\n    const tradeIndex = trades.open.findIndex(t => \n      t.signalId === signalId || \n      (t.market && t.market.toLowerCase().includes(signalId?.toLowerCase()))\n    );\n    \n    if (tradeIndex >= 0) {\n      const trade = trades.open[tradeIndex];\n      \n      // Update trade with settlement info\n      trade.outcome = outcome;\n      trade.settledAt = new Date().toISOString();\n      trade.returned = returned;\n      trade.pnl = pnl;\n      trade.roi = trade.invested > 0 ? Math.round((pnl / trade.invested) * 100) : 0;\n      \n      // Move to resolved\n      trades.resolved.unshift(trade);\n      trades.open.splice(tradeIndex, 1);\n      \n      // Keep last 200 resolved trades\n      if (trades.resolved.length > 200) {\n        trades.resolved = trades.resolved.slice(0, 200);\n      }\n      \n      trades.lastUpdated = new Date().toISOString();\n      \n      await env.SIGNALS_CACHE.put(tradesKey, JSON.stringify(trades), {\n        expirationTtl: 180 * 24 * 60 * 60\n      });\n    }\n  } catch (e) {\n    console.error(\"Error updating trade outcome:\", e.message);\n  }\n}\n\n// Evaluate if wallet should be kept\nfunction evaluateWalletForKeeping(stats) {\n  // Always keep wallets with pending bets\n  if (stats.pending > 0) return true;\n  \n  // Keep if not enough data yet\n  if (stats.totalBets < KEEPER_THRESHOLDS.MIN_BETS) return true;\n  \n  // Keep winners\n  if (stats.winRate >= KEEPER_THRESHOLDS.MIN_WIN_RATE) return true;\n  \n  // Keep high volume (even if not winning yet)\n  if (stats.totalVolume >= 50000) return true;\n  \n  // Keep recent activity (within 7 days)\n  if (stats.lastBetAt) {\n    const daysSinceLastBet = (Date.now() - new Date(stats.lastBetAt).getTime()) / (24 * 60 * 60 * 1000);\n    if (daysSinceLastBet < 7) return true;\n  }\n  \n  return false;\n}\n\n// ============================================================\n// GET WALLET P&L - Full trade history with calculations\n// ============================================================\nexport async function getWalletPnL(env, walletAddress) {\n  if (!env.SIGNALS_CACHE || !walletAddress) {\n    return { success: false, error: \"Invalid request\" };\n  }\n  \n  const key = KV_KEYS.WALLETS_PREFIX + walletAddress.toLowerCase();\n  const tradesKey = `wallet_trades_${walletAddress.toLowerCase()}`;\n  \n  try {\n    // Get wallet stats\n    const stats = await env.SIGNALS_CACHE.get(key, { type: \"json\" });\n    if (!stats) {\n      return { success: false, error: \"Wallet not found\" };\n    }\n    \n    // Get detailed trades\n    let trades = await env.SIGNALS_CACHE.get(tradesKey, { type: 'json' });\n    \n    // If no separate trades storage, use recentBets\n    if (!trades) {\n      trades = {\n        open: [],\n        resolved: [],\n        lastUpdated: null\n      };\n      \n      // Populate from recentBets - DEDUPLICATE by market+amount\n      const seen = new Map();\n      \n      if (stats.recentBets && stats.recentBets.length > 0) {\n        for (const bet of stats.recentBets) {\n          // Deduplicate\n          const dedupKey = `${(bet.market || bet.signalId || '').toLowerCase()}-${Math.round(bet.amount || 0)}`;\n          if (seen.has(dedupKey)) continue;\n          seen.set(dedupKey, true);\n          \n          const invested = bet.amount || 0;\n          const entryPrice = bet.price || 0.5;\n          \n          // CALCULATE P&L if bet has outcome but no pnl stored\n          let returned = bet.returned || 0;\n          let pnl = bet.pnl || 0;\n          let roi = bet.roi || 0;\n          \n          if (bet.outcome === 'WIN' && pnl === 0 && invested > 0) {\n            // WIN: shares = invested / price, return = shares * $1\n            const shares = invested / entryPrice;\n            returned = Math.round(shares * 100) / 100;\n            pnl = Math.round((returned - invested) * 100) / 100;\n            roi = Math.round((pnl / invested) * 100);\n          } else if (bet.outcome === 'LOSS' && pnl === 0 && invested > 0) {\n            // LOSS: lose everything\n            returned = 0;\n            pnl = -invested;\n            roi = -100;\n          }\n          \n          // Format market title - make it readable\n          let marketTitle = bet.marketTitle || bet.market || '';\n          marketTitle = formatMarketTitle(marketTitle);\n          \n          const tradeRecord = {\n            id: bet.id || `${bet.signalId || bet.market}-${bet.timestamp}`,\n            signalId: bet.signalId,\n            market: bet.market,\n            marketTitle: marketTitle,\n            direction: bet.direction,\n            amount: invested,\n            price: entryPrice,\n            timestamp: bet.timestamp,\n            outcome: bet.outcome,\n            settledAt: bet.settledAt,\n            invested: invested,\n            returned: returned,\n            pnl: pnl,\n            roi: roi,\n            currentPrice: bet.currentPrice || entryPrice,\n            currentValue: bet.currentValue || invested,\n            unrealizedPnl: bet.unrealizedPnl || 0\n          };\n          \n          // Separate based on outcome - if it has outcome, it's resolved\n          if (bet.outcome === 'WIN' || bet.outcome === 'LOSS') {\n            trades.resolved.push(tradeRecord);\n          } else {\n            trades.open.push(tradeRecord);\n          }\n        }\n      }\n    }\n    \n    // Calculate summary P&L stats\n    const totalInvested = [...trades.open, ...trades.resolved].reduce((sum, t) => sum + (t.invested || t.amount || 0), 0);\n    const totalReturned = trades.resolved.reduce((sum, t) => sum + (t.returned || 0), 0);\n    const realizedPnl = trades.resolved.reduce((sum, t) => sum + (t.pnl || 0), 0);\n    \n    // Calculate unrealized P&L for open positions (estimate based on current holdings)\n    let unrealizedPnl = 0;\n    for (const trade of trades.open) {\n      // If we had current market prices, we'd calculate here\n      // For now, estimate based on entry price\n      const currentValue = trade.currentValue || trade.amount || 0;\n      const invested = trade.invested || trade.amount || 0;\n      trade.unrealizedPnl = currentValue - invested;\n      unrealizedPnl += trade.unrealizedPnl;\n    }\n    \n    const totalPnl = realizedPnl + unrealizedPnl;\n    const roi = totalInvested > 0 ? Math.round((totalPnl / totalInvested) * 100) : 0;\n    \n    return {\n      success: true,\n      address: walletAddress.toLowerCase(),\n      \n      // Summary stats\n      summary: {\n        totalPnl: Math.round(totalPnl * 100) / 100,\n        realizedPnl: Math.round(realizedPnl * 100) / 100,\n        unrealizedPnl: Math.round(unrealizedPnl * 100) / 100,\n        totalInvested: Math.round(totalInvested * 100) / 100,\n        totalReturned: Math.round(totalReturned * 100) / 100,\n        roi,\n        wins: stats.wins || 0,\n        losses: stats.losses || 0,\n        pending: stats.pending || 0,\n        winRate: stats.winRate || 0,\n        totalVolume: stats.totalVolume || 0,\n        currentStreak: stats.currentStreak || 0,\n        bestStreak: stats.bestStreak || 0\n      },\n      \n      // Detailed trade arrays\n      openBets: trades.open.map(t => ({\n        id: t.id,\n        market: t.market,\n        marketTitle: t.marketTitle || t.market,\n        direction: t.direction,\n        invested: t.invested || t.amount || 0,\n        entryPrice: t.price || 0,\n        currentPrice: t.currentPrice || t.price || 0,\n        currentValue: t.currentValue || t.invested || 0,\n        unrealizedPnl: t.unrealizedPnl || 0,\n        roi: t.roi || 0,\n        timestamp: t.timestamp\n      })),\n      \n      resolvedBets: trades.resolved.map(t => ({\n        id: t.id,\n        market: t.market,\n        marketTitle: t.marketTitle || t.market,\n        direction: t.direction,\n        outcome: t.outcome,\n        invested: t.invested || t.amount || 0,\n        entryPrice: t.price || 0,\n        returned: t.returned || 0,\n        pnl: t.pnl || 0,\n        roi: t.roi || 0,\n        timestamp: t.timestamp,\n        settledAt: t.settledAt\n      })),\n      \n      lastUpdated: trades.lastUpdated || stats.lastBetAt\n    };\n    \n  } catch (e) {\n    console.error(\"Error getting wallet P&L:\", e.message);\n    return { success: false, error: e.message };\n  }\n}\n\n// Update winning wallets cache (fast lookup for scans)\nasync function updateWinningWalletsCache(env, walletAddress, stats) {\n  if (!env.SIGNALS_CACHE) return;\n  \n  try {\n    let cache = await env.SIGNALS_CACHE.get('winning_wallets_cache', { type: 'json' }) || { wallets: {}, timestamp: 0 };\n    \n    cache.wallets[walletAddress.toLowerCase()] = {\n      isWinner: true,\n      winRate: stats.winRate,\n      record: `${stats.wins}W-${stats.losses}L`,\n      tier: stats.tier,\n      totalBets: stats.totalBets\n    };\n    \n    cache.timestamp = Date.now();\n    \n    // Keep only top 100 winning wallets\n    const entries = Object.entries(cache.wallets);\n    if (entries.length > 100) {\n      entries.sort((a, b) => b[1].winRate - a[1].winRate);\n      cache.wallets = Object.fromEntries(entries.slice(0, 100));\n    }\n    \n    await env.SIGNALS_CACHE.put('winning_wallets_cache', JSON.stringify(cache), {\n      expirationTtl: 24 * 60 * 60  // 24 hours\n    });\n  } catch (e) {\n    console.error(\"Error updating winning wallets cache:\", e.message);\n  }\n}\n\n// Get wallet stats\nexport async function getWalletStats(env, walletAddress) {\n  if (!env.SIGNALS_CACHE || !walletAddress) return null;\n  \n  const key = KV_KEYS.WALLETS_PREFIX + walletAddress.toLowerCase();\n  \n  try {\n    const stats = await env.SIGNALS_CACHE.get(key, { type: \"json\" });\n    if (stats) {\n      stats.tierInfo = getWalletTier(stats);\n    }\n    return stats;\n  } catch (e) {\n    return null;\n  }\n}\n\n// Add to wallet index\nasync function addToWalletIndex(env, walletAddress) {\n  if (!env.SIGNALS_CACHE) return;\n  \n  try {\n    const indexKey = \"tracked_wallet_index\";\n    let index = await env.SIGNALS_CACHE.get(indexKey, { type: \"json\" }) || [];\n    \n    const normalizedAddress = walletAddress.toLowerCase();\n    if (!index.includes(normalizedAddress)) {\n      index.push(normalizedAddress);\n      await env.SIGNALS_CACHE.put(indexKey, JSON.stringify(index), {\n        expirationTtl: 365 * 24 * 60 * 60\n      });\n    }\n  } catch (e) {}\n}\n\n// Remove from wallet index\nasync function removeFromWalletIndex(env, walletAddress) {\n  if (!env.SIGNALS_CACHE) return;\n  \n  try {\n    const indexKey = \"tracked_wallet_index\";\n    let index = await env.SIGNALS_CACHE.get(indexKey, { type: \"json\" }) || [];\n    \n    const normalizedAddress = walletAddress.toLowerCase();\n    index = index.filter(addr => addr !== normalizedAddress);\n    \n    await env.SIGNALS_CACHE.put(indexKey, JSON.stringify(index), {\n      expirationTtl: 365 * 24 * 60 * 60\n    });\n  } catch (e) {}\n}\n\n// Get tracked wallets\nexport async function getTrackedWallets(env) {\n  if (!env.SIGNALS_CACHE) return [];\n  try {\n    return await env.SIGNALS_CACHE.get(\"tracked_wallet_index\", { type: \"json\" }) || [];\n  } catch (e) {\n    return [];\n  }\n}\n\n// Get leaderboard (WINNERS ONLY)\nexport async function getWalletLeaderboard(env, limit = 50) {\n  const walletIndex = await getTrackedWallets(env);\n  const wallets = [];\n  \n  console.log(`Leaderboard: Checking ${walletIndex.length} wallets`);\n  \n  // Process in batches to avoid memory issues\n  const BATCH_SIZE = 50;\n  for (let i = 0; i < Math.min(walletIndex.length, 200); i += BATCH_SIZE) {\n    const batch = walletIndex.slice(i, i + BATCH_SIZE);\n    \n    for (const address of batch) {\n      if (!address) continue;\n      \n      const stats = await getWalletStats(env, address);\n      \n      // Only include wallets with meaningful data\n      if (stats && (stats.totalBets >= 1 || stats.pending > 0)) {\n        wallets.push({\n          address: stats.address || address,\n          wins: stats.wins || 0,\n          losses: stats.losses || 0,\n          pending: stats.pending || 0,\n          totalBets: stats.totalBets || 0,\n          winRate: stats.winRate || 0,\n          totalVolume: stats.totalVolume || 0,\n          tier: stats.tier || (stats.pending > 0 ? 'PENDING' : 'NEW'),\n          tierInfo: getWalletTier(stats),\n          profitLoss: stats.profitLoss || 0,\n          currentStreak: stats.currentStreak || 0,\n          bestStreak: stats.bestStreak || 0,\n          lastBetAt: stats.lastBetAt || null\n        });\n      }\n    }\n  }\n  \n  console.log(`Leaderboard: Found ${wallets.length} active wallets`);\n  \n  // Sort by: WINNERS FIRST, then by win rate\n  const tierOrder = { 'INSIDER': 0, 'ELITE': 1, 'STRONG': 2, 'AVERAGE': 3, 'PENDING': 4, 'NEW': 5, 'FADE': 6 };\n  wallets.sort((a, b) => {\n    // Winners (>55%) first\n    const aIsWinner = a.winRate >= 55 && a.totalBets >= 3;\n    const bIsWinner = b.winRate >= 55 && b.totalBets >= 3;\n    if (aIsWinner && !bIsWinner) return -1;\n    if (!aIsWinner && bIsWinner) return 1;\n    \n    // Then by tier\n    const tierDiff = (tierOrder[a.tier] || 99) - (tierOrder[b.tier] || 99);\n    if (tierDiff !== 0) return tierDiff;\n    \n    // Then by win rate\n    return b.winRate - a.winRate;\n  });\n  \n  return wallets.slice(0, limit);\n}\n\n// ============================================================\n// CLEANUP FUNCTIONS\n// ============================================================\n\n// Prune losing wallets and old data\nexport async function pruneLosingWallets(env) {\n  if (!env.SIGNALS_CACHE) return { pruned: 0, kept: 0 };\n  \n  const walletIndex = await getTrackedWallets(env);\n  let pruned = 0;\n  let kept = 0;\n  \n  console.log(`Pruning: Checking ${walletIndex.length} wallets`);\n  \n  for (const address of walletIndex) {\n    if (!address) continue;\n    \n    try {\n      const stats = await getWalletStats(env, address);\n      \n      if (!stats) {\n        await removeFromWalletIndex(env, address);\n        pruned++;\n        continue;\n      }\n      \n      // Prune if: 5+ bets AND below 45% win rate AND no pending\n      if (stats.totalBets >= 5 && stats.winRate < 45 && stats.pending === 0) {\n        const key = KV_KEYS.WALLETS_PREFIX + address.toLowerCase();\n        await env.SIGNALS_CACHE.delete(key);\n        await removeFromWalletIndex(env, address);\n        pruned++;\n        console.log(`Pruned: ${address.slice(0,8)}... (${stats.winRate}% over ${stats.totalBets} bets)`);\n      } else {\n        kept++;\n      }\n    } catch (e) {\n      pruned++;\n    }\n  }\n  \n  console.log(`Pruning complete: ${pruned} removed, ${kept} kept`);\n  return { pruned, kept };\n}\n\n// Clean up duplicate bets in all wallets\nexport async function deduplicateWalletBets(env) {\n  if (!env.SIGNALS_CACHE) return { walletsProcessed: 0, duplicatesRemoved: 0 };\n  \n  const walletIndex = await getTrackedWallets(env);\n  let walletsProcessed = 0;\n  let duplicatesRemoved = 0;\n  \n  console.log(`Deduplicating bets in ${walletIndex.length} wallets`);\n  \n  for (const address of walletIndex) {\n    if (!address) continue;\n    \n    try {\n      const key = KV_KEYS.WALLETS_PREFIX + address.toLowerCase();\n      const stats = await env.SIGNALS_CACHE.get(key, { type: 'json' });\n      \n      if (!stats || !stats.recentBets || stats.recentBets.length === 0) continue;\n      \n      const originalCount = stats.recentBets.length;\n      \n      // Deduplicate by market + amount\n      const seen = new Map();\n      const uniqueBets = [];\n      \n      for (const bet of stats.recentBets) {\n        const market = (bet.market || bet.signalId || '').toLowerCase();\n        const amount = Math.round(bet.amount || 0);\n        const key = `${market}-${amount}`;\n        \n        if (!seen.has(key)) {\n          seen.set(key, bet);\n          uniqueBets.push(bet);\n        } else {\n          // If this one has an outcome and existing doesn't, use this one\n          const existing = seen.get(key);\n          if (bet.outcome && !existing.outcome) {\n            existing.outcome = bet.outcome;\n            existing.settledAt = bet.settledAt;\n          }\n        }\n      }\n      \n      const removed = originalCount - uniqueBets.length;\n      \n      if (removed > 0) {\n        // Recalculate stats based on unique bets\n        const wins = uniqueBets.filter(b => b.outcome === 'WIN').length;\n        const losses = uniqueBets.filter(b => b.outcome === 'LOSS').length;\n        const pending = uniqueBets.filter(b => !b.outcome).length;\n        const totalBets = wins + losses;\n        \n        stats.recentBets = uniqueBets;\n        stats.wins = wins;\n        stats.losses = losses;\n        stats.pending = pending;\n        stats.totalBets = totalBets;\n        stats.winRate = totalBets > 0 ? Math.round((wins / totalBets) * 100) : 0;\n        \n        await env.SIGNALS_CACHE.put(key, JSON.stringify(stats), {\n          expirationTtl: 90 * 24 * 60 * 60\n        });\n        \n        duplicatesRemoved += removed;\n        console.log(`Wallet ${address.slice(0,8)}...: removed ${removed} duplicates, now ${stats.wins}W-${stats.losses}L (${stats.winRate}%)`);\n      }\n      \n      walletsProcessed++;\n    } catch (e) {\n      console.error(`Error deduplicating wallet ${address}:`, e.message);\n    }\n  }\n  \n  console.log(`Deduplication complete: ${walletsProcessed} wallets, ${duplicatesRemoved} duplicates removed`);\n  return { walletsProcessed, duplicatesRemoved };\n}\n\n// Clear all trade buckets (they're not needed after processing)\nexport async function clearTradeBuckets(env) {\n  if (!env.SIGNALS_CACHE) return { cleared: 0 };\n  \n  try {\n    const index = await env.SIGNALS_CACHE.get('trades_index', { type: 'json' }) || [];\n    let cleared = 0;\n    \n    for (const bucketKey of index) {\n      try {\n        await env.SIGNALS_CACHE.delete(bucketKey);\n        cleared++;\n      } catch (e) {}\n    }\n    \n    // Clear index\n    await env.SIGNALS_CACHE.delete('trades_index');\n    await env.SIGNALS_CACHE.delete('trades_last_poll');\n    await env.SIGNALS_CACHE.delete('trades_poll_stats');\n    \n    console.log(`Cleared ${cleared} trade buckets`);\n    return { cleared };\n  } catch (e) {\n    return { cleared: 0, error: e.message };\n  }\n}\n\n// Full KV cleanup\nexport async function fullKVCleanup(env) {\n  const results = {\n    tradeBuckets: await clearTradeBuckets(env),\n    walletPrune: await pruneLosingWallets(env)\n  };\n  \n  return results;\n}\n", "// ============================================================\n// LEARNING.JS - AI Learning, Factor Stats, Confidence & Trend Discovery\n// ============================================================\n\nimport { KV_KEYS } from './config.js';\n\n// KV keys for learning system\nconst LEARNING_KEYS = {\n  FACTOR_STATS: KV_KEYS.FACTOR_STATS,\n  DISCOVERED_PATTERNS: \"discovered_patterns\",\n  PATTERN_CANDIDATES: \"pattern_candidates\",\n  MARKET_TYPE_STATS: \"market_type_stats\",\n  TIME_PATTERNS: \"time_patterns\",\n  VOLUME_BRACKETS: \"volume_brackets\"\n};\n\n/**\n * Update factor statistics when a signal settles\n */\nexport async function updateFactorStats(env, factors, outcome) {\n  if (!env.SIGNALS_CACHE || !factors || factors.length === 0) return;\n  \n  try {\n    let factorStats = await env.SIGNALS_CACHE.get(LEARNING_KEYS.FACTOR_STATS, { type: \"json\" }) || {};\n    \n    for (const factor of factors) {\n      // Handle both { factor: 'name' } and { name: 'name' } formats\n      const factorName = typeof factor === 'object' ? (factor.factor || factor.name) : factor;\n      if (!factorName) continue;\n      \n      if (!factorStats[factorName]) {\n        factorStats[factorName] = {\n          wins: 0,\n          losses: 0,\n          winRate: 50,\n          weight: 1.0,\n          sampleSize: 0,\n          lastUpdated: null,\n          isDiscovered: false  // Track if this was auto-discovered\n        };\n      }\n      \n      if (outcome === \"WIN\") {\n        factorStats[factorName].wins += 1;\n      } else {\n        factorStats[factorName].losses += 1;\n      }\n      \n      const total = factorStats[factorName].wins + factorStats[factorName].losses;\n      factorStats[factorName].sampleSize = total;\n      factorStats[factorName].winRate = Math.round((factorStats[factorName].wins / total) * 100);\n      \n      // Dynamic weight based on performance AND sample size\n      // More data = more confidence in the weight\n      const sampleMultiplier = Math.min(1, total / 10); // Full weight at 10+ samples\n      const performanceWeight = 0.5 + (factorStats[factorName].winRate / 100) * 1.5;\n      factorStats[factorName].weight = 0.5 + (performanceWeight - 0.5) * sampleMultiplier;\n      \n      factorStats[factorName].lastUpdated = new Date().toISOString();\n    }\n    \n    await env.SIGNALS_CACHE.put(LEARNING_KEYS.FACTOR_STATS, JSON.stringify(factorStats), {\n      expirationTtl: 90 * 24 * 60 * 60\n    });\n    \n    return factorStats;\n  } catch (e) {\n    console.error(\"Error updating factor stats:\", e.message);\n    return null;\n  }\n}\n\n/**\n * Track additional signal metadata for pattern discovery\n */\nexport async function trackSignalMetadata(env, signal, outcome) {\n  if (!env.SIGNALS_CACHE) return;\n  \n  try {\n    // Track market type performance\n    await trackMarketTypePerformance(env, signal.marketType, outcome);\n    \n    // Track volume bracket performance\n    await trackVolumeBracket(env, signal.totalVolume, outcome);\n    \n    // Track time-of-day patterns\n    await trackTimePattern(env, signal.detectedAt, outcome);\n    \n    // Track wallet count patterns\n    await trackWalletCountPattern(env, signal.walletCount, outcome);\n    \n    // Track event timing patterns (NEW - improvement #5)\n    await trackEventTiming(env, signal, outcome);\n    \n    // Check for new pattern discoveries\n    await discoverNewPatterns(env);\n    \n  } catch (e) {\n    console.error(\"Error tracking signal metadata:\", e.message);\n  }\n}\n\n/**\n * Track market type performance (sports-nba, crypto, politics, etc.)\n */\nasync function trackMarketTypePerformance(env, marketType, outcome) {\n  if (!marketType) return;\n  \n  let stats = await env.SIGNALS_CACHE.get(LEARNING_KEYS.MARKET_TYPE_STATS, { type: \"json\" }) || {};\n  \n  if (!stats[marketType]) {\n    stats[marketType] = { wins: 0, losses: 0, winRate: 50 };\n  }\n  \n  if (outcome === \"WIN\") stats[marketType].wins++;\n  else stats[marketType].losses++;\n  \n  const total = stats[marketType].wins + stats[marketType].losses;\n  stats[marketType].winRate = Math.round((stats[marketType].wins / total) * 100);\n  \n  await env.SIGNALS_CACHE.put(LEARNING_KEYS.MARKET_TYPE_STATS, JSON.stringify(stats), {\n    expirationTtl: 90 * 24 * 60 * 60\n  });\n}\n\n/**\n * Track volume bracket performance\n */\nasync function trackVolumeBracket(env, volume, outcome) {\n  let stats = await env.SIGNALS_CACHE.get(LEARNING_KEYS.VOLUME_BRACKETS, { type: \"json\" }) || {};\n  \n  // Define volume brackets\n  let bracket;\n  if (volume >= 100000) bracket = \"vol_100k_plus\";\n  else if (volume >= 50000) bracket = \"vol_50k_100k\";\n  else if (volume >= 25000) bracket = \"vol_25k_50k\";\n  else if (volume >= 10000) bracket = \"vol_10k_25k\";\n  else bracket = \"vol_under_10k\";\n  \n  if (!stats[bracket]) {\n    stats[bracket] = { wins: 0, losses: 0, winRate: 50 };\n  }\n  \n  if (outcome === \"WIN\") stats[bracket].wins++;\n  else stats[bracket].losses++;\n  \n  const total = stats[bracket].wins + stats[bracket].losses;\n  stats[bracket].winRate = Math.round((stats[bracket].wins / total) * 100);\n  \n  await env.SIGNALS_CACHE.put(LEARNING_KEYS.VOLUME_BRACKETS, JSON.stringify(stats), {\n    expirationTtl: 90 * 24 * 60 * 60\n  });\n}\n\n/**\n * Track time-of-day patterns\n */\nasync function trackTimePattern(env, detectedAt, outcome) {\n  if (!detectedAt) return;\n  \n  let stats = await env.SIGNALS_CACHE.get(LEARNING_KEYS.TIME_PATTERNS, { type: \"json\" }) || {};\n  \n  const hour = new Date(detectedAt).getUTCHours();\n  let timeBlock;\n  if (hour >= 5 && hour < 12) timeBlock = \"morning_5_12\";\n  else if (hour >= 12 && hour < 17) timeBlock = \"afternoon_12_17\";\n  else if (hour >= 17 && hour < 22) timeBlock = \"evening_17_22\";\n  else timeBlock = \"night_22_5\";\n  \n  // Also track day of week\n  const day = new Date(detectedAt).getUTCDay();\n  const dayName = [\"sunday\", \"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\"][day];\n  \n  for (const pattern of [timeBlock, `day_${dayName}`]) {\n    if (!stats[pattern]) {\n      stats[pattern] = { wins: 0, losses: 0, winRate: 50 };\n    }\n    \n    if (outcome === \"WIN\") stats[pattern].wins++;\n    else stats[pattern].losses++;\n    \n    const total = stats[pattern].wins + stats[pattern].losses;\n    stats[pattern].winRate = Math.round((stats[pattern].wins / total) * 100);\n  }\n  \n  await env.SIGNALS_CACHE.put(LEARNING_KEYS.TIME_PATTERNS, JSON.stringify(stats), {\n    expirationTtl: 90 * 24 * 60 * 60\n  });\n}\n\n/**\n * Track wallet count patterns\n */\nasync function trackWalletCountPattern(env, walletCount, outcome) {\n  let stats = await env.SIGNALS_CACHE.get(LEARNING_KEYS.PATTERN_CANDIDATES, { type: \"json\" }) || {};\n  \n  let pattern;\n  if (walletCount === 1) pattern = \"single_wallet\";\n  else if (walletCount === 2) pattern = \"two_wallets\";\n  else if (walletCount <= 5) pattern = \"few_wallets_3_5\";\n  else pattern = \"many_wallets_6_plus\";\n  \n  if (!stats[pattern]) {\n    stats[pattern] = { wins: 0, losses: 0, winRate: 50, category: \"wallet_count\" };\n  }\n  \n  if (outcome === \"WIN\") stats[pattern].wins++;\n  else stats[pattern].losses++;\n  \n  const total = stats[pattern].wins + stats[pattern].losses;\n  stats[pattern].winRate = Math.round((stats[pattern].wins / total) * 100);\n  \n  await env.SIGNALS_CACHE.put(LEARNING_KEYS.PATTERN_CANDIDATES, JSON.stringify(stats), {\n    expirationTtl: 90 * 24 * 60 * 60\n  });\n}\n\n/**\n * IMPROVEMENT #5: Track event timing patterns\n * How close to event start was the bet placed?\n */\nasync function trackEventTiming(env, signal, outcome) {\n  if (!signal.marketSlug && !signal.marketTitle) return;\n  \n  const slug = signal.marketSlug || '';\n  const dateMatch = slug.match(/(\\d{4})-(\\d{2})-(\\d{2})/);\n  if (!dateMatch) return; // Non-dated markets (politics, crypto) skip this\n  \n  const eventDate = new Date(\n    parseInt(dateMatch[1]),\n    parseInt(dateMatch[2]) - 1,\n    parseInt(dateMatch[3])\n  );\n  eventDate.setUTCHours(24, 0, 0, 0); // End of event date \u2248 evening games\n  \n  // Use lastTradeTime if available, otherwise detectedAt\n  const betTime = signal.lastTradeTime \n    ? new Date(signal.lastTradeTime).getTime()\n    : signal.detectedAt \n      ? new Date(signal.detectedAt).getTime()\n      : null;\n  \n  if (!betTime || isNaN(betTime)) return;\n  \n  const hoursBeforeEvent = (eventDate.getTime() - betTime) / (1000 * 60 * 60);\n  \n  let timingFactor;\n  if (hoursBeforeEvent <= 0) timingFactor = 'betDuringEvent';\n  else if (hoursBeforeEvent <= 2) timingFactor = 'betLast2Hours';\n  else if (hoursBeforeEvent <= 6) timingFactor = 'betSameDay';\n  else if (hoursBeforeEvent <= 24) timingFactor = 'betDayBefore';\n  else if (hoursBeforeEvent <= 72) timingFactor = 'betEarlyDays';\n  else timingFactor = 'betVeryEarly';\n  \n  // Store in pattern_candidates for auto-discovery\n  let stats = await env.SIGNALS_CACHE.get(LEARNING_KEYS.PATTERN_CANDIDATES, { type: \"json\" }) || {};\n  \n  if (!stats[timingFactor]) {\n    stats[timingFactor] = { wins: 0, losses: 0, winRate: 50, category: \"event_timing\" };\n  }\n  \n  if (outcome === \"WIN\") stats[timingFactor].wins++;\n  else stats[timingFactor].losses++;\n  \n  const total = stats[timingFactor].wins + stats[timingFactor].losses;\n  stats[timingFactor].winRate = Math.round((stats[timingFactor].wins / total) * 100);\n  \n  await env.SIGNALS_CACHE.put(LEARNING_KEYS.PATTERN_CANDIDATES, JSON.stringify(stats), {\n    expirationTtl: 90 * 24 * 60 * 60\n  });\n}\n\n/**\n * Discover new patterns that should be promoted to official factors\n */\nasync function discoverNewPatterns(env) {\n  try {\n    const candidates = await env.SIGNALS_CACHE.get(LEARNING_KEYS.PATTERN_CANDIDATES, { type: \"json\" }) || {};\n    const timePatterns = await env.SIGNALS_CACHE.get(LEARNING_KEYS.TIME_PATTERNS, { type: \"json\" }) || {};\n    const volumeBrackets = await env.SIGNALS_CACHE.get(LEARNING_KEYS.VOLUME_BRACKETS, { type: \"json\" }) || {};\n    const marketTypes = await env.SIGNALS_CACHE.get(LEARNING_KEYS.MARKET_TYPE_STATS, { type: \"json\" }) || {};\n    \n    let factorStats = await env.SIGNALS_CACHE.get(LEARNING_KEYS.FACTOR_STATS, { type: \"json\" }) || {};\n    let discovered = await env.SIGNALS_CACHE.get(LEARNING_KEYS.DISCOVERED_PATTERNS, { type: \"json\" }) || [];\n    \n    // Check all pattern sources for promotable patterns\n    const allPatterns = { ...candidates, ...timePatterns, ...volumeBrackets, ...marketTypes };\n    \n    for (const [patternName, stats] of Object.entries(allPatterns)) {\n      const total = (stats.wins || 0) + (stats.losses || 0);\n      \n      // Promote pattern to official factor if:\n      // 1. At least 10 samples\n      // 2. Win rate >= 60% OR <= 35% (strong signal either way)\n      // 3. Not already a factor\n      if (total >= 10 && !factorStats[patternName]) {\n        if (stats.winRate >= 60 || stats.winRate <= 35) {\n          factorStats[patternName] = {\n            wins: stats.wins,\n            losses: stats.losses,\n            winRate: stats.winRate,\n            weight: 0.5 + (stats.winRate / 100) * 1.5,\n            sampleSize: total,\n            lastUpdated: new Date().toISOString(),\n            isDiscovered: true,\n            discoveredAt: new Date().toISOString(),\n            category: stats.category || \"auto_discovered\"\n          };\n          \n          if (!discovered.includes(patternName)) {\n            discovered.push(patternName);\n          }\n          \n          console.log(`\uD83D\uDD0D Discovered new pattern: ${patternName} (${stats.winRate}% over ${total} samples)`);\n        }\n      }\n    }\n    \n    await env.SIGNALS_CACHE.put(LEARNING_KEYS.FACTOR_STATS, JSON.stringify(factorStats), {\n      expirationTtl: 90 * 24 * 60 * 60\n    });\n    \n    await env.SIGNALS_CACHE.put(LEARNING_KEYS.DISCOVERED_PATTERNS, JSON.stringify(discovered), {\n      expirationTtl: 90 * 24 * 60 * 60\n    });\n    \n  } catch (e) {\n    console.error(\"Error discovering patterns:\", e.message);\n  }\n}\n\n/**\n * Calculate confidence score for a signal based on ALL available data\n */\nexport async function calculateConfidence(env, factors, signal = {}) {\n  if (!env.SIGNALS_CACHE) return null;\n  \n  try {\n    const factorStats = await env.SIGNALS_CACHE.get(LEARNING_KEYS.FACTOR_STATS, { type: \"json\" }) || {};\n    const marketTypeStats = await env.SIGNALS_CACHE.get(LEARNING_KEYS.MARKET_TYPE_STATS, { type: \"json\" }) || {};\n    const volumeBrackets = await env.SIGNALS_CACHE.get(LEARNING_KEYS.VOLUME_BRACKETS, { type: \"json\" }) || {};\n    const timePatterns = await env.SIGNALS_CACHE.get(LEARNING_KEYS.TIME_PATTERNS, { type: \"json\" }) || {};\n    \n    let components = [];\n    \n    // 1. Factor-based confidence (primary)\n    if (factors && factors.length > 0) {\n      let totalWeight = 0;\n      let weightedWinRate = 0;\n      \n      for (const factor of factors) {\n        // Handle both { factor: 'name' } and { name: 'name' } formats, or plain string\n        const factorName = typeof factor === 'object' ? (factor.factor || factor.name) : factor;\n        if (!factorName) continue;\n        \n        const stats = factorStats[factorName];\n        if (stats && stats.sampleSize >= 3) {\n          const weight = stats.weight || 1.0;\n          totalWeight += weight;\n          weightedWinRate += stats.winRate * weight;\n        }\n      }\n      \n      if (totalWeight > 0) {\n        components.push({\n          source: 'factors',\n          confidence: Math.round(weightedWinRate / totalWeight),\n          weight: 3  // Factors are most important\n        });\n      }\n    }\n    \n    // 2. Market type confidence\n    if (signal.marketType && marketTypeStats[signal.marketType]) {\n      const stats = marketTypeStats[signal.marketType];\n      if ((stats.wins + stats.losses) >= 5) {\n        components.push({\n          source: 'market_type',\n          confidence: stats.winRate,\n          weight: 1\n        });\n      }\n    }\n    \n    // 3. Volume bracket confidence\n    if (signal.totalVolume) {\n      let bracket;\n      if (signal.totalVolume >= 100000) bracket = \"vol_100k_plus\";\n      else if (signal.totalVolume >= 50000) bracket = \"vol_50k_100k\";\n      else if (signal.totalVolume >= 25000) bracket = \"vol_25k_50k\";\n      else if (signal.totalVolume >= 10000) bracket = \"vol_10k_25k\";\n      else bracket = \"vol_under_10k\";\n      \n      if (volumeBrackets[bracket]) {\n        const stats = volumeBrackets[bracket];\n        if ((stats.wins + stats.losses) >= 5) {\n          components.push({\n            source: 'volume',\n            confidence: stats.winRate,\n            weight: 1\n          });\n        }\n      }\n    }\n    \n    // 4. Time pattern confidence\n    if (signal.detectedAt) {\n      const hour = new Date(signal.detectedAt).getUTCHours();\n      let timeBlock;\n      if (hour >= 5 && hour < 12) timeBlock = \"morning_5_12\";\n      else if (hour >= 12 && hour < 17) timeBlock = \"afternoon_12_17\";\n      else if (hour >= 17 && hour < 22) timeBlock = \"evening_17_22\";\n      else timeBlock = \"night_22_5\";\n      \n      if (timePatterns[timeBlock]) {\n        const stats = timePatterns[timeBlock];\n        if ((stats.wins + stats.losses) >= 5) {\n          components.push({\n            source: 'time',\n            confidence: stats.winRate,\n            weight: 0.5\n          });\n        }\n      }\n    }\n    \n    // 5. Event timing confidence (NEW - how close to event)\n    const candidates = await env.SIGNALS_CACHE.get(LEARNING_KEYS.PATTERN_CANDIDATES, { type: \"json\" }) || {};\n    if (factors) {\n      const factorNames = factors.map(f => typeof f === 'object' ? (f.factor || f.name) : f).filter(Boolean);\n      const timingFactors = ['betDuringEvent', 'betLast2Hours', 'betSameDay', 'betDayBefore', 'betEarlyDays', 'betVeryEarly'];\n      \n      for (const tf of timingFactors) {\n        if (factorNames.includes(tf) && candidates[tf]) {\n          const stats = candidates[tf];\n          const total = (stats.wins || 0) + (stats.losses || 0);\n          if (total >= 5) {\n            components.push({\n              source: 'event_timing',\n              confidence: stats.winRate,\n              weight: 1.5  // Event timing is highly predictive\n            });\n            break; // Only one timing factor per signal\n          }\n        }\n      }\n    }\n    \n    // Calculate weighted average confidence\n    if (components.length === 0) {\n      return null;  // Not enough data\n    }\n    \n    let totalWeight = 0;\n    let weightedConfidence = 0;\n    \n    for (const comp of components) {\n      totalWeight += comp.weight;\n      weightedConfidence += comp.confidence * comp.weight;\n    }\n    \n    const finalConfidence = Math.round(weightedConfidence / totalWeight);\n    \n    return {\n      confidence: Math.max(0, Math.min(100, finalConfidence)),\n      components,\n      dataPoints: components.length\n    };\n  } catch (e) {\n    console.error(\"Error calculating confidence:\", e.message);\n    return null;\n  }\n}\n\n/**\n * Get factor statistics\n */\nexport async function getFactorStats(env) {\n  if (!env.SIGNALS_CACHE) return {};\n  \n  try {\n    return await env.SIGNALS_CACHE.get(LEARNING_KEYS.FACTOR_STATS, { type: \"json\" }) || {};\n  } catch (e) {\n    console.error(\"Error getting factor stats:\", e.message);\n    return {};\n  }\n}\n\n/**\n * Get all discovered patterns\n */\nexport async function getDiscoveredPatterns(env) {\n  if (!env.SIGNALS_CACHE) return { patterns: [], candidates: {} };\n  \n  try {\n    const discovered = await env.SIGNALS_CACHE.get(LEARNING_KEYS.DISCOVERED_PATTERNS, { type: \"json\" }) || [];\n    const candidates = await env.SIGNALS_CACHE.get(LEARNING_KEYS.PATTERN_CANDIDATES, { type: \"json\" }) || {};\n    const timePatterns = await env.SIGNALS_CACHE.get(LEARNING_KEYS.TIME_PATTERNS, { type: \"json\" }) || {};\n    const volumeBrackets = await env.SIGNALS_CACHE.get(LEARNING_KEYS.VOLUME_BRACKETS, { type: \"json\" }) || {};\n    const marketTypes = await env.SIGNALS_CACHE.get(LEARNING_KEYS.MARKET_TYPE_STATS, { type: \"json\" }) || {};\n    \n    // Find patterns close to promotion threshold\n    const allCandidates = { ...candidates, ...timePatterns, ...volumeBrackets, ...marketTypes };\n    const nearPromotion = [];\n    \n    for (const [name, stats] of Object.entries(allCandidates)) {\n      const total = (stats.wins || 0) + (stats.losses || 0);\n      if (total >= 5 && total < 10) {\n        nearPromotion.push({\n          name,\n          ...stats,\n          samplesNeeded: 10 - total\n        });\n      }\n    }\n    \n    return {\n      promotedPatterns: discovered,\n      nearPromotion: nearPromotion.sort((a, b) => b.winRate - a.winRate),\n      allTracking: {\n        candidates: Object.keys(candidates).length,\n        timePatterns: Object.keys(timePatterns).length,\n        volumeBrackets: Object.keys(volumeBrackets).length,\n        marketTypes: Object.keys(marketTypes).length\n      }\n    };\n  } catch (e) {\n    console.error(\"Error getting discovered patterns:\", e.message);\n    return { patterns: [], candidates: {} };\n  }\n}\n\n/**\n * Reset factor stats (for testing)\n */\nexport async function resetFactorStats(env) {\n  if (!env.SIGNALS_CACHE) return;\n  \n  try {\n    await env.SIGNALS_CACHE.put(LEARNING_KEYS.FACTOR_STATS, JSON.stringify({}));\n    await env.SIGNALS_CACHE.put(LEARNING_KEYS.DISCOVERED_PATTERNS, JSON.stringify([]));\n    await env.SIGNALS_CACHE.put(LEARNING_KEYS.PATTERN_CANDIDATES, JSON.stringify({}));\n    await env.SIGNALS_CACHE.put(LEARNING_KEYS.TIME_PATTERNS, JSON.stringify({}));\n    await env.SIGNALS_CACHE.put(LEARNING_KEYS.VOLUME_BRACKETS, JSON.stringify({}));\n    await env.SIGNALS_CACHE.put(LEARNING_KEYS.MARKET_TYPE_STATS, JSON.stringify({}));\n  } catch (e) {\n    console.error(\"Error resetting factor stats:\", e.message);\n  }\n}\n\n/**\n * Get AI recommendation based on current factor performance\n */\nexport async function getAIRecommendation(env) {\n  if (!env.SIGNALS_CACHE) return null;\n  \n  try {\n    const factorStats = await env.SIGNALS_CACHE.get(LEARNING_KEYS.FACTOR_STATS, { type: \"json\" }) || {};\n    const discoveredPatterns = await getDiscoveredPatterns(env);\n    const factors = Object.entries(factorStats);\n    \n    if (factors.length < 3) {\n      return {\n        hasRecommendation: false,\n        message: \"Need more data to generate recommendations\",\n        patternsTracking: discoveredPatterns.allTracking\n      };\n    }\n    \n    // Separate core factors from discovered\n    const coreFactors = factors.filter(([name, stats]) => !stats.isDiscovered);\n    const discoveredFactors = factors.filter(([name, stats]) => stats.isDiscovered);\n    \n    // Find best and worst performing factors (with sufficient data)\n    const sorted = factors\n      .filter(([name, stats]) => (stats.wins + stats.losses) >= 3)\n      .sort((a, b) => b[1].winRate - a[1].winRate);\n    \n    if (sorted.length < 2) {\n      return {\n        hasRecommendation: false,\n        message: \"Need more settled bets to generate recommendations\",\n        patternsTracking: discoveredPatterns.allTracking\n      };\n    }\n    \n    const bestFactors = sorted.slice(0, 3).map(([name, stats]) => ({\n      name,\n      winRate: stats.winRate,\n      record: `${stats.wins}W-${stats.losses}L`,\n      isDiscovered: stats.isDiscovered || false\n    }));\n    \n    const worstFactors = sorted.slice(-3).reverse().map(([name, stats]) => ({\n      name,\n      winRate: stats.winRate,\n      record: `${stats.wins}W-${stats.losses}L`,\n      isDiscovered: stats.isDiscovered || false\n    }));\n    \n    // Calculate overall confidence\n    const avgWinRate = sorted.reduce((sum, [_, s]) => sum + s.winRate, 0) / sorted.length;\n    \n    // Generate dynamic recommendation\n    let recommendation;\n    if (avgWinRate >= 60) {\n      recommendation = \"\uD83D\uDD25 System is running hot! High confidence in signals with top factors.\";\n    } else if (avgWinRate >= 55) {\n      recommendation = \"\uD83D\uDCC8 System performing above average. Follow signals with strong factor combinations.\";\n    } else if (avgWinRate >= 45) {\n      recommendation = \"\uD83D\uDCCA System at baseline. Be selective - prioritize signals with proven factors.\";\n    } else if (avgWinRate >= 35) {\n      recommendation = \"\u26A0\uFE0F System underperforming. Consider waiting or fading weak signals.\";\n    } else {\n      recommendation = \"\uD83D\uDEA8 System in drawdown. Recommend pausing until patterns stabilize.\";\n    }\n    \n    return {\n      hasRecommendation: true,\n      overallConfidence: Math.round(avgWinRate),\n      bestFactors,\n      worstFactors,\n      recommendation,\n      totalFactorsTracked: factors.length,\n      factorsWithData: sorted.length,\n      discoveredCount: discoveredFactors.length,\n      coreFactorsCount: coreFactors.length,\n      patternsNearPromotion: discoveredPatterns.nearPromotion.slice(0, 3),\n      patternsTracking: discoveredPatterns.allTracking\n    };\n  } catch (e) {\n    console.error(\"Error getting AI recommendation:\", e.message);\n    return null;\n  }\n}\n\n// ============================================================\n// FACTOR COMBO TRACKING (NEW!)\n// ============================================================\n\nconst COMBO_KEY = 'factor_combos_v1';\n\n/**\n * Track factor combinations when a signal settles\n * This helps identify which factor PAIRS perform best together\n */\nexport async function trackFactorCombo(env, factors, outcome) {\n  if (!env.SIGNALS_CACHE || !factors || factors.length < 2) return;\n  \n  try {\n    let combos = await env.SIGNALS_CACHE.get(COMBO_KEY, { type: 'json' }) || {};\n    \n    // Get unique factor names\n    const factorNames = factors.map(f => typeof f === 'object' ? (f.factor || f.name) : f).filter(Boolean);\n    \n    // Generate all 2-factor combinations\n    for (let i = 0; i < factorNames.length; i++) {\n      for (let j = i + 1; j < factorNames.length; j++) {\n        // Sort to ensure consistent key regardless of order\n        const combo = [factorNames[i], factorNames[j]].sort().join(' + ');\n        \n        if (!combos[combo]) {\n          combos[combo] = { \n            wins: 0, \n            losses: 0, \n            winRate: 50,\n            factors: [factorNames[i], factorNames[j]].sort(),\n            lastUpdated: null\n          };\n        }\n        \n        if (outcome === 'WIN') combos[combo].wins++;\n        else combos[combo].losses++;\n        \n        const total = combos[combo].wins + combos[combo].losses;\n        combos[combo].winRate = Math.round((combos[combo].wins / total) * 100);\n        combos[combo].lastUpdated = new Date().toISOString();\n      }\n    }\n    \n    // Prune combos with very few samples to save space\n    const prunedCombos = {};\n    for (const [key, stats] of Object.entries(combos)) {\n      if ((stats.wins + stats.losses) >= 2) {  // Keep if at least 2 samples\n        prunedCombos[key] = stats;\n      }\n    }\n    \n    await env.SIGNALS_CACHE.put(COMBO_KEY, JSON.stringify(prunedCombos), {\n      expirationTtl: 90 * 24 * 60 * 60\n    });\n    \n    return prunedCombos;\n  } catch (e) {\n    console.error(\"Error tracking factor combo:\", e.message);\n    return null;\n  }\n}\n\n/**\n * Get factor combo statistics\n * Returns best and worst performing factor combinations\n */\nexport async function getFactorCombos(env) {\n  if (!env.SIGNALS_CACHE) return { combos: [], bestCombos: [], worstCombos: [] };\n  \n  try {\n    const combos = await env.SIGNALS_CACHE.get(COMBO_KEY, { type: 'json' }) || {};\n    \n    // Convert to array and filter for sufficient data\n    const comboArray = Object.entries(combos)\n      .map(([name, stats]) => ({ name, ...stats }))\n      .filter(c => (c.wins + c.losses) >= 3)  // At least 3 samples\n      .sort((a, b) => b.winRate - a.winRate);\n    \n    return {\n      combos: comboArray,\n      bestCombos: comboArray.filter(c => c.winRate >= 60).slice(0, 10),\n      worstCombos: comboArray.filter(c => c.winRate <= 40).slice(-10).reverse(),\n      totalTracked: Object.keys(combos).length\n    };\n  } catch (e) {\n    console.error(\"Error getting factor combos:\", e.message);\n    return { combos: [], bestCombos: [], worstCombos: [] };\n  }\n}\n\n/**\n * Check if a signal has a historically strong factor combo\n */\nexport async function hasStrongCombo(env, factors) {\n  if (!env.SIGNALS_CACHE || !factors || factors.length < 2) return null;\n  \n  try {\n    const combos = await env.SIGNALS_CACHE.get(COMBO_KEY, { type: 'json' }) || {};\n    const factorNames = factors.map(f => typeof f === 'object' ? (f.factor || f.name) : f).filter(Boolean);\n    \n    let bestCombo = null;\n    let bestWinRate = 0;\n    \n    // Check all 2-factor combinations in this signal\n    for (let i = 0; i < factorNames.length; i++) {\n      for (let j = i + 1; j < factorNames.length; j++) {\n        const combo = [factorNames[i], factorNames[j]].sort().join(' + ');\n        const stats = combos[combo];\n        \n        if (stats && (stats.wins + stats.losses) >= 5 && stats.winRate > bestWinRate) {\n          bestWinRate = stats.winRate;\n          bestCombo = {\n            combo,\n            winRate: stats.winRate,\n            record: `${stats.wins}W-${stats.losses}L`\n          };\n        }\n      }\n    }\n    \n    return bestCombo;\n  } catch (e) {\n    return null;\n  }\n}", "// ============================================================\n// POLYMARKET-API.JS - Comprehensive Polymarket API Integration\n// v1.0.0 - Real-time prices via Gamma + CLOB APIs\n// ============================================================\n// \n// This module integrates with ALL useful Polymarket APIs:\n// \n// 1. GAMMA API (https://gamma-api.polymarket.com)\n//    - GET /markets - List all markets with current prices (outcomePrices)\n//    - GET /markets?slug=xxx - Get specific market by slug\n//    - GET /events - List events (groups of related markets)\n//    - GET /events/{id} - Get event details with all markets\n//    \n// 2. CLOB API (https://clob.polymarket.com) - Real-time orderbook\n//    - GET /midpoint?token_id=xxx - Get midpoint price (best bid + ask / 2)\n//    - GET /price?token_id=xxx&side=BUY - Get current buy/sell price\n//    - GET /book?token_id=xxx - Get full orderbook\n//    - GET /last-trade-price?token_id=xxx - Last executed trade price\n//    - GET /spread?token_id=xxx - Current bid-ask spread\n//\n// 3. DATA API (https://data-api.polymarket.com)\n//    - GET /trades - Recent trades with wallet info\n//    - GET /activity - Market activity feed\n//\n// ============================================================\n\nconst GAMMA_API = 'https://gamma-api.polymarket.com';\nconst CLOB_API = 'https://clob.polymarket.com';\nconst DATA_API = 'https://data-api.polymarket.com';\n\n// Cache durations\nconst CACHE_TTL = {\n  MARKETS_LIST: 5 * 60,      // 5 min - market list doesn't change often\n  MARKET_PRICES: 60,          // 1 min - prices update frequently\n  MIDPOINT: 30,               // 30 sec - real-time price\n  ORDERBOOK: 30,              // 30 sec - orderbook\n  SPORTS_MARKETS: 5 * 60,     // 5 min - sports market mapping\n};\n\n// ============================================================\n// GAMMA API - Market Discovery & Metadata\n// ============================================================\n\n/**\n * Fetch markets from Gamma API with filters\n * Returns markets with outcomePrices (real-time prices!)\n */\nexport async function getMarkets(env, options = {}) {\n  const {\n    limit = 100,\n    offset = 0,\n    closed = false,\n    active = true,\n    tag_slug = null,  // e.g., 'sports', 'nba', 'ncaa-cbb'\n    slug = null,      // specific market slug\n  } = options;\n\n  const cacheKey = `gamma_markets_${tag_slug || 'all'}_${limit}_${offset}`;\n  \n  // Check cache\n  if (env.SIGNALS_CACHE) {\n    try {\n      const cached = await env.SIGNALS_CACHE.get(cacheKey, { type: 'json' });\n      if (cached && (Date.now() - cached.timestamp) < CACHE_TTL.MARKETS_LIST * 1000) {\n        return { ...cached.data, fromCache: true };\n      }\n    } catch (e) {\n      console.error('Cache read error:', e.message);\n    }\n  }\n\n  try {\n    let url = `${GAMMA_API}/markets?limit=${limit}&offset=${offset}&closed=${closed}&active=${active}`;\n    if (tag_slug) url += `&tag_slug=${tag_slug}`;\n    if (slug) url += `&slug=${slug}`;\n\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`Gamma API error: ${response.status}`);\n    }\n\n    const markets = await response.json();\n    \n    // Parse and process markets\n    const processed = markets.map(m => parseMarket(m));\n\n    const result = {\n      success: true,\n      count: processed.length,\n      markets: processed,\n      timestamp: new Date().toISOString()\n    };\n\n    // Cache result\n    if (env.SIGNALS_CACHE) {\n      await env.SIGNALS_CACHE.put(cacheKey, JSON.stringify({\n        data: result,\n        timestamp: Date.now()\n      }), { expirationTtl: CACHE_TTL.MARKETS_LIST + 60 });\n    }\n\n    return result;\n  } catch (e) {\n    console.error('Gamma API error:', e.message);\n    return { success: false, error: e.message };\n  }\n}\n\n/**\n * Get a specific market by slug\n */\nexport async function getMarketBySlug(env, slug) {\n  const cacheKey = `gamma_market_${slug}`;\n  \n  if (env.SIGNALS_CACHE) {\n    try {\n      const cached = await env.SIGNALS_CACHE.get(cacheKey, { type: 'json' });\n      if (cached && (Date.now() - cached.timestamp) < CACHE_TTL.MARKET_PRICES * 1000) {\n        return { ...cached.data, fromCache: true };\n      }\n    } catch (e) {}\n  }\n\n  try {\n    const response = await fetch(`${GAMMA_API}/markets?slug=${slug}`);\n    if (!response.ok) throw new Error(`Gamma API error: ${response.status}`);\n    \n    const markets = await response.json();\n    if (!markets || markets.length === 0) {\n      return { success: false, error: 'Market not found' };\n    }\n\n    const market = parseMarket(markets[0]);\n    \n    const result = { success: true, market };\n\n    if (env.SIGNALS_CACHE) {\n      await env.SIGNALS_CACHE.put(cacheKey, JSON.stringify({\n        data: result,\n        timestamp: Date.now()\n      }), { expirationTtl: CACHE_TTL.MARKET_PRICES + 60 });\n    }\n\n    return result;\n  } catch (e) {\n    return { success: false, error: e.message };\n  }\n}\n\n/**\n * Get all sports markets for a specific sport\n * Uses /sports endpoint for series_id, then /events?series_id=&tag_id=100639 for game events\n * Each event = one game, containing multiple markets (moneyline, spread, props)\n * We extract only the moneyline market (slug matches event slug with no suffix)\n */\nexport async function getSportsMarkets(env, sport) {\n  const seriesIds = await getSportSeriesIds(env, sport);\n  \n  if (seriesIds.length === 0) {\n    console.log(`No series_ids found for sport: ${sport}`);\n    return { success: false, error: `No series_ids for ${sport}`, markets: [] };\n  }\n  \n  const cacheKey = `sports_events_v3_${sport}_${seriesIds.join('_')}`;\n  \n  if (env.SIGNALS_CACHE) {\n    try {\n      const cached = await env.SIGNALS_CACHE.get(cacheKey, { type: 'json' });\n      if (cached && (Date.now() - cached.timestamp) < CACHE_TTL.SPORTS_MARKETS * 1000) {\n        return { ...cached.data, fromCache: true };\n      }\n    } catch (e) {}\n  }\n\n  try {\n    // Query ALL series IDs and combine results\n    const allGameMarkets = [];\n    let totalEvents = 0;\n    \n    for (const seriesId of seriesIds) {\n      try {\n        const response = await fetch(\n          `${GAMMA_API}/events?series_id=${seriesId}&tag_id=100639&active=true&closed=false&limit=200&order=startTime&ascending=true`\n        );\n        \n        if (!response.ok) {\n          console.log(`Gamma events API error for series ${seriesId}: ${response.status}`);\n          continue;\n        }\n        \n        const events = await response.json();\n        console.log(`Series ${seriesId}: ${events.length} game events for ${sport}`);\n        totalEvents += events.length;\n        \n        for (const event of events) {\n          if (!event.markets || event.markets.length === 0) continue;\n          \n          const eventSlug = event.slug;\n          let moneylineMarket = null;\n          \n          // Strategy 1: exact slug match\n          moneylineMarket = event.markets.find(m => m.slug === eventSlug);\n          \n          // Strategy 2: slug with no suffix after date\n          if (!moneylineMarket) {\n            moneylineMarket = event.markets.find(m => {\n              const slug = m.slug || '';\n              return /^[a-z]+-[a-z]+-[a-z]+-\\d{4}-\\d{2}-\\d{2}$/.test(slug);\n            });\n          }\n          \n          // Strategy 3: outcomes are team names (not Yes/No/Over/Under)\n          if (!moneylineMarket) {\n            moneylineMarket = event.markets.find(m => {\n              const outcomes = typeof m.outcomes === 'string' ? JSON.parse(m.outcomes) : (m.outcomes || []);\n              if (outcomes.length !== 2) return false;\n              const o0 = outcomes[0].toLowerCase();\n              const o1 = outcomes[1].toLowerCase();\n              return o0 !== 'yes' && o0 !== 'no' && o0 !== 'over' && o0 !== 'under' \n                && !m.slug?.includes('-spread') && !m.slug?.includes('-total') \n                && !m.slug?.includes('-assists') && !m.slug?.includes('-points')\n                && !m.slug?.includes('-rebounds') && !m.slug?.includes('-1h-');\n            });\n          }\n          \n          if (moneylineMarket) {\n            const parsed = parseMarket(moneylineMarket);\n            parsed.eventSlug = event.slug;\n            parsed.eventTitle = event.title;\n            parsed.eventId = event.id;\n            parsed.gameStartTime = event.startDate;\n            parsed.totalMarketsInEvent = event.markets.length;\n            allGameMarkets.push(parsed);\n          }\n        }\n      } catch (seriesErr) {\n        console.error(`Error fetching series ${seriesId}:`, seriesErr.message);\n      }\n    }\n\n    console.log(`Total: ${allGameMarkets.length} moneyline markets from ${totalEvents} events across ${seriesIds.length} series`);\n\n    const result = {\n      success: true,\n      sport,\n      seriesIds,\n      source: 'events-api-v3',\n      count: allGameMarkets.length,\n      eventsCount: totalEvents,\n      markets: allGameMarkets,\n      timestamp: new Date().toISOString()\n    };\n\n    if (env.SIGNALS_CACHE) {\n      await env.SIGNALS_CACHE.put(cacheKey, JSON.stringify({\n        data: result,\n        timestamp: Date.now()\n      }), { expirationTtl: CACHE_TTL.SPORTS_MARKETS + 60 });\n    }\n\n    return result;\n  } catch (e) {\n    console.error(`getSportsMarkets error for ${sport}:`, e.message);\n    return { success: false, error: e.message, markets: [] };\n  }\n}\n\n/**\n * Get ALL series IDs for a sport from /sports endpoint\n * Returns array since some sports have multiple series (e.g. ncaab has March Madness + regular CBB)\n * Caches the mapping for 1 hour since it rarely changes\n */\nasync function getSportSeriesIds(env, sport) {\n  const cacheKey = 'polymarket_sports_metadata';\n  let sportsData = null;\n  \n  if (env.SIGNALS_CACHE) {\n    try {\n      const cached = await env.SIGNALS_CACHE.get(cacheKey, { type: 'json' });\n      if (cached && (Date.now() - cached.timestamp) < 3600 * 1000) {\n        sportsData = cached.data;\n      }\n    } catch (e) {}\n  }\n  \n  if (!sportsData) {\n    try {\n      const response = await fetch(`${GAMMA_API}/sports`);\n      if (!response.ok) throw new Error(`Sports API error: ${response.status}`);\n      sportsData = await response.json();\n      \n      if (env.SIGNALS_CACHE) {\n        await env.SIGNALS_CACHE.put(cacheKey, JSON.stringify({\n          data: sportsData,\n          timestamp: Date.now()\n        }), { expirationTtl: 3600 + 60 });\n      }\n    } catch (e) {\n      console.error('Failed to fetch /sports:', e.message);\n      return [];\n    }\n  }\n  \n  // Map our sport codes to ALL Polymarket sport codes to query\n  // Based on actual /sports API response Feb 2026:\n  //   ncaab=39(March Madness), cbb=10470(regular CBB), cwbb=10471(womens)\n  //   nba=10345, nhl=10346, nfl=10187, mlb=3, cfb=10210, mma=10500\n  const SPORT_SEARCH_KEYS = {\n    'nba':   ['nba'],\n    'nfl':   ['nfl'],\n    'ncaab': ['ncaab', 'cbb'],     // Both March Madness AND regular season CBB\n    'cbb':   ['cbb', 'ncaab'],\n    'ncaaf': ['cfb'],\n    'cfb':   ['cfb'],\n    'nhl':   ['nhl'],\n    'mlb':   ['mlb'],\n    'ufc':   ['mma'],\n    'mma':   ['mma'],\n  };\n  \n  const searchKeys = SPORT_SEARCH_KEYS[sport.toLowerCase()] || [sport.toLowerCase()];\n  const sportsList = Array.isArray(sportsData) ? sportsData : Object.values(sportsData);\n  \n  const seriesIds = [];\n  const seen = new Set();\n  \n  for (const key of searchKeys) {\n    for (const entry of sportsList) {\n      const entrySport = (entry.sport || '').toLowerCase();\n      const seriesId = entry.series;\n      if (entrySport === key && seriesId && !seen.has(seriesId)) {\n        seriesIds.push(seriesId);\n        seen.add(seriesId);\n        console.log(`Found series ${seriesId} for sport ${sport} (matched: ${entrySport})`);\n      }\n    }\n  }\n  \n  if (seriesIds.length === 0) {\n    console.log(`No series match for sport: ${sport}. Available: ${sportsList.map(s => s.sport).join(', ')}`);\n  }\n  \n  return seriesIds;\n}\n\n\n// ============================================================\n// CLOB API - Real-Time Prices & Orderbook\n// ============================================================\n\n/**\n * Get real-time midpoint price for a token\n * This is the most accurate current price!\n */\nexport async function getMidpoint(env, tokenId) {\n  const cacheKey = `clob_midpoint_${tokenId}`;\n  \n  if (env.SIGNALS_CACHE) {\n    try {\n      const cached = await env.SIGNALS_CACHE.get(cacheKey, { type: 'json' });\n      if (cached && (Date.now() - cached.timestamp) < CACHE_TTL.MIDPOINT * 1000) {\n        return { ...cached.data, fromCache: true };\n      }\n    } catch (e) {}\n  }\n\n  try {\n    const response = await fetch(`${CLOB_API}/midpoint?token_id=${tokenId}`);\n    if (!response.ok) throw new Error(`CLOB API error: ${response.status}`);\n    \n    const data = await response.json();\n    \n    const result = {\n      success: true,\n      tokenId,\n      midpoint: parseFloat(data.mid) || null,\n      timestamp: new Date().toISOString()\n    };\n\n    if (env.SIGNALS_CACHE && result.midpoint !== null) {\n      await env.SIGNALS_CACHE.put(cacheKey, JSON.stringify({\n        data: result,\n        timestamp: Date.now()\n      }), { expirationTtl: CACHE_TTL.MIDPOINT + 10 });\n    }\n\n    return result;\n  } catch (e) {\n    return { success: false, error: e.message, tokenId };\n  }\n}\n\n/**\n * Get midpoints for multiple tokens at once (batched)\n */\nexport async function getMidpoints(env, tokenIds) {\n  const results = {};\n  \n  // Batch fetch - CLOB supports this\n  try {\n    const idsParam = tokenIds.join(',');\n    const response = await fetch(`${CLOB_API}/midpoints?token_ids=${idsParam}`);\n    \n    if (response.ok) {\n      const data = await response.json();\n      // Response format: { \"token_id\": \"0.65\", ... }\n      for (const [tokenId, mid] of Object.entries(data)) {\n        results[tokenId] = parseFloat(mid) || null;\n      }\n    }\n  } catch (e) {\n    console.error('Batch midpoints error:', e.message);\n  }\n\n  return results;\n}\n\n/**\n * Get the current best price for a side (BUY or SELL)\n */\nexport async function getPrice(env, tokenId, side = 'BUY') {\n  try {\n    const response = await fetch(`${CLOB_API}/price?token_id=${tokenId}&side=${side}`);\n    if (!response.ok) throw new Error(`CLOB API error: ${response.status}`);\n    \n    const data = await response.json();\n    \n    return {\n      success: true,\n      tokenId,\n      side,\n      price: parseFloat(data.price) || null\n    };\n  } catch (e) {\n    return { success: false, error: e.message };\n  }\n}\n\n/**\n * Get full orderbook for a token\n */\nexport async function getOrderBook(env, tokenId) {\n  const cacheKey = `clob_book_${tokenId}`;\n  \n  if (env.SIGNALS_CACHE) {\n    try {\n      const cached = await env.SIGNALS_CACHE.get(cacheKey, { type: 'json' });\n      if (cached && (Date.now() - cached.timestamp) < CACHE_TTL.ORDERBOOK * 1000) {\n        return { ...cached.data, fromCache: true };\n      }\n    } catch (e) {}\n  }\n\n  try {\n    const response = await fetch(`${CLOB_API}/book?token_id=${tokenId}`);\n    if (!response.ok) throw new Error(`CLOB API error: ${response.status}`);\n    \n    const data = await response.json();\n    \n    // Calculate best bid/ask and spread\n    const bestBid = data.bids?.[0]?.price ? parseFloat(data.bids[0].price) : null;\n    const bestAsk = data.asks?.[0]?.price ? parseFloat(data.asks[0].price) : null;\n    const spread = (bestBid && bestAsk) ? (bestAsk - bestBid) : null;\n    const midpoint = (bestBid && bestAsk) ? (bestBid + bestAsk) / 2 : null;\n    \n    // Calculate total liquidity at top levels\n    const bidLiquidity = data.bids?.slice(0, 5).reduce((sum, b) => sum + parseFloat(b.size || 0), 0) || 0;\n    const askLiquidity = data.asks?.slice(0, 5).reduce((sum, a) => sum + parseFloat(a.size || 0), 0) || 0;\n\n    const result = {\n      success: true,\n      tokenId,\n      bestBid,\n      bestAsk,\n      spread,\n      midpoint,\n      bidLiquidity: Math.round(bidLiquidity),\n      askLiquidity: Math.round(askLiquidity),\n      bids: data.bids?.slice(0, 10) || [],\n      asks: data.asks?.slice(0, 10) || [],\n      timestamp: new Date().toISOString()\n    };\n\n    if (env.SIGNALS_CACHE) {\n      await env.SIGNALS_CACHE.put(cacheKey, JSON.stringify({\n        data: result,\n        timestamp: Date.now()\n      }), { expirationTtl: CACHE_TTL.ORDERBOOK + 10 });\n    }\n\n    return result;\n  } catch (e) {\n    return { success: false, error: e.message };\n  }\n}\n\n/**\n * Get last trade price for a token\n */\nexport async function getLastTradePrice(env, tokenId) {\n  try {\n    const response = await fetch(`${CLOB_API}/last-trade-price?token_id=${tokenId}`);\n    if (!response.ok) throw new Error(`CLOB API error: ${response.status}`);\n    \n    const data = await response.json();\n    \n    return {\n      success: true,\n      tokenId,\n      lastPrice: parseFloat(data.price) || null\n    };\n  } catch (e) {\n    return { success: false, error: e.message };\n  }\n}\n\n// ============================================================\n// COMBINED: Vegas Odds Comparison with Real-Time Poly Prices\n// ============================================================\n\n/**\n * Get sports markets with REAL-TIME prices for Vegas comparison\n * This is the PROPER way to compare - uses Gamma API's outcomePrices\n */\nexport async function getSportsMarketsWithPrices(env, sport) {\n  const sportsResult = await getSportsMarkets(env, sport);\n  \n  if (!sportsResult.success) {\n    return sportsResult;\n  }\n\n  // The Gamma API already returns outcomePrices!\n  // We just need to structure it for our Vegas comparison\n  const marketsWithPrices = sportsResult.markets.map(market => {\n    // outcomePrices is already parsed in parseMarket()\n    const prices = market.outcomePrices || [];\n    \n    return {\n      slug: market.slug,\n      eventSlug: market.eventSlug,\n      eventTitle: market.eventTitle,\n      question: market.question,\n      outcomes: market.outcomes,\n      outcomePrices: prices, // Real-time prices from Gamma!\n      yesPrice: prices[0] !== undefined && prices[0] !== null ? Math.round(prices[0] * 100) : null,\n      noPrice: prices[1] !== undefined && prices[1] !== null ? Math.round(prices[1] * 100) : null,\n      volume: market.volume,\n      liquidity: market.liquidity,\n      endDate: market.endDate,\n      gameStartTime: market.gameStartTime,\n      clobTokenIds: market.clobTokenIds, // For orderbook lookups\n      active: market.active,\n      closed: market.closed\n    };\n  });\n\n  return {\n    ...sportsResult,\n    markets: marketsWithPrices\n  };\n}\n\n/**\n * Build a lookup map of Polymarket prices by game\n * Uses slug parsing to match with Vegas games\n */\nexport async function buildPolymarketPricesFromGamma(env, sport) {\n  const marketsResult = await getSportsMarketsWithPrices(env, sport);\n  \n  if (!marketsResult.success) {\n    return { success: false, error: marketsResult.error, prices: {} };\n  }\n\n  const pricesMap = {};\n\n  for (const market of marketsResult.markets) {\n    // Parse slug to extract game info\n    // Format: cbb-duke-vtech-2026-01-31 or nba-lal-gsw-2026-01-28\n    const slugMatch = market.slug?.match(/^([a-z]+)-(.+)-(\\d{4}-\\d{2}-\\d{2})(?:-spread)?$/i);\n    \n    if (!slugMatch) continue;\n\n    const sportCode = slugMatch[1];\n    const teamsStr = slugMatch[2];\n    const dateStr = slugMatch[3];\n    const isSpread = market.slug.includes('-spread');\n\n    // Try to split teams - this is tricky for multi-word names\n    // We'll use the market outcomes to get team names\n    const outcomes = market.outcomes || [];\n    \n    // Generate a game key for matching\n    const gameKey = `${teamsStr}-${dateStr}`.toLowerCase();\n    \n    if (!pricesMap[gameKey]) {\n      pricesMap[gameKey] = {\n        slug: market.slug,\n        date: dateStr,\n        outcomes: outcomes,\n        moneyline: {},\n        spread: {},\n        volume: market.volume,\n        liquidity: market.liquidity,\n        clobTokenIds: market.clobTokenIds,\n        lastUpdate: new Date().toISOString()\n      };\n    }\n\n    // Store prices\n    if (isSpread) {\n      if (market.yesPrice !== null) {\n        pricesMap[gameKey].spread.yes = market.yesPrice;\n        pricesMap[gameKey].spread.no = market.noPrice;\n      }\n    } else {\n      // Moneyline - outcomes[0] is typically home/favorite\n      if (market.yesPrice !== null) {\n        pricesMap[gameKey].moneyline.yes = market.yesPrice;\n        pricesMap[gameKey].moneyline.no = market.noPrice;\n        pricesMap[gameKey].moneyline.outcomes = outcomes;\n      }\n    }\n  }\n\n  return {\n    success: true,\n    sport,\n    pricesCount: Object.keys(pricesMap).length,\n    prices: pricesMap,\n    timestamp: new Date().toISOString()\n  };\n}\n\n// ============================================================\n// DATA API - Trades & Activity\n// ============================================================\n\n/**\n * Get recent trades (with wallet info for scanner)\n */\nexport async function getRecentTrades(env, options = {}) {\n  const { limit = 1000, market = null } = options;\n  \n  try {\n    let url = `${DATA_API}/trades?limit=${limit}`;\n    if (market) url += `&market=${market}`;\n    \n    const response = await fetch(url);\n    if (!response.ok) throw new Error(`Data API error: ${response.status}`);\n    \n    const trades = await response.json();\n    \n    return {\n      success: true,\n      count: trades.length,\n      trades\n    };\n  } catch (e) {\n    return { success: false, error: e.message };\n  }\n}\n\n// ============================================================\n// HELPER FUNCTIONS\n// ============================================================\n\n/**\n * Parse a market object from Gamma API\n */\nfunction parseMarket(market) {\n  // outcomePrices comes as a JSON string like '[\"0.87\",\"0.13\"]'\n  let outcomePrices = [];\n  if (market.outcomePrices) {\n    try {\n      outcomePrices = typeof market.outcomePrices === 'string' \n        ? JSON.parse(market.outcomePrices)\n        : market.outcomePrices;\n      outcomePrices = outcomePrices.map(p => parseFloat(p));\n    } catch (e) {\n      console.error('Error parsing outcomePrices:', e.message);\n    }\n  }\n\n  // outcomes comes as a JSON string like '[\"Yes\",\"No\"]' or team names\n  let outcomes = [];\n  if (market.outcomes) {\n    try {\n      outcomes = typeof market.outcomes === 'string'\n        ? JSON.parse(market.outcomes)\n        : market.outcomes;\n    } catch (e) {\n      console.error('Error parsing outcomes:', e.message);\n    }\n  }\n\n  // clobTokenIds - needed for CLOB API lookups\n  let clobTokenIds = [];\n  if (market.clobTokenIds) {\n    try {\n      clobTokenIds = typeof market.clobTokenIds === 'string'\n        ? JSON.parse(market.clobTokenIds)\n        : market.clobTokenIds;\n    } catch (e) {}\n  }\n\n  return {\n    id: market.id,\n    conditionId: market.conditionId,\n    slug: market.slug,\n    question: market.question,\n    description: market.description,\n    outcomes,\n    outcomePrices,\n    clobTokenIds,\n    volume: parseFloat(market.volume) || 0,\n    volumeNum: market.volumeNum || 0,\n    liquidity: parseFloat(market.liquidity) || 0,\n    liquidityNum: market.liquidityNum || 0,\n    active: market.active,\n    closed: market.closed,\n    archived: market.archived,\n    endDate: market.endDate,\n    gameStartTime: market.gameStartTime,\n    category: market.category,\n    marketType: market.marketType,\n    image: market.image,\n    icon: market.icon\n  };\n}\n\n/**\n * Check if market is a game (not futures/props)\n */\nfunction isGameMarket(market) {\n  const slug = (market.slug || '').toLowerCase();\n  const question = (market.question || '').toLowerCase();\n  \n  // Futures keywords to exclude\n  const futuresKeywords = [\n    'champion', 'winner', 'mvp', 'playoff', 'seed',\n    'division', 'conference', 'season', 'draft', 'award',\n    'rookie of the year', 'player of the year'\n  ];\n  \n  if (futuresKeywords.some(kw => question.includes(kw))) {\n    return false;\n  }\n  \n  // Game indicators\n  // Has a date in slug: nba-lal-gsw-2026-01-28\n  if (/\\d{4}-\\d{2}-\\d{2}/.test(slug)) {\n    return true;\n  }\n  \n  // Has \"vs\" in question\n  if (question.includes(' vs ') || question.includes(' @ ')) {\n    return true;\n  }\n  \n  return false;\n}\n\n/**\n * Match a Polymarket slug to a Vegas game\n */\nexport function matchPolyToVegas(polySlug, vegasHomeTeam, vegasAwayTeam, vegasDate) {\n  if (!polySlug) return null;\n  \n  const slugLower = polySlug.toLowerCase();\n  const homeLower = vegasHomeTeam.toLowerCase();\n  const awayLower = vegasAwayTeam.toLowerCase();\n  \n  // Extract words from team names for matching\n  const homeWords = homeLower.split(' ').filter(w => w.length > 3);\n  const awayWords = awayLower.split(' ').filter(w => w.length > 3);\n  \n  // Check if slug contains team name parts\n  const homeMatch = homeWords.some(w => slugLower.includes(w));\n  const awayMatch = awayWords.some(w => slugLower.includes(w));\n  \n  // Check date\n  const dateMatch = vegasDate && slugLower.includes(vegasDate);\n  \n  return homeMatch && awayMatch && dateMatch;\n}\n\n// ============================================================\n// EVENT TIMING LOOKUP\n// Enriches signals with event start/end times from Gamma API\n// ============================================================\n\n/**\n * Get event timing (start/end) for a market slug\n * Uses Gamma API events endpoint with aggressive caching\n * Returns { eventStartTime, eventEndTime, hoursUntilEvent } or null\n */\nexport async function getEventTimingBySlug(env, slug) {\n  if (!slug) return null;\n  \n  // Step 1: Try slug-specific cache first (fast path)\n  const timingCacheKey = `event_timing_${slug}`;\n  if (env.SIGNALS_CACHE) {\n    try {\n      const cached = await env.SIGNALS_CACHE.get(timingCacheKey, { type: 'json' });\n      if (cached) return cached;\n    } catch (e) {}\n  }\n  \n  // Step 2: Extract date from slug for estimation\n  const dateMatch = slug.match(/(\\d{4})-(\\d{2})-(\\d{2})/);\n  \n  // Step 3: Try Gamma API direct slug lookup\n  let timing = null;\n  try {\n    const response = await fetch(`${GAMMA_API}/events?slug=${slug}&limit=1`);\n    if (response.ok) {\n      const events = await response.json();\n      if (events && events.length > 0) {\n        const event = events[0];\n        timing = {\n          eventStartTime: event.startDate || null,\n          eventEndTime: event.endDate || null,\n          source: 'gamma-event'\n        };\n      }\n    }\n  } catch (e) {\n    // Gamma lookup failed, fall through to estimation\n  }\n  \n  // Step 4: If no Gamma event found, try market lookup for endDate\n  if (!timing) {\n    try {\n      const response = await fetch(`${GAMMA_API}/markets?slug=${slug}&limit=1`);\n      if (response.ok) {\n        const markets = await response.json();\n        if (markets && markets.length > 0) {\n          const market = markets[0];\n          timing = {\n            eventStartTime: null,\n            eventEndTime: market.endDate || null,\n            source: 'gamma-market'\n          };\n        }\n      }\n    } catch (e) {}\n  }\n  \n  // Step 5: Estimate from slug date if no API data\n  if (!timing && dateMatch) {\n    const eventDate = new Date(\n      parseInt(dateMatch[1]),\n      parseInt(dateMatch[2]) - 1,\n      parseInt(dateMatch[3])\n    );\n    \n    // Estimate game time based on sport type in slug\n    const slugLower = slug.toLowerCase();\n    let estimatedHour = 0; // UTC midnight = 7pm ET default\n    \n    if (slugLower.startsWith('nba-') || slugLower.startsWith('nhl-')) {\n      estimatedHour = 0; // ~7pm ET start typical\n    } else if (slugLower.startsWith('nfl-')) {\n      estimatedHour = 18; // ~1pm ET Sunday start typical\n    } else if (slugLower.startsWith('cbb-') || slugLower.startsWith('ncaab-')) {\n      estimatedHour = 23; // ~6pm ET typical\n    }\n    \n    eventDate.setUTCHours(estimatedHour, 0, 0, 0);\n    \n    // End time estimate: game start + 3 hours\n    const eventEndDate = new Date(eventDate.getTime() + 3 * 60 * 60 * 1000);\n    \n    timing = {\n      eventStartTime: eventDate.toISOString(),\n      eventEndTime: eventEndDate.toISOString(),\n      source: 'slug-estimate'\n    };\n  }\n  \n  if (!timing) return null;\n  \n  // Calculate hours until event\n  const startTime = timing.eventStartTime ? new Date(timing.eventStartTime).getTime() : null;\n  const endTime = timing.eventEndTime ? new Date(timing.eventEndTime).getTime() : null;\n  const now = Date.now();\n  \n  timing.hoursUntilEvent = startTime ? Math.round((startTime - now) / (1000 * 60 * 60) * 10) / 10 : null;\n  timing.hoursUntilEnd = endTime ? Math.round((endTime - now) / (1000 * 60 * 60) * 10) / 10 : null;\n  timing.eventStatus = startTime \n    ? (now < startTime ? 'upcoming' : (endTime && now < endTime ? 'live' : 'ended'))\n    : 'unknown';\n  \n  // Cache for 10 minutes (event times don't change often)\n  if (env.SIGNALS_CACHE) {\n    try {\n      await env.SIGNALS_CACHE.put(timingCacheKey, JSON.stringify(timing), {\n        expirationTtl: 10 * 60\n      });\n    } catch (e) {}\n  }\n  \n  return timing;\n}\n\n/**\n * Batch lookup event timing for multiple slugs (efficient for scan enrichment)\n * Returns Map<slug, timing>\n */\nexport async function batchGetEventTiming(env, slugs) {\n  const timingMap = new Map();\n  \n  // Limit to prevent API hammering - only enrich top signals\n  const maxLookups = 20;\n  const lookupSlugs = slugs.slice(0, maxLookups);\n  \n  // Parallel lookups with individual error handling\n  const results = await Promise.allSettled(\n    lookupSlugs.map(slug => getEventTimingBySlug(env, slug))\n  );\n  \n  results.forEach((result, i) => {\n    if (result.status === 'fulfilled' && result.value) {\n      timingMap.set(lookupSlugs[i], result.value);\n    }\n  });\n  \n  return timingMap;\n}\n\n// ============================================================\n// EXPORTS\n// ============================================================\n\nexport default {\n  // Gamma API\n  getMarkets,\n  getMarketBySlug,\n  getSportsMarkets,\n  getSportsMarketsWithPrices,\n  buildPolymarketPricesFromGamma,\n  \n  // CLOB API\n  getMidpoint,\n  getMidpoints,\n  getPrice,\n  getOrderBook,\n  getLastTradePrice,\n  \n  // Data API\n  getRecentTrades,\n  \n  // Event Timing\n  getEventTimingBySlug,\n  batchGetEventTiming,\n  \n  // Helpers\n  matchPolyToVegas\n};\n", "// ============================================================\n// SIGNALS.JS - Signal Detection and Scoring\n// v18.9.0 - WINNING FOCUS: Track winners, prioritize sports props\n// ============================================================\n\nimport { POLYMARKET_API, SCORES, KV_KEYS } from './config.js';\nimport { detectMarketType, generateId, isSportsGame } from './utils.js';\nimport { trackWalletBet } from './wallets.js';\nimport { calculateConfidence } from './learning.js';\nimport { batchGetEventTiming } from './polymarket-api.js';\n\n// ============================================================\n// CONFIGURATION\n// ============================================================\nconst CONFIG = {\n  SCAN_CACHE_TTL: 2 * 60,        // 2 minutes cache\n  TRADE_LIMIT: 1500,              // API fetch limit\n  MAX_TRADES_PER_MARKET: 10,      // Memory optimization\n  SPORTS_SIGNAL_LIMIT: 15,        // Top 15 sports props\n  MIN_WALLET_WIN_RATE: 55,        // Only track wallets above 55% win rate\n  MIN_WALLET_BETS: 3,             // Minimum bets before tracking\n};\n\n// ============================================================\n// FACTOR-BASED FILTERING (AI LEARNED)\n// ============================================================\n\n// Factors to auto-hide (historically terrible performance)\nconst FADE_FACTORS = ['sports-mma'];  // 0% win rate\n\n// Factors to heavily penalize\nconst WEAK_FACTORS = ['vol_100k_plus', 'freshWhale10k', 'whaleSize25k', 'vol_25k_50k', 'betVeryEarly'];  // <20% WR\n\n// Factors to boost (proven winners)\nconst STRONG_FACTORS = ['volumeHuge', 'sports-other', 'freshWhale5k', 'betLast2Hours', 'betDuringEvent'];  // likely high WR\n\n// Calculate AI-adjusted score based on factor performance\nasync function calculateAIScore(env, baseScore, scoreBreakdown, marketType, hasWinningWallet) {\n  if (!env.SIGNALS_CACHE) return { aiScore: baseScore, multiplier: 1.0, shouldHide: false };\n  \n  try {\n    const factorStats = await env.SIGNALS_CACHE.get('factor_stats_v2', { type: 'json' }) || {};\n    \n    let multiplier = 1.0;\n    let shouldHide = false;\n    let boostReasons = [];\n    let penaltyReasons = [];\n    \n    // Check each factor in the signal\n    const factors = scoreBreakdown?.map(f => f.factor) || [];\n    if (marketType) factors.push(marketType);\n    if (hasWinningWallet) factors.push('winningWallet');\n    \n    for (const factor of factors) {\n      const stats = factorStats[factor];\n      \n      // Skip factors with insufficient data\n      if (!stats || (stats.wins + stats.losses) < 5) continue;\n      \n      const winRate = stats.winRate;\n      const sampleSize = stats.wins + stats.losses;\n      \n      // Confidence factor: more samples = more weight\n      const confidenceFactor = Math.min(1, sampleSize / 20);\n      \n      if (winRate >= 70) {\n        // Strong factor: boost significantly\n        const boost = 1 + (0.3 * confidenceFactor);\n        multiplier *= boost;\n        boostReasons.push(`${factor}(${winRate}%)`);\n      } else if (winRate >= 55) {\n        // Good factor: small boost\n        multiplier *= (1 + (0.1 * confidenceFactor));\n      } else if (winRate <= 15) {\n        // Terrible factor: heavy penalty\n        multiplier *= (0.4 * confidenceFactor + (1 - confidenceFactor));\n        penaltyReasons.push(`${factor}(${winRate}%)`);\n        \n        // Auto-hide if dominated by terrible factors\n        if (FADE_FACTORS.includes(factor)) {\n          shouldHide = true;\n        }\n      } else if (winRate <= 25) {\n        // Weak factor: moderate penalty\n        multiplier *= (0.6 * confidenceFactor + (1 - confidenceFactor));\n        penaltyReasons.push(`${factor}(${winRate}%)`);\n      } else if (winRate <= 35) {\n        // Below average: small penalty\n        multiplier *= (0.8 * confidenceFactor + (1 - confidenceFactor));\n      }\n    }\n    \n    // Cap multiplier range\n    multiplier = Math.max(0.3, Math.min(2.0, multiplier));\n    \n    // Override: Never hide signals with winning wallets\n    if (hasWinningWallet) {\n      shouldHide = false;\n      multiplier = Math.max(multiplier, 1.0);  // At least 1.0x with winning wallet\n    }\n    \n    const aiScore = Math.round(baseScore * multiplier);\n    \n    return {\n      aiScore,\n      multiplier: Math.round(multiplier * 100) / 100,\n      shouldHide,\n      boostReasons,\n      penaltyReasons\n    };\n  } catch (e) {\n    console.error('Error calculating AI score:', e.message);\n    return { aiScore: baseScore, multiplier: 1.0, shouldHide: false };\n  }\n}\n\n// Get historical win rate for a specific factor\nasync function getFactorWinRate(env, factorName) {\n  if (!env.SIGNALS_CACHE) return null;\n  \n  try {\n    const factorStats = await env.SIGNALS_CACHE.get('factor_stats_v2', { type: 'json' }) || {};\n    const stats = factorStats[factorName];\n    \n    if (!stats || (stats.wins + stats.losses) < 3) return null;\n    \n    return {\n      winRate: stats.winRate,\n      record: `${stats.wins}W-${stats.losses}L`,\n      weight: stats.weight || 1.0\n    };\n  } catch (e) {\n    return null;\n  }\n}\n\n// ============================================================\n// SCAN RESULT CACHE\n// ============================================================\nasync function getCachedScanResult(env, cacheKey) {\n  if (!env.SIGNALS_CACHE) return null;\n  \n  try {\n    const cached = await env.SIGNALS_CACHE.get(cacheKey, { type: 'json' });\n    if (cached && cached.timestamp) {\n      const age = Date.now() - cached.timestamp;\n      if (age < CONFIG.SCAN_CACHE_TTL * 1000) {\n        return { ...cached.data, fromCache: true, cacheAge: Math.round(age / 1000) };\n      }\n    }\n  } catch (e) {}\n  return null;\n}\n\nasync function cacheScanResult(env, cacheKey, data) {\n  if (!env.SIGNALS_CACHE) return;\n  try {\n    await env.SIGNALS_CACHE.put(cacheKey, JSON.stringify({\n      data,\n      timestamp: Date.now()\n    }), { expirationTtl: CONFIG.SCAN_CACHE_TTL + 60 });\n  } catch (e) {}\n}\n\n// ============================================================\n// FILTERS\n// ============================================================\nconst GAMBLING_KEYWORDS = [\n  'up or down', 'bitcoin up or down', 'ethereum up or down', \n  '15m', '30m', '1h', '5m', 'next 15 minutes', 'next 30 minutes'\n];\n\nfunction isGamblingMarket(title) {\n  if (!title) return false;\n  const lower = title.toLowerCase();\n  return GAMBLING_KEYWORDS.some(kw => lower.includes(kw));\n}\n\nfunction extractWallet(trade) {\n  const wallet = trade.proxyWallet || trade.user || trade.maker || trade.taker;\n  return (wallet && typeof wallet === 'string' && wallet.length > 10) ? wallet : null;\n}\n\nfunction isNoBetOutcome(outcome) {\n  if (!outcome) return false;\n  const lower = String(outcome).toLowerCase();\n  return lower === 'no' || lower === 'false' || lower === '0';\n}\n\n// ============================================================\n// WINNING WALLET LOOKUP (Check if wallet is a proven winner)\n// ============================================================\nasync function getWinningWallets(env) {\n  if (!env.SIGNALS_CACHE) return new Map();\n  \n  try {\n    const cached = await env.SIGNALS_CACHE.get('winning_wallets_cache', { type: 'json' });\n    if (cached && cached.timestamp && (Date.now() - cached.timestamp < 5 * 60 * 1000)) {\n      return new Map(Object.entries(cached.wallets || {}));\n    }\n  } catch (e) {}\n  \n  return new Map();\n}\n\nasync function isWinningWallet(env, address, winningWalletsCache) {\n  if (!address) return { isWinner: false };\n  \n  // Check cache first\n  if (winningWalletsCache.has(address.toLowerCase())) {\n    return winningWalletsCache.get(address.toLowerCase());\n  }\n  \n  // Not in cache, check KV directly\n  if (!env.SIGNALS_CACHE) return { isWinner: false };\n  \n  try {\n    const walletKey = KV_KEYS.WALLETS_PREFIX + address.toLowerCase();\n    const stats = await env.SIGNALS_CACHE.get(walletKey, { type: 'json' });\n    \n    if (stats && stats.totalBets >= CONFIG.MIN_WALLET_BETS) {\n      const winRate = stats.winRate || (stats.totalBets > 0 ? (stats.wins / stats.totalBets) * 100 : 0);\n      if (winRate >= CONFIG.MIN_WALLET_WIN_RATE) {\n        return {\n          isWinner: true,\n          winRate: Math.round(winRate),\n          record: `${stats.wins}W-${stats.losses}L`,\n          tier: stats.tier || 'WINNER',\n          totalBets: stats.totalBets\n        };\n      }\n    }\n  } catch (e) {}\n  \n  return { isWinner: false };\n}\n\n// ============================================================\n// SIGNAL STORAGE (Only store signals with potential)\n// ============================================================\nasync function storeSignalForSettlement(env, signal) {\n  if (!env.SIGNALS_CACHE || !signal.id) return false;\n  \n  try {\n    const signalKey = KV_KEYS.SIGNALS_PREFIX + signal.id;\n    \n    const signalData = {\n      id: signal.id,\n      marketSlug: signal.marketSlug,\n      marketTitle: signal.marketTitle,\n      direction: signal.direction,\n      priceAtSignal: signal.displayPrice,\n      score: signal.score,\n      confidence: signal.confidence,\n      detectedAt: new Date().toISOString(),\n      marketType: signal.marketType,\n      totalVolume: signal.suspiciousVolume,\n      largestBet: signal.largestBet,\n      scoreBreakdown: signal.scoreBreakdown || [],\n      wallets: signal.topTrades?.map(t => t.wallet).filter(Boolean) || [],\n      hasWinningWallet: signal.hasWinningWallet || false,\n      // FIX #3: Track actual bet count (trade count that contributed to this signal)\n      betCount: signal.tradeCount || signal.topTrades?.length || 0,\n      uniqueWallets: signal.uniqueWallets || 0,\n      // FIX #5: Store timing metadata for learning\n      firstTradeTime: signal.firstTradeTime || null,\n      lastTradeTime: signal.lastTradeTime || null,\n      // Event timing: prevents premature settlement + keeps signals visible until event ends\n      eventStartTime: signal.eventStartTime || null,\n      eventEndTime: signal.eventEndTime || null,\n      hoursUntilEvent: signal.hoursUntilEvent || null,\n      outcome: null,\n      settledAt: null\n    };\n    \n    await env.SIGNALS_CACHE.put(signalKey, JSON.stringify(signalData), {\n      expirationTtl: 7 * 24 * 60 * 60\n    });\n    \n    // Add to pending signals list\n    let pendingSignals = await env.SIGNALS_CACHE.get(KV_KEYS.PENDING_SIGNALS, { type: 'json' }) || [];\n    if (!pendingSignals.includes(signal.id)) {\n      pendingSignals.push(signal.id);\n      if (pendingSignals.length > 300) pendingSignals = pendingSignals.slice(-300);\n      await env.SIGNALS_CACHE.put(KV_KEYS.PENDING_SIGNALS, JSON.stringify(pendingSignals), {\n        expirationTtl: 30 * 24 * 60 * 60\n      });\n    }\n    \n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n// Only track wallets that show promise (large bets or part of winning signal)\nasync function trackWalletIfWorthy(env, wallet, tradeData, signal) {\n  if (!env.SIGNALS_CACHE || !wallet) return false;\n  \n  // Track if: large bet (>$5k) OR signal score is high (>60) OR has winning wallet pattern\n  const isWorthy = tradeData.amount >= 5000 || signal.score >= 60 || signal.hasWinningWallet;\n  \n  if (isWorthy) {\n    try {\n      await trackWalletBet(env, wallet, {\n        signalId: signal.id,\n        market: signal.marketSlug,\n        marketTitle: signal.marketTitle,  // ADD THE READABLE TITLE\n        direction: signal.direction,\n        amount: tradeData.amount,\n        price: tradeData.price\n      });\n      return true;\n    } catch (e) {}\n  }\n  return false;\n}\n\n// ============================================================\n// MAIN SCAN FUNCTION\n// ============================================================\nexport async function runScan(hours, minScore, env, options = {}) {\n  const startTime = Date.now();\n  const { sportsOnly = false, includeDebug = false } = options;\n  \n  const cacheKey = `scan_result_${hours}_${minScore}_${sportsOnly ? 'sports' : 'all'}`;\n  \n  // Try cache first\n  const cached = await getCachedScanResult(env, cacheKey);\n  if (cached) {\n    console.log(`Returning cached scan (age: ${cached.cacheAge}s)`);\n    return cached;\n  }\n  \n  try {\n    // Load winning wallets cache for quick lookup\n    const winningWallets = await getWinningWallets(env);\n    console.log(`Loaded ${winningWallets.size} winning wallets from cache`);\n    \n    // Fetch trades from API (skip KV buckets to save memory)\n    const controller = new AbortController();\n    const timeout = setTimeout(() => controller.abort(), 8000);\n    \n    let allTrades = [];\n    try {\n      const tradesRes = await fetch(`${POLYMARKET_API}/trades?limit=${CONFIG.TRADE_LIMIT}`, {\n        signal: controller.signal\n      });\n      if (tradesRes.ok) {\n        allTrades = await tradesRes.json();\n        console.log(`Fetched ${allTrades.length} trades from API`);\n      }\n    } catch (e) {\n      return { success: true, signals: [], totalSignals: 0, message: 'Trade fetch failed', processingTime: Date.now() - startTime };\n    } finally {\n      clearTimeout(timeout);\n    }\n    \n    if (!allTrades || allTrades.length === 0) {\n      return { success: true, signals: [], totalSignals: 0, message: 'No trades', processingTime: Date.now() - startTime };\n    }\n    \n    // DEBUG: Log first trade to see structure\n    if (allTrades.length > 0) {\n      console.log('Sample trade structure:', JSON.stringify(allTrades[0]).slice(0, 500));\n    }\n    \n    const cutoffTime = Date.now() - (hours * 60 * 60 * 1000);\n    \n    // DEBUG counters\n    let debugStats = {\n      total: allTrades.length,\n      noTitle: 0,\n      gambling: 0,\n      noTimestamp: 0,\n      oldTrade: 0,\n      badPrice: 0,\n      tooSmall: 0,\n      noSlug: 0,\n      passed: 0\n    };\n    \n    // Group trades by market\n    const marketMap = new Map();\n    \n    for (const t of allTrades) {\n      const marketTitle = t.title || t.market || t.question || '';\n      if (!marketTitle) { debugStats.noTitle++; }\n      if (isGamblingMarket(marketTitle)) { debugStats.gambling++; continue; }\n      \n      let tradeTime = t.timestamp || t.createdAt || t.matchTime;\n      if (typeof tradeTime === 'string') tradeTime = new Date(tradeTime).getTime();\n      if (tradeTime && tradeTime < 1e10) tradeTime = tradeTime * 1000;\n      if (!tradeTime) { debugStats.noTimestamp++; continue; }\n      if (tradeTime < cutoffTime) { debugStats.oldTrade++; continue; }\n      \n      const price = parseFloat(t.price) || 0;\n      if (price >= 0.95 || price <= 0.05) { debugStats.badPrice++; continue; }\n      \n      let usdValue = parseFloat(t.usd_value) || parseFloat(t.usdcSize) || parseFloat(t.size) || parseFloat(t.amount) || 0;\n      if (usdValue < 10) { debugStats.tooSmall++; continue; }\n      \n      const slug = t.slug || t.eventSlug || t.market_slug || t.conditionId || '';\n      if (sportsOnly && !isSportsGame(slug) && !isSportsGame(marketTitle)) continue;\n      \n      const marketKey = slug || marketTitle;\n      if (!marketKey) { debugStats.noSlug++; continue; }\n      \n      debugStats.passed++;\n      \n      if (!marketMap.has(marketKey)) {\n        marketMap.set(marketKey, {\n          slug: marketKey,\n          eventSlug: t.eventSlug,\n          title: t.title,\n          icon: t.icon,\n          trades: [],\n          wallets: new Set(),\n          totalVolume: 0,\n          largestBet: 0,\n          largestBetOutcome: null,\n          firstTradeTime: tradeTime,\n          lastTradeTime: tradeTime,\n          yesVolume: 0,\n          noVolume: 0,\n          outcomeVolumes: {}  // Track volume per outcome name (e.g., {\"Panthers\": 9003, \"Bruins\": 441})\n        });\n      }\n      \n      const market = marketMap.get(marketKey);\n      \n      // Keep top trades only (memory optimization)\n      if (market.trades.length < CONFIG.MAX_TRADES_PER_MARKET) {\n        market.trades.push({ \n          _usdValue: usdValue, \n          _tradeTime: tradeTime,\n          price: t.price,\n          outcome: t.outcome,\n          outcomeIndex: t.outcomeIndex,  // 0 = Yes/Team1, 1 = No/Team2\n          side: t.side,                   // BUY or SELL\n          proxyWallet: t.proxyWallet\n        });\n      }\n      \n      market.totalVolume += usdValue;\n      if (usdValue > market.largestBet) {\n        market.largestBet = usdValue;\n        market.largestBetOutcome = t.outcome || null;  // Track which outcome the biggest bet was on\n      }\n      market.firstTradeTime = Math.min(market.firstTradeTime, tradeTime);\n      market.lastTradeTime = Math.max(market.lastTradeTime, tradeTime);\n      \n      const wallet = extractWallet(t);\n      if (wallet) market.wallets.add(wallet);\n      \n      // Track volume per outcome - map Yes/No to team names for vs-format markets\n      const outcomeName = t.outcome ? String(t.outcome) : '';\n      const outcomeLower = outcomeName.toLowerCase();\n      const isYesNo = outcomeLower === 'yes' || outcomeLower === 'no' || outcomeLower === 'true' || outcomeLower === 'false';\n      \n      if (isYesNo) {\n        // Polymarket Data API returns \"Yes\"/\"No\" even for sports markets\n        // Map to team names using the title: \"Team1 vs Team2\" \u2192 Yes=Team1, No=Team2\n        const titleStr = market.title || t.title || '';\n        const vsMatch = titleStr.match(/^(.+?)\\s+vs\\.?\\s+(.+)$/i);\n        if (vsMatch) {\n          // Sports market: map Yes/No to team names\n          const team1 = vsMatch[1].trim();\n          const team2 = vsMatch[2].trim();\n          const isTeam1 = outcomeLower === 'yes' || outcomeLower === 'true';\n          const teamName = isTeam1 ? team1 : team2;\n          market.outcomeVolumes[teamName] = (market.outcomeVolumes[teamName] || 0) + usdValue;\n        }\n        // Track YES/NO volume using outcomeIndex (more reliable) or outcome string\n        const isNo = t.outcomeIndex === 1 || outcomeLower === 'no' || outcomeLower === 'false';\n        if (isNo) {\n          market.noVolume += usdValue;\n        } else {\n          market.yesVolume += usdValue;\n        }\n      } else {\n        // Non-Yes/No outcome (could be team name directly in some cases)\n        market.outcomeVolumes[outcomeName] = (market.outcomeVolumes[outcomeName] || 0) + usdValue;\n        if (isNoBetOutcome(t.outcome)) {\n          market.noVolume += usdValue;\n        } else {\n          market.yesVolume += usdValue;\n        }\n      }\n    }\n    \n    console.log(`Grouped into ${marketMap.size} markets`);\n    \n    // Score markets and build signals\n    const allSignals = [];\n    const sportsSignals = [];\n    let signalsStored = 0;\n    let walletsTracked = 0;\n    \n    for (const [slug, market] of marketMap) {\n      const score = calculateSignalScore(market);\n      if (score < minScore) continue;\n      \n      market.trades.sort((a, b) => b._usdValue - a._usdValue);\n      \n      // Check for winning wallets in this market\n      let hasWinningWallet = false;\n      let winningWalletInfo = null;\n      \n      const topTrades = [];\n      for (const t of market.trades.slice(0, 5)) {\n        const wallet = extractWallet(t);\n        const walletCheck = await isWinningWallet(env, wallet, winningWallets);\n        \n        if (walletCheck.isWinner) {\n          hasWinningWallet = true;\n          winningWalletInfo = { wallet, ...walletCheck };\n        }\n        \n        topTrades.push({\n          wallet,\n          amount: Math.round(t._usdValue),\n          price: t.price,\n          time: new Date(t._tradeTime).toISOString(),\n          outcome: t.outcome,\n          outcomeIndex: t.outcomeIndex,  // 0=Yes/Team1, 1=No/Team2\n          side: t.side,                   // BUY or SELL\n          isWinner: walletCheck.isWinner,\n          winnerInfo: walletCheck.isWinner ? walletCheck : null\n        });\n      }\n      \n      const direction = market.yesVolume > market.noVolume ? 'YES' : 'NO';\n      const directionPercent = Math.round((Math.max(market.yesVolume, market.noVolume) / market.totalVolume) * 100);\n      \n      // Determine the DOMINANT outcome (which team/side the whales are actually betting on)\n      // For sports markets, outcome is the team name (e.g., \"Panthers\"), not \"Yes\"/\"No\"\n      const outcomeNames = Object.keys(market.outcomeVolumes);\n      let dominantOutcome = null;\n      let dominantOutcomeVolume = 0;\n      for (const [name, vol] of Object.entries(market.outcomeVolumes)) {\n        if (vol > dominantOutcomeVolume) {\n          dominantOutcome = name;\n          dominantOutcomeVolume = vol;\n        }\n      }\n      \n      // displayPrice = the entry price of the largest trade's outcome\n      // trade.price on Polymarket = the price of THAT trade's outcome token\n      // So if whale bought \"Panthers\" at price 0.56, displayPrice = 56 (Panthers' price)\n      const rawPrice = market.trades[0] ? parseFloat(market.trades[0].price) : null;\n      let displayPrice = null;\n      if (rawPrice !== null) {\n        displayPrice = Math.round(rawPrice * 100);\n      }\n      \n      // For logging: which outcome did the biggest trade buy?\n      const biggestTradeOutcome = market.trades[0]?.outcome || null;\n      console.log(`Signal ${slug}: dominantOutcome=${dominantOutcome} (${dominantOutcomeVolume}), biggestTradeOutcome=${biggestTradeOutcome}, displayPrice=${displayPrice}, outcomeVolumes=${JSON.stringify(market.outcomeVolumes)}`);\n      \n      const marketType = detectMarketType(market.title || slug, slug);\n      const scoreBreakdown = getScoreBreakdown(market, displayPrice, hasWinningWallet);\n      \n      // ============================================================\n      // NEW: AI-POWERED SCORING\n      // ============================================================\n      const aiResult = await calculateAIScore(env, score, scoreBreakdown, marketType, hasWinningWallet);\n      \n      // Skip signals that AI says to hide (e.g., MMA with 0% historical WR)\n      if (aiResult.shouldHide) {\n        console.log(`Hiding signal ${slug}: dominated by weak factors (${aiResult.penaltyReasons.join(', ')})`);\n        continue;\n      }\n      \n      // Use AI-adjusted score\n      const aiScore = aiResult.aiScore;\n      \n      // Calculate confidence with winning wallet boost\n      let confidence = Math.round(50 + (aiScore / 100) * 25);\n      \n      // BOOST: Winning wallet adds 10-15% confidence\n      if (hasWinningWallet && winningWalletInfo) {\n        const walletBoost = Math.min(15, Math.round((winningWalletInfo.winRate - 50) / 3));\n        confidence += walletBoost;\n      }\n      \n      // AI learning enhancement\n      try {\n        if (typeof calculateConfidence === 'function' && env.SIGNALS_CACHE) {\n          const factorNames = [...scoreBreakdown.map(f => f.factor), marketType];\n          if (hasWinningWallet) factorNames.push('winningWallet');\n          \n          const confResult = await calculateConfidence(env, factorNames, {\n            marketType,\n            totalVolume: market.totalVolume,\n            detectedAt: new Date(market.firstTradeTime).toISOString()\n          });\n          \n          if (confResult && typeof confResult.confidence === 'number' && confResult.dataPoints >= 1) {\n            confidence = Math.round(confResult.confidence * 0.6 + confidence * 0.4);\n          }\n        }\n      } catch (e) {}\n      \n      confidence = Math.max(40, Math.min(95, Math.round(confidence)));\n      \n      const signal = {\n        id: generateId(),\n        marketSlug: slug,\n        eventSlug: market.eventSlug || slug,  // Parent event slug for correct Polymarket URLs\n        marketTitle: market.title || slug,\n        icon: market.icon,\n        score,                          // Original raw score\n        aiScore,                        // AI-adjusted score (NEW!)\n        aiMultiplier: aiResult.multiplier, // Show the multiplier (NEW!)\n        confidence,\n        direction,\n        directionPercent,\n        displayPrice,\n        suspiciousVolume: Math.round(market.totalVolume),\n        largestBet: Math.round(market.largestBet),\n        uniqueWallets: market.wallets.size,\n        tradeCount: market.trades.length,\n        firstTradeTime: new Date(market.firstTradeTime).toISOString(),\n        lastTradeTime: new Date(market.lastTradeTime).toISOString(),\n        topTrades,\n        hasWinningWallet,\n        winningWalletInfo,\n        marketType,\n        scoreBreakdown,\n        // Priority flag for sports\n        isSportsSignal: marketType.startsWith('sports-'),\n        // FIX: Accurate bet summary for vs-format markets\n        // Use the ACTUAL outcome from trades, not the YES/NO direction guess\n        // Polymarket sports trades have outcome = team name (e.g., \"Panthers\")\n        betSummary: (() => {\n          const title = market.title || slug;\n          const vsMatch = title.match(/^(.+?)\\s+vs\\.?\\s+(.+)$/i);\n          if (vsMatch) {\n            const team1 = vsMatch[1].trim(); // YES token = Team 1\n            const team2 = vsMatch[2].trim(); // NO token = Team 2\n            \n            // Determine which team the whales bet on using multiple signals:\n            // 1. dominantOutcome from outcomeVolumes (now mapped to team names)\n            // 2. Biggest trade's outcomeIndex (0=Team1, 1=Team2)\n            // 3. Biggest trade's outcome mapped via Yes/No \u2192 team\n            \n            let whaleTeam = null;\n            \n            // BEST: Use dominantOutcome (volume-weighted, now has team names)\n            if (dominantOutcome) {\n              const domLower = dominantOutcome.toLowerCase();\n              const t1Lower = team1.toLowerCase();\n              const t2Lower = team2.toLowerCase();\n              if (domLower === t1Lower || t1Lower.includes(domLower) || domLower.includes(t1Lower)) {\n                whaleTeam = team1;\n              } else if (domLower === t2Lower || t2Lower.includes(domLower) || domLower.includes(t2Lower)) {\n                whaleTeam = team2;\n              }\n            }\n            \n            // FALLBACK: Use biggest trade's outcome + outcomeIndex\n            if (!whaleTeam && market.trades[0]) {\n              const bigTrade = market.trades[0];\n              const outLower = (bigTrade.outcome || '').toLowerCase();\n              \n              if (bigTrade.outcomeIndex === 0 || outLower === 'yes' || outLower === 'true') {\n                whaleTeam = team1;\n              } else if (bigTrade.outcomeIndex === 1 || outLower === 'no' || outLower === 'false') {\n                whaleTeam = team2;\n              } else {\n                // Outcome might be a team name directly (some markets)\n                const t1Lower = team1.toLowerCase();\n                const t2Lower = team2.toLowerCase();\n                if (t1Lower.includes(outLower) || outLower.includes(t1Lower)) {\n                  whaleTeam = team1;\n                } else if (t2Lower.includes(outLower) || outLower.includes(t2Lower)) {\n                  whaleTeam = team2;\n                }\n              }\n            }\n            \n            // LAST RESORT: use volume direction\n            if (!whaleTeam) {\n              whaleTeam = market.yesVolume >= market.noVolume ? team1 : team2;\n            }\n            \n            // displayPrice = price of the outcome token the whale bought\n            const entryPct = displayPrice ? `${displayPrice}%` : '';\n            console.log(`betSummary: title=\"${title}\" whaleTeam=\"${whaleTeam}\" dominantOutcome=\"${dominantOutcome}\" biggestTrade=${biggestTradeOutcome}(idx:${market.trades[0]?.outcomeIndex}) displayPrice=${displayPrice}`);\n            return `${whaleTeam} @ ${entryPct}`;\n          }\n          return null;\n        })(),\n        // NEW: Send team names separately for frontend flexibility\n        teamInfo: (() => {\n          const title = market.title || slug;\n          const vsMatch = title.match(/^(.+?)\\s+vs\\.?\\s+(.+)$/i);\n          if (vsMatch) {\n            const team1 = vsMatch[1].trim();\n            const team2 = vsMatch[2].trim();\n            \n            // Determine which team whales are betting on\n            // Use same logic as betSummary: dominantOutcome (team names from outcomeVolumes)\n            // or outcomeIndex from biggest trade\n            let whaleTeam = team1; // default to team1\n            \n            // Use dominantOutcome (now properly mapped to team names)\n            if (dominantOutcome) {\n              const domLower = dominantOutcome.toLowerCase();\n              const t2Lower = team2.toLowerCase();\n              if (domLower === t2Lower || t2Lower.includes(domLower) || domLower.includes(t2Lower)) {\n                whaleTeam = team2;\n              }\n            } else if (market.trades[0]) {\n              // Fallback: use biggest trade's outcomeIndex\n              const bigTrade = market.trades[0];\n              const outLower = (bigTrade.outcome || '').toLowerCase();\n              if (bigTrade.outcomeIndex === 1 || outLower === 'no' || outLower === 'false') {\n                whaleTeam = team2;\n              }\n            }\n            \n            return {\n              team1,\n              team2,\n              yesTeam: team1,\n              noTeam: team2,\n              whaleTeam,\n              whaleOutcome: dominantOutcome || biggestTradeOutcome || null,\n              whalePrice: displayPrice,\n              yesPct: displayPrice,\n              noPct: displayPrice ? (100 - displayPrice) : null\n            };\n          }\n          return null;\n        })()\n      };\n      \n      allSignals.push(signal);\n      \n      // Separate sports signals for priority handling\n      if (signal.isSportsSignal) {\n        sportsSignals.push(signal);\n      }\n      \n      // Store signal\n      try {\n        if (await storeSignalForSettlement(env, signal)) signalsStored++;\n      } catch (e) {}\n      \n      // Track worthy wallets only\n      for (const trade of topTrades.slice(0, 3)) {\n        if (trade.wallet) {\n          try {\n            if (await trackWalletIfWorthy(env, trade.wallet, trade, signal)) walletsTracked++;\n          } catch (e) {}\n        }\n      }\n    }\n    \n    // Clear map to free memory\n    marketMap.clear();\n    \n    // ============================================================\n    // ENRICH SIGNALS WITH EVENT TIMING (start/end times)\n    // Batch lookup from Gamma API with caching\n    // ============================================================\n    try {\n      const slugsToLookup = allSignals.map(s => s.marketSlug).filter(Boolean);\n      if (slugsToLookup.length > 0) {\n        const timingMap = await batchGetEventTiming(env, slugsToLookup);\n        \n        let enriched = 0;\n        for (const signal of allSignals) {\n          const timing = timingMap.get(signal.marketSlug);\n          if (timing) {\n            signal.eventStartTime = timing.eventStartTime;\n            signal.eventEndTime = timing.eventEndTime;\n            signal.hoursUntilEvent = timing.hoursUntilEvent;\n            signal.hoursUntilEnd = timing.hoursUntilEnd;\n            signal.eventStatus = timing.eventStatus;\n            signal.eventTimingSource = timing.source;\n            enriched++;\n          }\n        }\n        console.log(`Enriched ${enriched}/${allSignals.length} signals with event timing`);\n      }\n    } catch (e) {\n      console.error('Event timing enrichment error:', e.message);\n      // Non-fatal - signals still work without timing\n    }\n    \n    // Sort all signals by score\n    allSignals.sort((a, b) => {\n      // Winning wallet signals first\n      if (a.hasWinningWallet && !b.hasWinningWallet) return -1;\n      if (!a.hasWinningWallet && b.hasWinningWallet) return 1;\n      // Then by score\n      return b.score - a.score;\n    });\n    \n    // Sort sports signals separately and ensure top 15\n    sportsSignals.sort((a, b) => {\n      if (a.hasWinningWallet && !b.hasWinningWallet) return -1;\n      if (!a.hasWinningWallet && b.hasWinningWallet) return 1;\n      return b.score - a.score;\n    });\n    \n    const result = {\n      success: true,\n      signals: allSignals,\n      sportsSignals: sportsSignals.slice(0, CONFIG.SPORTS_SIGNAL_LIMIT),\n      totalSignals: allSignals.length,\n      sportsSignalCount: sportsSignals.length,\n      signalsWithWinners: allSignals.filter(s => s.hasWinningWallet).length,\n      tradesProcessed: allTrades.length,\n      tradesSource: 'api',\n      signalsStored,\n      walletsTracked,\n      winningWalletsInCache: winningWallets.size,\n      processingTime: Date.now() - startTime,\n      marketsFound: marketMap.size,\n      debug: includeDebug ? debugStats : undefined\n    };\n    \n    await cacheScanResult(env, cacheKey, result);\n    \n    return result;\n    \n  } catch (e) {\n    console.error('Scan error:', e);\n    return { success: false, error: e.message, processingTime: Date.now() - startTime };\n  }\n}\n\n// ============================================================\n// SCORING\n// ============================================================\nfunction calculateSignalScore(market) {\n  let score = 0;\n  \n  // Whale bet size\n  if (market.largestBet >= 100000) score += 80;\n  else if (market.largestBet >= 50000) score += 60;\n  else if (market.largestBet >= 25000) score += 45;\n  else if (market.largestBet >= 10000) score += 30;\n  else if (market.largestBet >= 5000) score += 15;\n  \n  // Concentration\n  const walletCount = market.wallets.size;\n  if (walletCount === 1 && market.totalVolume >= 10000) score += 25;\n  else if (walletCount <= 2 && market.totalVolume >= 20000) score += 15;\n  else if (walletCount <= 5 && market.totalVolume >= 30000) score += 10;\n  \n  // Volume\n  if (market.totalVolume >= 500000) score += 25;\n  else if (market.totalVolume >= 100000) score += 15;\n  else if (market.totalVolume >= 50000) score += 8;\n  \n  // One-sided action\n  const dominantPercent = Math.max(market.yesVolume, market.noVolume) / market.totalVolume;\n  if (dominantPercent >= 0.90) score += 15;\n  else if (dominantPercent >= 0.80) score += 10;\n  \n  return Math.min(100, Math.round(score));\n}\n\nfunction getScoreBreakdown(market, displayPrice = 50, hasWinningWallet = false) {\n  const breakdown = [];\n  \n  // Whale size\n  if (market.largestBet >= 100000) breakdown.push({ factor: 'whaleSize100k', points: 80 });\n  else if (market.largestBet >= 50000) breakdown.push({ factor: 'whaleSize50k', points: 60 });\n  else if (market.largestBet >= 25000) breakdown.push({ factor: 'whaleSize25k', points: 45 });\n  else if (market.largestBet >= 15000) breakdown.push({ factor: 'whaleSize15k', points: 30 });\n  else if (market.largestBet >= 8000) breakdown.push({ factor: 'whaleSize8k', points: 20 });\n  else if (market.largestBet >= 5000) breakdown.push({ factor: 'whaleSize5k', points: 15 });\n  else if (market.largestBet >= 3000) breakdown.push({ factor: 'whaleSize3k', points: 10 });\n  \n  // Concentration\n  const walletCount = market.wallets.size;\n  if (walletCount === 1 && market.totalVolume >= 10000) breakdown.push({ factor: 'concentrated', points: 25 });\n  else if (walletCount <= 2 && market.totalVolume >= 20000) breakdown.push({ factor: 'concentrated', points: 15 });\n  \n  // Volume\n  if (market.totalVolume >= 500000) breakdown.push({ factor: 'volumeHuge', points: 25 });\n  else if (market.totalVolume >= 100000) breakdown.push({ factor: 'vol_100k_plus', points: 20 });\n  else if (market.totalVolume >= 50000) breakdown.push({ factor: 'vol_50k_100k', points: 15 });\n  else if (market.totalVolume >= 25000) breakdown.push({ factor: 'vol_25k_50k', points: 12 });\n  else if (market.totalVolume >= 10000) breakdown.push({ factor: 'vol_10k_25k', points: 10 });\n  else breakdown.push({ factor: 'vol_under_10k', points: 5 });\n  \n  // === IMPROVEMENT #4: Split odds into DIRECTIONAL factors ===\n  // Instead of one \"extremeOdds\" bucket, track buying cheap longshots vs expensive favorites separately\n  const price = displayPrice || 50;\n  const direction = market.yesVolume > market.noVolume ? 'YES' : 'NO';\n  // effectivePrice = the price the whales are BUYING at\n  // If direction=YES, they buy at displayPrice. If direction=NO, they buy at (100-displayPrice)\n  const effectivePrice = direction === 'YES' ? price : (100 - price);\n  \n  if (effectivePrice <= 15) {\n    breakdown.push({ factor: 'buyDeepLongshot', points: 35, desc: 'Buying at <15% (deep longshot)' });\n  } else if (effectivePrice <= 25) {\n    breakdown.push({ factor: 'buyLongshot', points: 20, desc: 'Buying at 15-25% (longshot)' });\n  } else if (effectivePrice <= 40) {\n    breakdown.push({ factor: 'buyUnderdog', points: 10, desc: 'Buying at 25-40% (underdog)' });\n  } else if (effectivePrice >= 85) {\n    breakdown.push({ factor: 'buyHeavyFavorite', points: 10, desc: 'Buying at 85%+ (heavy favorite)' });\n  } else if (effectivePrice >= 70) {\n    breakdown.push({ factor: 'buyFavorite', points: 8, desc: 'Buying at 70-85% (favorite)' });\n  }\n  // 40-70% range = no odds factor (fair price territory)\n  \n  // Keep legacy extremeOdds for backwards compat with existing stats (but lower points)\n  if (price <= 15 || price >= 85) breakdown.push({ factor: 'extremeOdds', points: 5 });\n  \n  // === IMPROVEMENT #5: Time-to-event factors ===\n  // How close to event start was the bet placed?\n  if (market.slug) {\n    const eventTiming = getEventTiming(market.slug, market.lastTradeTime);\n    if (eventTiming) {\n      breakdown.push(eventTiming);\n    }\n  }\n  \n  // WINNING WALLET FACTOR (high value!)\n  if (hasWinningWallet) {\n    breakdown.push({ factor: 'winningWallet', points: 30 });\n  }\n  \n  return breakdown;\n}\n\n/**\n * IMPROVEMENT #5: Calculate time-to-event and return a timing factor\n * Bets placed close to game time are much more likely to be informed\n */\nfunction getEventTiming(slug, lastTradeTime) {\n  // Extract event date from slug (e.g., \"nba-bos-lal-2026-02-03\")\n  const dateMatch = (slug || '').match(/(\\d{4})-(\\d{2})-(\\d{2})/);\n  if (!dateMatch) return null;\n  \n  const eventDate = new Date(\n    parseInt(dateMatch[1]),\n    parseInt(dateMatch[2]) - 1,\n    parseInt(dateMatch[3])\n  );\n  \n  // Estimate event start time based on sport\n  // Most games start evening ET (7-10pm), so estimate 00:00-03:00 UTC next day\n  // For afternoon games, ~5pm ET = 22:00 UTC\n  // We'll use midnight UTC as a rough event start for the game date\n  const estimatedEventStart = new Date(eventDate);\n  estimatedEventStart.setUTCHours(24, 0, 0, 0); // End of event date UTC \u2248 evening ET\n  \n  const tradeTime = typeof lastTradeTime === 'number' ? lastTradeTime : new Date(lastTradeTime).getTime();\n  if (!tradeTime || isNaN(tradeTime)) return null;\n  \n  const hoursBeforeEvent = (estimatedEventStart.getTime() - tradeTime) / (1000 * 60 * 60);\n  \n  if (hoursBeforeEvent <= 0) {\n    // Bet placed DURING or AFTER event (live betting / in-game)\n    return { factor: 'betDuringEvent', points: 20, desc: 'Bet placed during/after event start' };\n  } else if (hoursBeforeEvent <= 2) {\n    // Within 2 hours of event start \u2014 very late money\n    return { factor: 'betLast2Hours', points: 25, desc: 'Bet placed within 2h of event' };\n  } else if (hoursBeforeEvent <= 6) {\n    // Same day, close to game time\n    return { factor: 'betSameDay', points: 15, desc: 'Bet placed same day (2-6h before)' };\n  } else if (hoursBeforeEvent <= 24) {\n    // Day before\n    return { factor: 'betDayBefore', points: 8, desc: 'Bet placed day before event' };\n  } else if (hoursBeforeEvent <= 72) {\n    // 1-3 days before\n    return { factor: 'betEarlyDays', points: 5, desc: 'Bet placed 1-3 days before event' };\n  } else {\n    // Very early bet (3+ days)\n    return { factor: 'betVeryEarly', points: 3, desc: 'Bet placed 3+ days before event' };\n  }\n}\n\n// ============================================================\n// HELPER EXPORTS\n// ============================================================\nexport async function getRecentSignals(env, limit = 20) {\n  const cached = await getCachedScanResult(env, 'scan_result_48_40_all');\n  if (cached && cached.signals) return cached.signals.slice(0, limit);\n  const result = await runScan(24, 30, env, { sportsOnly: false });\n  return result.signals?.slice(0, limit) || [];\n}\n\nexport async function getSignal(env, signalId) {\n  const cached = await getCachedScanResult(env, 'scan_result_48_40_all');\n  if (cached && cached.signals) return cached.signals.find(s => s.id === signalId);\n  return null;\n}\n\nexport async function getPendingSignalsCount(env) {\n  if (!env.SIGNALS_CACHE) return 0;\n  try {\n    const pending = await env.SIGNALS_CACHE.get(KV_KEYS.PENDING_SIGNALS, { type: 'json' }) || [];\n    return pending.length;\n  } catch (e) { return 0; }\n}\n\nexport async function getTrackedWalletsCount(env) {\n  if (!env.SIGNALS_CACHE) return 0;\n  try {\n    const index = await env.SIGNALS_CACHE.get('tracked_wallet_index', { type: 'json' }) || [];\n    return index.length;\n  } catch (e) { return 0; }\n}\n", "// ============================================================\n// ODDS-API.JS - Vegas Odds + Polymarket Real-Time Comparison\n// v18.6.0 - Uses Gamma API for real-time Polymarket prices\n// ============================================================\n\nimport { ODDS_API_BASE, SPORT_KEY_MAP } from './config.js';\nimport { americanToProb, getTeamFullName } from './utils.js';\nimport { getSportsMarketsWithPrices, getMidpoint, getOrderBook } from './polymarket-api.js';\n\n// Cache duration in seconds\nconst CACHE_DURATION = {\n  ODDS: 30 * 60,      // 30 minutes for Vegas odds\n  SCORES: 15 * 60,    // 15 minutes for scores\n  COMPARISON: 10 * 60 // 10 minutes for full comparison (shorter since we have real-time Poly prices now)\n};\n\n// Map sport codes to Polymarket tag slugs\nconst POLYMARKET_SPORT_MAP = {\n  'nba': 'nba',\n  'nfl': 'nfl',\n  'ncaab': 'ncaa-cbb',\n  'cbb': 'ncaa-cbb',\n  'ncaaf': 'college-football',\n  'cfb': 'college-football',\n  'nhl': 'nhl',\n  'mlb': 'mlb',\n  'ufc': 'ufc',\n  'mma': 'mma'\n};\n\n// ============================================================\n// VEGAS ODDS (The Odds API)\n// ============================================================\n\nasync function getCachedOrFetch(env, cacheKey, fetchFn, ttlSeconds) {\n  if (!env.SIGNALS_CACHE) {\n    return await fetchFn();\n  }\n  \n  try {\n    const cached = await env.SIGNALS_CACHE.get(cacheKey, { type: \"json\" });\n    if (cached && cached.data !== undefined && cached.data !== null) {\n      const age = Date.now() - cached.timestamp;\n      const maxAge = ttlSeconds * 1000;\n      \n      if (age < maxAge) {\n        console.log(`Cache HIT for ${cacheKey} (age: ${Math.round(age/1000)}s)`);\n        // Return data directly - don't spread arrays into objects\n        return cached.data;\n      }\n    }\n    \n    console.log(`Cache MISS for ${cacheKey} - fetching fresh`);\n    const freshData = await fetchFn();\n    \n    if (freshData) {\n      await env.SIGNALS_CACHE.put(cacheKey, JSON.stringify({\n        data: freshData,\n        timestamp: Date.now()\n      }), { expirationTtl: ttlSeconds + 60 });\n    }\n    \n    return freshData;\n  } catch (e) {\n    console.error(`Cache error for ${cacheKey}:`, e.message);\n    return await fetchFn();\n  }\n}\n\nexport async function getGameOdds(env, sportKey, markets) {\n  if (!env.ODDS_API_KEY) {\n    console.log(\"No ODDS_API_KEY configured\");\n    return null;\n  }\n  \n  const cacheKey = `odds_data_${sportKey}_${markets || 'h2h,spreads'}`;\n  \n  return getCachedOrFetch(env, cacheKey, async () => {\n    try {\n      const url = `${ODDS_API_BASE}/sports/${sportKey}/odds/?apiKey=${env.ODDS_API_KEY}&regions=us&markets=${markets || 'h2h,spreads'}&oddsFormat=american`;\n      const response = await fetch(url);\n      \n      if (!response.ok) {\n        console.error(\"Odds API error:\", response.status);\n        return null;\n      }\n      \n      return await response.json();\n    } catch (e) {\n      console.error(\"Error fetching odds:\", e.message);\n      return null;\n    }\n  }, CACHE_DURATION.ODDS);\n}\n\nexport async function getGameScores(env, sportKey, daysFrom) {\n  if (!env.ODDS_API_KEY) return null;\n  \n  const cacheKey = `odds_scores_${sportKey}_${daysFrom || 3}`;\n  \n  return getCachedOrFetch(env, cacheKey, async () => {\n    try {\n      const url = `${ODDS_API_BASE}/sports/${sportKey}/scores/?apiKey=${env.ODDS_API_KEY}&daysFrom=${daysFrom || 3}`;\n      const response = await fetch(url);\n      if (!response.ok) return null;\n      return await response.json();\n    } catch (e) {\n      return null;\n    }\n  }, CACHE_DURATION.SCORES);\n}\n\n// ============================================================\n// MAIN: Vegas + Polymarket Comparison with REAL-TIME PRICES\n// ============================================================\n\nexport async function getOddsComparison(env, sport) {\n  const sportKey = SPORT_KEY_MAP[sport];\n  if (!sportKey) return { success: false, error: \"Sport not supported\" };\n  \n  if (!env.ODDS_API_KEY) {\n    return { success: false, error: \"Odds API not configured\" };\n  }\n  \n  const cacheKey = `odds_comparison_v2_${sport}`;\n  \n  // Check cache (shorter TTL now that we have real-time Poly prices)\n  if (env.SIGNALS_CACHE) {\n    try {\n      const cached = await env.SIGNALS_CACHE.get(cacheKey, { type: \"json\" });\n      if (cached && cached.data) {\n        const age = Date.now() - cached.timestamp;\n        const maxAge = CACHE_DURATION.COMPARISON * 1000;\n        \n        if (age < maxAge) {\n          console.log(`Comparison cache HIT for ${sport}`);\n          return { \n            ...cached.data, \n            fromCache: true, \n            cacheAge: Math.round(age/1000),\n            nextRefresh: Math.round((maxAge - age) / 1000)\n          };\n        }\n      }\n    } catch (e) {}\n  }\n  \n  try {\n    console.log(`Building odds comparison for ${sport}...`);\n    \n    // 1. Fetch Vegas odds\n    const vegasOddsRaw = await getGameOdds(env, sportKey, 'h2h,spreads');\n    \n    // getGameOdds returns through getCachedOrFetch which may wrap the array\n    // Handle: raw array, object with numeric keys (spread array), or null\n    let vegasOdds = [];\n    if (Array.isArray(vegasOddsRaw)) {\n      vegasOdds = vegasOddsRaw;\n    } else if (vegasOddsRaw && typeof vegasOddsRaw === 'object') {\n      // getCachedOrFetch spreads arrays into objects: { 0: game1, 1: game2, fromCache: true }\n      // Extract the game entries back out\n      const entries = Object.entries(vegasOddsRaw)\n        .filter(([key]) => /^\\d+$/.test(key))\n        .sort(([a], [b]) => parseInt(a) - parseInt(b))\n        .map(([_, val]) => val);\n      if (entries.length > 0) {\n        vegasOdds = entries;\n      }\n    }\n    \n    console.log(`Vegas odds extracted: ${vegasOdds.length} games (raw type: ${Array.isArray(vegasOddsRaw) ? 'array' : typeof vegasOddsRaw})`);\n    \n    // 2. Fetch Polymarket markets with REAL-TIME prices from Gamma API\n    const polyMarkets = await getSportsMarketsWithPrices(env, sport);\n    \n    console.log(`Vegas games: ${vegasOdds?.length || 0}, Poly markets: ${polyMarkets?.markets?.length || 0}`);\n    \n    // 3. Build Polymarket lookup by slug patterns\n    const polyLookup = buildPolymarketLookup(polyMarkets?.markets || []);\n    \n    // Debug: log sample lookup keys\n    const slugKeys = Object.keys(polyLookup.bySlug).slice(0, 5);\n    const teamDateKeys = Object.keys(polyLookup.byTeamDate).slice(0, 10);\n    console.log(`Poly lookup sample slugs: ${JSON.stringify(slugKeys)}`);\n    console.log(`Poly lookup sample team-dates: ${JSON.stringify(teamDateKeys)}`);\n    \n    // 4. Match and compare each Vegas game\n    const games = (vegasOdds || []).map(vegasGame => {\n      const result = processGameWithRealTimePrices(vegasGame, polyLookup);\n      if (!result.hasPolymarket) {\n        console.log(`NO MATCH: ${vegasGame.away_team} @ ${vegasGame.home_team} (${vegasGame.commence_time?.split('T')[0]})`);\n      } else {\n        console.log(`MATCHED: ${vegasGame.away_team} @ ${vegasGame.home_team} \u2192 ${result.polymarket?.slug}`);\n      }\n      return result;\n    });\n    \n    // 5. Sort by edge (reliable data first)\n    games.sort((a, b) => {\n      if (a.hasReliablePolyData && !b.hasReliablePolyData) return -1;\n      if (!a.hasReliablePolyData && b.hasReliablePolyData) return 1;\n      \n      const aEdge = Math.max(a.edge?.home || -100, a.edge?.away || -100);\n      const bEdge = Math.max(b.edge?.home || -100, b.edge?.away || -100);\n      return bEdge - aEdge;\n    });\n    \n    // 6. Extract value bets (only from reliable data)\n    const valueBets = games\n      .filter(g => g.edge?.bestBet && g.hasReliablePolyData)\n      .map(g => ({\n        game: `${g.awayTeam} @ ${g.homeTeam}`,\n        team: g.edge.bestBet.team,\n        edge: g.edge.bestBet.edge,\n        type: g.edge.bestBet.type,\n        vegasProb: g.edge.bestBet.vegasProb,\n        polyPrice: g.edge.bestBet.polyPrice,\n        polySlug: g.polymarket?.slug\n      }));\n    \n    const result = {\n      success: true,\n      sport,\n      sportKey,\n      version: '18.6.0-realtime',\n      timestamp: new Date().toISOString(),\n      gamesCount: games.length,\n      valueBetsCount: valueBets.length,\n      polymarketGamesMatched: games.filter(g => g.hasPolymarket).length,\n      polymarketSource: 'gamma-api-realtime',\n      valueBets,\n      games\n    };\n    \n    // Cache result\n    if (env.SIGNALS_CACHE) {\n      await env.SIGNALS_CACHE.put(cacheKey, JSON.stringify({\n        data: result,\n        timestamp: Date.now()\n      }), { expirationTtl: CACHE_DURATION.COMPARISON + 60 });\n    }\n    \n    return result;\n    \n  } catch (e) {\n    console.error('Odds comparison error:', e);\n    return { success: false, error: e.message, stack: e.stack };\n  }\n}\n\n// ============================================================\n// HELPERS\n// ============================================================\n\n/**\n * Build a lookup of Polymarket markets by various keys\n */\nfunction buildPolymarketLookup(markets) {\n  const lookup = {\n    bySlug: {},\n    byTeamDate: {}\n  };\n  \n  for (const market of markets) {\n    if (!market.slug) continue;\n    \n    const slug = market.slug.toLowerCase();\n    \n    // Store by full slug\n    lookup.bySlug[slug] = market;\n    \n    // Extract date from slug: nba-mem-lal-2026-02-03\n    const dateMatch = slug.match(/(\\d{4}-\\d{2}-\\d{2})/);\n    if (!dateMatch) continue;\n    const date = dateMatch[1];\n    \n    // Extract team abbreviations from slug\n    // Format: {sport}-{away}-{home}-{date} e.g. nba-mem-lal-2026-01-04\n    const parts = slug.split('-');\n    const dateIdx = parts.findIndex(p => /^\\d{4}$/.test(p));\n    if (dateIdx > 2) {\n      const teamParts = parts.slice(1, dateIdx); // e.g. ['mem', 'lal']\n      \n      // Store by each team abbreviation + date\n      for (const abbr of teamParts) {\n        const key = `${abbr}-${date}`;\n        if (!lookup.byTeamDate[key]) {\n          lookup.byTeamDate[key] = market;\n        }\n      }\n      \n      // Store by combined abbreviation + date\n      const combinedKey = `${teamParts.join('-')}-${date}`;\n      lookup.byTeamDate[combinedKey] = market;\n    }\n    \n    // ALSO index by full outcome team names (most reliable for matching)\n    // e.g. outcomes: [\"Lakers\", \"Grizzlies\"]\n    const outcomes = market.outcomes || [];\n    for (const outcome of outcomes) {\n      // Full outcome name lowercase, alphanumeric only\n      const cleanOutcome = outcome.toLowerCase().replace(/[^a-z0-9]/g, '');\n      lookup.byTeamDate[`${cleanOutcome}-${date}`] = market;\n      \n      // Also store individual words from outcome (for \"Trail Blazers\" -> \"blazers\")\n      const words = outcome.toLowerCase().split(/\\s+/);\n      for (const word of words) {\n        if (word.length > 3) {\n          const wordKey = `${word}-${date}`;\n          if (!lookup.byTeamDate[wordKey]) {\n            lookup.byTeamDate[wordKey] = market;\n          }\n        }\n      }\n    }\n    \n    // Index by event title words too (e.g. \"Grizzlies vs. Lakers\")\n    const title = (market.eventTitle || market.question || '').toLowerCase();\n    const titleWords = title.split(/[\\s.]+/).filter(w => w.length > 3 && w !== 'vs');\n    for (const word of titleWords) {\n      const wordKey = `${word}-${date}`;\n      if (!lookup.byTeamDate[wordKey]) {\n        lookup.byTeamDate[wordKey] = market;\n      }\n    }\n  }\n  \n  console.log(`Built Polymarket lookup: ${Object.keys(lookup.bySlug).length} by slug, ${Object.keys(lookup.byTeamDate).length} by team-date`);\n  \n  return lookup;\n}\n\n/**\n * Process a single Vegas game with real-time Polymarket prices\n */\nfunction processGameWithRealTimePrices(vegasGame, polyLookup) {\n  // Get Vegas odds from preferred books\n  const preferredBooks = ['fanduel', 'draftkings', 'betmgm'];\n  let h2hOdds = null;\n  let spreadOdds = null;\n  \n  for (const bookKey of preferredBooks) {\n    const book = vegasGame.bookmakers?.find(b => b.key === bookKey);\n    if (book) {\n      if (!h2hOdds) {\n        const h2hMarket = book.markets?.find(m => m.key === 'h2h');\n        if (h2hMarket) h2hOdds = h2hMarket.outcomes;\n      }\n      if (!spreadOdds) {\n        const spreadMarket = book.markets?.find(m => m.key === 'spreads');\n        if (spreadMarket) spreadOdds = spreadMarket.outcomes;\n      }\n    }\n    if (h2hOdds && spreadOdds) break;\n  }\n  \n  // Calculate Vegas probabilities\n  const vegasHomeProb = h2hOdds?.find(o => o.name === vegasGame.home_team)?.price ? \n    Math.round(americanToProb(h2hOdds.find(o => o.name === vegasGame.home_team).price) * 100) : null;\n  const vegasAwayProb = h2hOdds?.find(o => o.name === vegasGame.away_team)?.price ?\n    Math.round(americanToProb(h2hOdds.find(o => o.name === vegasGame.away_team).price) * 100) : null;\n  \n  // Find matching Polymarket data\n  const polyMatch = findPolymarketMatch(vegasGame, polyLookup);\n  \n  // Calculate edge if we have both prices\n  let homeEdge = null;\n  let awayEdge = null;\n  let polyHomePrice = null;\n  let polyAwayPrice = null;\n  \n  if (polyMatch) {\n    // Determine which Polymarket outcome corresponds to which Vegas team\n    // outcomes[0] has price outcomePrices[0] (yesPrice), outcomes[1] has outcomePrices[1] (noPrice)\n    if (polyMatch.outcomes && polyMatch.outcomes.length >= 2) {\n      const homeTeamLower = vegasGame.home_team.toLowerCase();\n      const awayTeamLower = vegasGame.away_team.toLowerCase();\n      \n      const outcome0Lower = polyMatch.outcomes[0].toLowerCase();\n      const outcome1Lower = polyMatch.outcomes[1].toLowerCase();\n      \n      // Use a scoring approach: score how well each outcome matches each team\n      // Higher score = better match. This handles same-mascot teams (Rams vs Rams)\n      const score_o0_home = teamMatchScore(outcome0Lower, homeTeamLower);\n      const score_o0_away = teamMatchScore(outcome0Lower, awayTeamLower);\n      const score_o1_home = teamMatchScore(outcome1Lower, homeTeamLower);\n      const score_o1_away = teamMatchScore(outcome1Lower, awayTeamLower);\n      \n      console.log(`Price assignment: o0=\"${polyMatch.outcomes[0]}\" o1=\"${polyMatch.outcomes[1]}\" | home=\"${vegasGame.home_team}\" away=\"${vegasGame.away_team}\" | scores: o0h=${score_o0_home} o0a=${score_o0_away} o1h=${score_o1_home} o1a=${score_o1_away} | yesPrice=${polyMatch.yesPrice} noPrice=${polyMatch.noPrice}`);\n      \n      // Pick the assignment that maximizes total match score\n      const assignNormal = score_o0_home + score_o1_away; // o0=home, o1=away\n      const assignFlipped = score_o0_away + score_o1_home; // o0=away, o1=home\n      \n      if (assignNormal >= assignFlipped && assignNormal > 0) {\n        // outcomes[0] = home team, outcomes[1] = away team\n        polyHomePrice = polyMatch.yesPrice;\n        polyAwayPrice = polyMatch.noPrice;\n        console.log(`\u2192 Assignment: NORMAL (o0=home=${polyMatch.yesPrice}\u00A2, o1=away=${polyMatch.noPrice}\u00A2)`);\n      } else if (assignFlipped > assignNormal && assignFlipped > 0) {\n        // outcomes[0] = away team, outcomes[1] = home team\n        polyAwayPrice = polyMatch.yesPrice;\n        polyHomePrice = polyMatch.noPrice;\n        console.log(`\u2192 Assignment: FLIPPED (o0=away=${polyMatch.yesPrice}\u00A2, o1=home=${polyMatch.noPrice}\u00A2)`);\n      } else {\n        // Can't determine - log warning but try based on slug order\n        console.log(`WARNING: Cannot determine team assignment for ${vegasGame.home_team} vs ${vegasGame.away_team}, outcomes: ${polyMatch.outcomes.join(', ')}`);\n        // Poly slug format is typically away-home, so outcomes[0]=away, outcomes[1]=home\n        polyAwayPrice = polyMatch.yesPrice;\n        polyHomePrice = polyMatch.noPrice;\n      }\n    } else {\n      // No outcomes to match - use raw prices\n      polyHomePrice = polyMatch.yesPrice;\n      polyAwayPrice = polyMatch.noPrice;\n    }\n    \n    // Calculate edge\n    if (polyHomePrice !== null && vegasHomeProb !== null) {\n      homeEdge = vegasHomeProb - polyHomePrice;\n    }\n    if (polyAwayPrice !== null && vegasAwayProb !== null) {\n      awayEdge = vegasAwayProb - polyAwayPrice;\n    }\n  }\n  \n  // Determine best bet (require at least 5% edge)\n  let bestBet = null;\n  if (homeEdge !== null && homeEdge >= 5) {\n    bestBet = { \n      team: vegasGame.home_team, \n      edge: Math.round(homeEdge), \n      type: 'moneyline',\n      vegasProb: vegasHomeProb,\n      polyPrice: polyHomePrice\n    };\n  } else if (awayEdge !== null && awayEdge >= 5) {\n    bestBet = { \n      team: vegasGame.away_team, \n      edge: Math.round(awayEdge), \n      type: 'moneyline',\n      vegasProb: vegasAwayProb,\n      polyPrice: polyAwayPrice\n    };\n  }\n  \n  return {\n    id: vegasGame.id,\n    homeTeam: vegasGame.home_team,\n    awayTeam: vegasGame.away_team,\n    commenceTime: vegasGame.commence_time,\n    vegas: {\n      moneyline: h2hOdds ? {\n        home: { \n          odds: h2hOdds.find(o => o.name === vegasGame.home_team)?.price,\n          prob: vegasHomeProb\n        },\n        away: { \n          odds: h2hOdds.find(o => o.name === vegasGame.away_team)?.price,\n          prob: vegasAwayProb\n        }\n      } : null,\n      spread: spreadOdds ? {\n        home: {\n          line: spreadOdds.find(o => o.name === vegasGame.home_team)?.point,\n          odds: spreadOdds.find(o => o.name === vegasGame.home_team)?.price\n        },\n        away: {\n          line: spreadOdds.find(o => o.name === vegasGame.away_team)?.point,\n          odds: spreadOdds.find(o => o.name === vegasGame.away_team)?.price\n        }\n      } : null\n    },\n    polymarket: polyMatch ? {\n      slug: polyMatch.slug,\n      outcomes: polyMatch.outcomes,\n      // Direct access (backwards compat)\n      home: { price: polyHomePrice },\n      away: { price: polyAwayPrice },\n      // Nested under moneyline (what GameCard.jsx expects)\n      moneyline: {\n        home: { price: polyHomePrice },\n        away: { price: polyAwayPrice }\n      },\n      volume: polyMatch.volume,\n      liquidity: polyMatch.liquidity,\n      source: 'gamma-api-realtime',\n      lastUpdate: new Date().toISOString()\n    } : null,\n    edge: { \n      home: homeEdge !== null ? Math.round(homeEdge) : null, \n      away: awayEdge !== null ? Math.round(awayEdge) : null, \n      bestBet \n    },\n    hasPolymarket: !!polyMatch,\n    hasReliablePolyData: !!(polyMatch && (polyHomePrice || polyAwayPrice))\n  };\n}\n\n/**\n * Find matching Polymarket market for a Vegas game\n */\nfunction findPolymarketMatch(vegasGame, polyLookup) {\n  const homeTeam = vegasGame.home_team; // e.g. \"Indiana Pacers\"\n  const awayTeam = vegasGame.away_team; // e.g. \"Houston Rockets\" \n  const gameDate = vegasGame.commence_time?.split('T')[0]; // e.g. \"2026-02-03\"\n  \n  if (!gameDate) return null;\n  \n  // Check \u00B11 day for timezone offset (UTC vs ET)\n  const d = new Date(gameDate);\n  const prevDay = new Date(d); prevDay.setDate(d.getDate() - 1);\n  const nextDay = new Date(d); nextDay.setDate(d.getDate() + 1);\n  const searchDates = [\n    gameDate,\n    nextDay.toISOString().split('T')[0],\n    prevDay.toISOString().split('T')[0]\n  ];\n  \n  // Extract useful matching tokens from team names\n  const homeWords = homeTeam.toLowerCase().split(/\\s+/);\n  const awayWords = awayTeam.toLowerCase().split(/\\s+/);\n  const homeLast = homeWords[homeWords.length - 1]; // \"pacers\"\n  const awayLast = awayWords[awayWords.length - 1]; // \"rockets\"\n  \n  // NBA team abbreviation map (Vegas full name -> Poly abbreviation)\n  const NBA_ABBREV = {\n    'hawks': 'atl', 'celtics': 'bos', 'nets': 'bkn', 'hornets': 'cha',\n    'bulls': 'chi', 'cavaliers': 'cle', 'mavericks': 'dal', 'nuggets': 'den',\n    'pistons': 'det', 'warriors': 'gsw', 'rockets': 'hou', 'pacers': 'ind',\n    'clippers': 'lac', 'lakers': 'lal', 'grizzlies': 'mem', 'heat': 'mia',\n    'bucks': 'mil', 'timberwolves': 'min', 'pelicans': 'nop', 'knicks': 'nyk',\n    'thunder': 'okc', 'magic': 'orl', '76ers': 'phi', 'suns': 'phx',\n    'trail blazers': 'por', 'kings': 'sac', 'spurs': 'sas', 'raptors': 'tor',\n    'jazz': 'uta', 'wizards': 'was',\n  };\n  \n  // Get abbreviations\n  const homeAbbrev = NBA_ABBREV[homeLast] || NBA_ABBREV[homeTeam.toLowerCase().split(' ').slice(1).join(' ')] || null;\n  const awayAbbrev = NBA_ABBREV[awayLast] || NBA_ABBREV[awayTeam.toLowerCase().split(' ').slice(1).join(' ')] || null;\n  \n  for (const date of searchDates) {\n    // Strategy 1: Match by team mascot/nickname + date (most reliable)\n    // e.g. \"pacers-2026-02-04\" -> lookup\n    const homeKey = `${homeLast}-${date}`;\n    const homeMatch = polyLookup.byTeamDate[homeKey];\n    if (homeMatch) {\n      // Verify the other team is also in this market\n      const matchStr = (homeMatch.slug + ' ' + (homeMatch.outcomes || []).join(' ') + ' ' + (homeMatch.eventTitle || '')).toLowerCase();\n      if (matchStr.includes(awayLast)) {\n        console.log(`MATCHED by mascot: ${awayTeam} @ ${homeTeam} \u2192 ${homeMatch.slug}`);\n        return homeMatch;\n      }\n    }\n    \n    // Strategy 2: Match by NBA abbreviation in slug\n    if (homeAbbrev && awayAbbrev) {\n      // Try both orderings: away-home and home-away\n      const key1 = `${awayAbbrev}-${homeAbbrev}-${date}`;\n      const key2 = `${homeAbbrev}-${awayAbbrev}-${date}`;\n      if (polyLookup.byTeamDate[key1]) {\n        console.log(`MATCHED by abbrev: ${awayTeam} @ ${homeTeam} \u2192 ${polyLookup.byTeamDate[key1].slug}`);\n        return polyLookup.byTeamDate[key1];\n      }\n      if (polyLookup.byTeamDate[key2]) {\n        console.log(`MATCHED by abbrev: ${awayTeam} @ ${homeTeam} \u2192 ${polyLookup.byTeamDate[key2].slug}`);\n        return polyLookup.byTeamDate[key2];\n      }\n    }\n    \n    // Strategy 3: Match by full team name concatenated\n    const homeClean = homeTeam.toLowerCase().replace(/[^a-z0-9]/g, '');\n    const awayClean = awayTeam.toLowerCase().replace(/[^a-z0-9]/g, '');\n    if (polyLookup.byTeamDate[`${homeClean}-${date}`]) {\n      console.log(`MATCHED by fullname: ${awayTeam} @ ${homeTeam} \u2192 slug`);\n      return polyLookup.byTeamDate[`${homeClean}-${date}`];\n    }\n    if (polyLookup.byTeamDate[`${awayClean}-${date}`]) {\n      return polyLookup.byTeamDate[`${awayClean}-${date}`];\n    }\n    \n    // Strategy 4: Scan all slugs for this date looking for both team indicators\n    for (const [slug, market] of Object.entries(polyLookup.bySlug)) {\n      if (!slug.includes(date)) continue;\n      \n      const matchStr = slug + ' ' + (market.outcomes || []).join(' ').toLowerCase() + ' ' + (market.eventTitle || '').toLowerCase();\n      \n      // Check if both teams are represented\n      const hasHome = matchStr.includes(homeLast) || (homeAbbrev && slug.includes(homeAbbrev));\n      const hasAway = matchStr.includes(awayLast) || (awayAbbrev && slug.includes(awayAbbrev));\n      \n      if (hasHome && hasAway) {\n        console.log(`MATCHED by scan: ${awayTeam} @ ${homeTeam} \u2192 ${slug}`);\n        return market;\n      }\n    }\n  }\n  \n  console.log(`NO MATCH: ${awayTeam} @ ${homeTeam} (${gameDate})`);\n  return null;\n}\n\n/**\n * Score how well an outcome string matches a team name (0 = no match, higher = better)\n * Uses word-level matching with bonus for distinctive words (city, school, mascot)\n * This handles same-mascot teams like \"VCU Rams\" vs \"Fordham Rams\"\n */\nfunction teamMatchScore(outcome, teamName) {\n  // Normalize common abbreviations before scoring\n  const normalize = (s) => s\n    .replace(/\\bst\\b/g, 'state')\n    .replace(/\\bn'western\\b/g, 'northwestern')\n    .replace(/\\bsf\\b/g, 'san francisco')\n    .replace(/\\bsfa\\b/g, 'stephen f austin');\n  \n  outcome = normalize(outcome);\n  teamName = normalize(teamName);\n  \n  const outcomeWords = outcome.split(/[\\s.]+/).filter(w => w.length > 1);\n  const teamWords = teamName.split(/[\\s.]+/).filter(w => w.length > 1);\n  \n  if (outcomeWords.length === 0 || teamWords.length === 0) return 0;\n  \n  let score = 0;\n  let matchedWords = 0;\n  \n  for (const ow of outcomeWords) {\n    for (const tw of teamWords) {\n      if (ow === tw) {\n        // Exact word match\n        score += 10;\n        matchedWords++;\n      } else if (ow.length > 3 && tw.length > 3 && (ow.includes(tw) || tw.includes(ow))) {\n        // Partial word match (e.g. \"northwestern\" contains \"western\")\n        score += 5;\n        matchedWords++;\n      }\n    }\n  }\n  \n  // Bonus for matching the FULL outcome (all words matched)\n  if (matchedWords >= outcomeWords.length && outcomeWords.length > 1) {\n    score += 20;\n  }\n  \n  // Bonus for exact substring match (e.g. outcome \"VCU Rams\" is in \"VCU Rams\")\n  if (teamName.includes(outcome) || outcome.includes(teamName)) {\n    score += 50;\n  }\n  \n  return score;\n}\n\n/**\n * Check if outcome string matches team name\n * Must match on the DISTINCTIVE part (mascot/nickname), not just shared city/state names\n * e.g. \"Tennessee Tech Golden Eagles\" vs \"Tennessee State Tigers\" - shared \"Tennessee\" should NOT match\n */\nfunction isTeamMatch(outcome, teamName) {\n  const outcomeWords = outcome.split(/[\\s.]+/).filter(w => w.length > 2);\n  const teamWords = teamName.split(/[\\s.]+/).filter(w => w.length > 2);\n  \n  if (outcomeWords.length === 0 || teamWords.length === 0) return false;\n  \n  // The most reliable identifier is the LAST word (mascot/nickname)\n  // e.g. \"eagles\", \"tigers\", \"rockets\", \"lakers\"\n  const outcomeLast = outcomeWords[outcomeWords.length - 1];\n  const teamLast = teamWords[teamWords.length - 1];\n  \n  // If last words match, it's almost certainly the same team\n  if (outcomeLast === teamLast || outcomeLast.includes(teamLast) || teamLast.includes(outcomeLast)) {\n    return true;\n  }\n  \n  // For short outcome names (1-2 words like \"Eagles\" or \"Golden Eagles\"),\n  // check if the outcome IS the mascot portion of the team name\n  if (outcomeWords.length <= 2) {\n    // The outcome should match the END of the team name (the mascot part)\n    const teamMascot = teamWords.slice(-outcomeWords.length).join(' ');\n    const outcomeStr = outcomeWords.join(' ');\n    if (outcomeStr === teamMascot) return true;\n  }\n  \n  // For full team names, require at least 2 distinctive words to match\n  // This prevents \"tennessee\" alone from matching\n  const matchingWords = outcomeWords.filter(ow => \n    teamWords.some(tw => ow === tw || (ow.length > 4 && (ow.includes(tw) || tw.includes(ow))))\n  );\n  \n  // Need majority of the shorter name's words to match\n  const minWords = Math.min(outcomeWords.length, teamWords.length);\n  return matchingWords.length >= Math.max(2, Math.ceil(minWords * 0.6));\n}\n\n// ============================================================\n// FIND MATCHING GAME (used by settlement.js)\n// ============================================================\n\n/**\n * Find matching game in Odds API results\n * @param {Array} games - Array of games from Odds API\n * @param {string} homeTeamCode - Home team code\n * @param {string} awayTeamCode - Away team code\n * @returns {Object|null} - Matching game or null\n */\nexport function findMatchingGame(games, homeTeamCode, awayTeamCode) {\n  if (!games || !Array.isArray(games)) return null;\n  \n  const homeFullName = getTeamFullName(homeTeamCode);\n  const awayFullName = getTeamFullName(awayTeamCode);\n  \n  for (const game of games) {\n    const gameHome = (game.home_team || '').toLowerCase();\n    const gameAway = (game.away_team || '').toLowerCase();\n    const homeMatch = homeFullName.toLowerCase();\n    const awayMatch = awayFullName.toLowerCase();\n    \n    if ((gameHome.includes(homeMatch) || homeMatch.includes(gameHome)) &&\n        (gameAway.includes(awayMatch) || awayMatch.includes(gameAway))) {\n      return game;\n    }\n    if ((gameHome.includes(awayMatch) || awayMatch.includes(gameHome)) &&\n        (gameAway.includes(homeMatch) || homeMatch.includes(gameAway))) {\n      return game;\n    }\n  }\n  \n  return null;\n}", "// ============================================================\n// SETTLEMENT.JS - Bet Settlement Logic\n// ============================================================\n\nimport { POLYMARKET_API, KV_KEYS, SPORT_KEY_MAP } from './config.js';\nimport { detectSportFromSlug, extractTeamsFromSlug, getTeamFullName } from './utils.js';\nimport { getGameScores, findMatchingGame } from './odds-api.js';\nimport { recordWalletOutcome } from './wallets.js';\nimport { updateFactorStats, trackSignalMetadata, trackFactorCombo } from './learning.js';\n\n// Check market settlement via Polymarket trades\nexport async function checkMarketSettlement(marketSlug, signalDetectedAt) {\n  try {\n    const tradesRes = await fetch(`${POLYMARKET_API}/trades?limit=2000`);\n    if (!tradesRes.ok) {\n      console.log(`Trades API error: ${tradesRes.status}`);\n      return null;\n    }\n    \n    const trades = await tradesRes.json();\n    \n    // Find trades for this market\n    let marketTrades = trades.filter(t => \n      t.slug === marketSlug || \n      t.eventSlug === marketSlug\n    );\n    \n    // Try base slug for spread/total markets\n    if (marketTrades.length === 0 && (marketSlug.includes('-spread') || marketSlug.includes('-total'))) {\n      const baseSlug = marketSlug.replace(/-spread.*$/, '').replace(/-total.*$/, '');\n      marketTrades = trades.filter(t => \n        t.slug === baseSlug || t.eventSlug === baseSlug\n      );\n    }\n    \n    // Check event date\n    const slugDateMatch = (marketSlug || '').match(/(\\d{4})-(\\d{2})-(\\d{2})/);\n    let hoursSinceEvent = 0;\n    \n    if (slugDateMatch) {\n      const eventDate = new Date(\n        parseInt(slugDateMatch[1]),\n        parseInt(slugDateMatch[2]) - 1,\n        parseInt(slugDateMatch[3]),\n        23, 59, 59\n      );\n      hoursSinceEvent = (Date.now() - eventDate.getTime()) / (1000 * 60 * 60);\n    } else if (signalDetectedAt) {\n      const detectedTime = new Date(signalDetectedAt).getTime();\n      hoursSinceEvent = (Date.now() - detectedTime) / (1000 * 60 * 60);\n    }\n    \n    if (marketTrades.length === 0) {\n      if (hoursSinceEvent > 12) {\n        return { \n          settled: true, \n          winningOutcome: \"UNKNOWN\", \n          resolutionPrice: 0,\n          note: `Event ${Math.round(hoursSinceEvent)}h ago, no recent trades`\n        };\n      }\n      return { settled: false };\n    }\n    \n    // Get latest trade\n    marketTrades.sort((a, b) => b.timestamp - a.timestamp);\n    const latestTrade = marketTrades[0];\n    const latestPrice = parseFloat(latestTrade.price);\n    \n    // Check settlement thresholds\n    if (latestPrice >= 0.95) {\n      return {\n        settled: true,\n        winningOutcome: latestTrade.outcome || \"Yes\",\n        resolutionPrice: latestPrice\n      };\n    }\n    \n    if (latestPrice <= 0.05) {\n      let winningOutcome = \"No\";\n      if (latestTrade.outcome === \"No\") winningOutcome = \"Yes\";\n      else if (latestTrade.outcome === \"Yes\") winningOutcome = \"No\";\n      \n      return {\n        settled: true,\n        winningOutcome,\n        resolutionPrice: 1 - latestPrice\n      };\n    }\n    \n    if (hoursSinceEvent > 24) {\n      return { \n        settled: true, \n        winningOutcome: \"UNKNOWN\", \n        resolutionPrice: latestPrice,\n        note: `Event ${Math.round(hoursSinceEvent)}h ago, ambiguous price`\n      };\n    }\n    \n    return { settled: false, currentPrice: latestPrice };\n    \n  } catch (e) {\n    console.error(`Error checking settlement for ${marketSlug}:`, e.message);\n    return null;\n  }\n}\n\n// Settle sports bet using The Odds API\nexport async function settleWithOddsAPI(env, marketSlug, direction) {\n  const sport = detectSportFromSlug(marketSlug);\n  if (!sport) return null;\n  \n  const sportKey = SPORT_KEY_MAP[sport];\n  if (!sportKey) return null;\n  \n  const teams = extractTeamsFromSlug(marketSlug);\n  if (!teams) return null;\n  \n  const scores = await getGameScores(env, sportKey, 3);\n  if (!scores) return null;\n  \n  const game = findMatchingGame(scores, teams.home, teams.away);\n  if (!game) {\n    console.log(`No matching game found for ${marketSlug}`);\n    return null;\n  }\n  \n  if (!game.completed) {\n    return { status: 'pending', game };\n  }\n  \n  if (!game.scores || game.scores.length < 2) {\n    return { status: 'no_scores', game };\n  }\n  \n  const homeScore = parseInt(game.scores.find(s => s.name === game.home_team)?.score || 0);\n  const awayScore = parseInt(game.scores.find(s => s.name === game.away_team)?.score || 0);\n  \n  // Determine winner\n  let winner;\n  if (homeScore > awayScore) winner = game.home_team;\n  else if (awayScore > homeScore) winner = game.away_team;\n  else winner = 'tie';\n  \n  // Handle spread bets\n  const isSpread = marketSlug.includes('spread');\n  if (isSpread) {\n    const spreadMatch = marketSlug.match(/spread-(home|away)-(\\d+)pt?(\\d)?/i);\n    if (spreadMatch) {\n      const spreadSide = spreadMatch[1].toLowerCase();\n      const spreadPoints = parseFloat(`${spreadMatch[2]}.${spreadMatch[3] || '5'}`);\n      \n      let spreadWinner;\n      if (spreadSide === 'away') {\n        spreadWinner = (awayScore + spreadPoints) > homeScore ? game.away_team : game.home_team;\n      } else {\n        spreadWinner = (homeScore - awayScore) > spreadPoints ? game.home_team : game.away_team;\n      }\n      \n      const dirTeam = getTeamFullName(direction);\n      const didWin = spreadWinner.toLowerCase().includes(dirTeam.toLowerCase()) ||\n                     dirTeam.toLowerCase().includes(spreadWinner.toLowerCase());\n      \n      return {\n        status: 'settled',\n        outcome: didWin ? 'WIN' : 'LOSS',\n        game,\n        homeScore,\n        awayScore,\n        spread: spreadPoints,\n        spreadWinner,\n        source: 'odds-api'\n      };\n    }\n  }\n  \n  // Moneyline bet\n  const dirTeam = getTeamFullName(direction);\n  const didWin = winner.toLowerCase().includes(dirTeam.toLowerCase()) ||\n                 dirTeam.toLowerCase().includes(winner.toLowerCase());\n  \n  return {\n    status: 'settled',\n    outcome: didWin ? 'WIN' : 'LOSS',\n    game,\n    homeScore,\n    awayScore,\n    winner,\n    source: 'odds-api'\n  };\n}\n\n// Process settled signals\nexport async function processSettledSignals(env) {\n  if (!env.SIGNALS_CACHE) return { processed: 0, wins: 0, losses: 0 };\n  \n  const results = { processed: 0, wins: 0, losses: 0, errors: 0 };\n  \n  try {\n    let pendingSignals = await env.SIGNALS_CACHE.get(KV_KEYS.PENDING_SIGNALS, { type: \"json\" }) || [];\n    const stillPending = [];\n    \n    console.log(`Checking ${pendingSignals.length} pending signals...`);\n    \n    for (const signalId of pendingSignals) {\n      try {\n        const signalKey = KV_KEYS.SIGNALS_PREFIX + signalId;\n        const signalData = await env.SIGNALS_CACHE.get(signalKey, { type: \"json\" });\n        \n        if (!signalData || signalData.outcome) {\n          continue;\n        }\n        \n        // ============================================================\n        // EVENT TIMING GUARD: Don't attempt settlement before event ends\n        // This prevents signals from being prematurely settled or dropped\n        // ============================================================\n        if (signalData.eventStartTime) {\n          const eventStart = new Date(signalData.eventStartTime).getTime();\n          const now = Date.now();\n          \n          if (now < eventStart) {\n            // Event hasn't started yet - definitely still pending\n            stillPending.push(signalId);\n            continue;\n          }\n          \n          // If event has endTime, check that too\n          if (signalData.eventEndTime) {\n            const eventEnd = new Date(signalData.eventEndTime).getTime();\n            // Allow 1 hour buffer after estimated end for settlement lag\n            if (now < eventEnd + (60 * 60 * 1000)) {\n              // Event still in progress or just ended - check but be cautious\n              // Fall through to normal settlement logic\n            }\n          }\n        }\n        \n        // Try Odds API first for sports\n        const sport = detectSportFromSlug(signalData.marketSlug);\n        \n        if (sport && SPORT_KEY_MAP[sport] && env.ODDS_API_KEY) {\n          const oddsApiResult = await settleWithOddsAPI(env, signalData.marketSlug, signalData.direction);\n          \n          if (oddsApiResult?.status === 'settled') {\n            const outcome = oddsApiResult.outcome;\n            const profitPct = outcome === \"WIN\" \n              ? Math.round(((1 - (signalData.priceAtSignal / 100)) / (signalData.priceAtSignal / 100)) * 100)\n              : -100;\n            \n            signalData.outcome = outcome;\n            signalData.settledAt = new Date().toISOString();\n            signalData.profitLoss = profitPct;\n            signalData.gameScore = `${oddsApiResult.homeScore}-${oddsApiResult.awayScore}`;\n            signalData.settledBy = 'odds-api';\n            \n            await env.SIGNALS_CACHE.put(signalKey, JSON.stringify(signalData), {\n              expirationTtl: 30 * 24 * 60 * 60\n            });\n            \n            // Update wallet stats\n            for (const wallet of (signalData.wallets || [])) {\n              await recordWalletOutcome(env, wallet, outcome, profitPct, signalData.marketType, signalData.largestBet, signalId);\n            }\n            \n            // Update factor stats for AI learning\n            // Handle both scoreBreakdown and factors field names\n            const factors = signalData.scoreBreakdown || signalData.factors || [];\n            if (factors.length > 0) {\n              await updateFactorStats(env, factors, outcome);\n              \n              // NEW: Track factor combinations\n              await trackFactorCombo(env, factors, outcome);\n            }\n            \n            // Track signal metadata for pattern discovery\n            await trackSignalMetadata(env, signalData, outcome);\n            \n            results.processed++;\n            if (outcome === \"WIN\") results.wins++;\n            else results.losses++;\n            \n            continue;\n          } else if (oddsApiResult?.status === 'pending') {\n            stillPending.push(signalId);\n            continue;\n          }\n        }\n        \n        // Fall back to Polymarket settlement\n        const settlement = await checkMarketSettlement(signalData.marketSlug, signalData.detectedAt);\n        \n        if (!settlement || !settlement.settled) {\n          stillPending.push(signalId);\n          continue;\n        }\n        \n        // Handle UNKNOWN\n        if (settlement.winningOutcome === \"UNKNOWN\") {\n          signalData.outcome = \"UNKNOWN\";\n          signalData.settledAt = new Date().toISOString();\n          await env.SIGNALS_CACHE.put(signalKey, JSON.stringify(signalData), {\n            expirationTtl: 7 * 24 * 60 * 60\n          });\n          results.processed++;\n          continue;\n        }\n        \n        // Determine win/loss\n        const signalDirection = (signalData.direction || \"\").toLowerCase();\n        const winningOutcome = (settlement.winningOutcome || \"\").toLowerCase();\n        \n        let outcome = \"LOSS\";\n        if (signalDirection === winningOutcome) outcome = \"WIN\";\n        else if (signalDirection === \"yes\" && winningOutcome === \"yes\") outcome = \"WIN\";\n        else if (signalDirection === \"no\" && winningOutcome === \"no\") outcome = \"WIN\";\n        \n        const entryPrice = signalData.priceAtSignal / 100;\n        const profitPct = outcome === \"WIN\" \n          ? Math.round(((1 - entryPrice) / entryPrice) * 100)\n          : -100;\n        \n        signalData.outcome = outcome;\n        signalData.settledAt = new Date().toISOString();\n        signalData.profitLoss = profitPct;\n        signalData.settledBy = 'polymarket';\n        \n        await env.SIGNALS_CACHE.put(signalKey, JSON.stringify(signalData), {\n          expirationTtl: 30 * 24 * 60 * 60\n        });\n        \n        // Update wallet stats\n        for (const wallet of (signalData.wallets || [])) {\n          await recordWalletOutcome(env, wallet, outcome, profitPct, signalData.marketType, signalData.largestBet, signalId);\n        }\n        \n        // Update factor stats for AI learning\n        // Handle both scoreBreakdown and factors field names\n        const polyFactors = signalData.scoreBreakdown || signalData.factors || [];\n        if (polyFactors.length > 0) {\n          await updateFactorStats(env, polyFactors, outcome);\n          \n          // NEW: Track factor combinations\n          await trackFactorCombo(env, polyFactors, outcome);\n        }\n        \n        // Track signal metadata for pattern discovery\n        await trackSignalMetadata(env, signalData, outcome);\n        \n        results.processed++;\n        if (outcome === \"WIN\") results.wins++;\n        else results.losses++;\n        \n      } catch (e) {\n        results.errors++;\n        stillPending.push(signalId);\n      }\n    }\n    \n    // Update pending list\n    await env.SIGNALS_CACHE.put(KV_KEYS.PENDING_SIGNALS, JSON.stringify(stillPending), {\n      expirationTtl: 30 * 24 * 60 * 60\n    });\n    \n    return results;\n    \n  } catch (e) {\n    console.error(\"Error processing settlements:\", e.message);\n    return results;\n  }\n}", "// ============================================================\n// TRADES.JS - Trade Accumulation System\n// Polls Polymarket API and stores trades in KV for historical data\n// ============================================================\n\nimport { POLYMARKET_API } from './config.js';\n\n// KV Keys for trade storage\nconst TRADES_KV_KEYS = {\n  TRADE_BUCKET_PREFIX: 'trades_bucket_',  // trades_bucket_2026-01-30-23 (hourly buckets)\n  TRADE_INDEX: 'trades_index',             // List of bucket keys\n  LAST_POLL: 'trades_last_poll',\n  POLL_STATS: 'trades_poll_stats'\n};\n\n// Get bucket key for a timestamp\nfunction getBucketKey(timestamp) {\n  const date = new Date(timestamp);\n  const year = date.getUTCFullYear();\n  const month = String(date.getUTCMonth() + 1).padStart(2, '0');\n  const day = String(date.getUTCDate()).padStart(2, '0');\n  const hour = String(date.getUTCHours()).padStart(2, '0');\n  return `${TRADES_KV_KEYS.TRADE_BUCKET_PREFIX}${year}-${month}-${day}-${hour}`;\n}\n\n// Poll for new trades and store in KV\nexport async function pollAndStoreTrades(env) {\n  if (!env.SIGNALS_CACHE) {\n    return { success: false, error: 'No KV storage available' };\n  }\n  \n  const startTime = Date.now();\n  \n  try {\n    // Fetch latest trades from API\n    const tradesRes = await fetch(`${POLYMARKET_API}/trades?limit=1000`);\n    if (!tradesRes.ok) {\n      throw new Error(`Trades API error: ${tradesRes.status}`);\n    }\n    \n    const trades = await tradesRes.json();\n    \n    // Get last poll timestamp to avoid duplicates\n    const lastPollStr = await env.SIGNALS_CACHE.get(TRADES_KV_KEYS.LAST_POLL);\n    const lastPollTime = lastPollStr ? parseInt(lastPollStr) : 0;\n    \n    // Filter to only new trades (after last poll)\n    const newTrades = trades.filter(t => {\n      const tradeTime = t.timestamp * 1000; // Convert to ms\n      return tradeTime > lastPollTime;\n    });\n    \n    if (newTrades.length === 0) {\n      // Update last poll time anyway\n      await env.SIGNALS_CACHE.put(TRADES_KV_KEYS.LAST_POLL, String(Date.now()));\n      return {\n        success: true,\n        newTrades: 0,\n        message: 'No new trades since last poll'\n      };\n    }\n    \n    // Group trades by hourly bucket\n    const buckets = {};\n    for (const trade of newTrades) {\n      const tradeTime = trade.timestamp * 1000;\n      const bucketKey = getBucketKey(tradeTime);\n      \n      if (!buckets[bucketKey]) {\n        buckets[bucketKey] = [];\n      }\n      \n      // Store minimal trade data to save space\n      buckets[bucketKey].push({\n        ts: trade.timestamp,\n        slug: trade.slug || trade.eventSlug,\n        eventSlug: trade.eventSlug,\n        title: trade.title,\n        outcome: trade.outcome,\n        outcomeIndex: trade.outcomeIndex,  // 0 = Yes/Team1, 1 = No/Team2\n        side: trade.side,\n        price: trade.price,\n        size: trade.size,\n        proxyWallet: trade.proxyWallet,\n        icon: trade.icon\n      });\n    }\n    \n    // Store each bucket (merge with existing)\n    const bucketKeys = Object.keys(buckets);\n    for (const bucketKey of bucketKeys) {\n      // Get existing bucket data\n      const existingData = await env.SIGNALS_CACHE.get(bucketKey, { type: 'json' }) || [];\n      \n      // Merge new trades (avoid duplicates by timestamp+wallet+slug)\n      const existingSet = new Set(existingData.map(t => `${t.ts}-${t.proxyWallet}-${t.slug}`));\n      const newBucketTrades = buckets[bucketKey].filter(t => \n        !existingSet.has(`${t.ts}-${t.proxyWallet}-${t.slug}`)\n      );\n      \n      if (newBucketTrades.length > 0) {\n        const mergedTrades = [...existingData, ...newBucketTrades];\n        \n        // Store with 72 hour TTL (we only need 48h but buffer for safety)\n        await env.SIGNALS_CACHE.put(bucketKey, JSON.stringify(mergedTrades), {\n          expirationTtl: 72 * 60 * 60\n        });\n      }\n    }\n    \n    // Update trade index (list of active buckets)\n    const existingIndex = await env.SIGNALS_CACHE.get(TRADES_KV_KEYS.TRADE_INDEX, { type: 'json' }) || [];\n    const indexSet = new Set(existingIndex);\n    for (const key of bucketKeys) {\n      indexSet.add(key);\n    }\n    \n    // Clean up old buckets from index (older than 72 hours)\n    const cutoffTime = Date.now() - (72 * 60 * 60 * 1000);\n    const activeIndex = [...indexSet].filter(key => {\n      // Extract date from key: trades_bucket_2026-01-30-23\n      const match = key.match(/trades_bucket_(\\d{4})-(\\d{2})-(\\d{2})-(\\d{2})/);\n      if (!match) return false;\n      const bucketDate = new Date(Date.UTC(\n        parseInt(match[1]),\n        parseInt(match[2]) - 1,\n        parseInt(match[3]),\n        parseInt(match[4])\n      ));\n      return bucketDate.getTime() > cutoffTime;\n    });\n    \n    await env.SIGNALS_CACHE.put(TRADES_KV_KEYS.TRADE_INDEX, JSON.stringify(activeIndex), {\n      expirationTtl: 72 * 60 * 60\n    });\n    \n    // Update last poll timestamp (use newest trade time)\n    const newestTradeTime = Math.max(...newTrades.map(t => t.timestamp * 1000));\n    await env.SIGNALS_CACHE.put(TRADES_KV_KEYS.LAST_POLL, String(newestTradeTime));\n    \n    // Store poll stats\n    const stats = {\n      lastPoll: new Date().toISOString(),\n      tradesStored: newTrades.length,\n      bucketsUpdated: bucketKeys.length,\n      totalBuckets: activeIndex.length,\n      pollDuration: Date.now() - startTime\n    };\n    await env.SIGNALS_CACHE.put(TRADES_KV_KEYS.POLL_STATS, JSON.stringify(stats));\n    \n    return {\n      success: true,\n      newTrades: newTrades.length,\n      bucketsUpdated: bucketKeys.length,\n      totalBuckets: activeIndex.length,\n      duration: Date.now() - startTime\n    };\n    \n  } catch (e) {\n    console.error('Poll error:', e);\n    return {\n      success: false,\n      error: e.message\n    };\n  }\n}\n\n// Get accumulated trades for a time window\nexport async function getAccumulatedTrades(env, hoursBack = 48) {\n  if (!env.SIGNALS_CACHE) {\n    return { trades: [], fromKV: false };\n  }\n  \n  try {\n    // Get bucket index\n    const index = await env.SIGNALS_CACHE.get(TRADES_KV_KEYS.TRADE_INDEX, { type: 'json' }) || [];\n    \n    if (index.length === 0) {\n      return { trades: [], fromKV: false, reason: 'No accumulated trades yet' };\n    }\n    \n    // Calculate cutoff time\n    const cutoffTime = Date.now() - (hoursBack * 60 * 60 * 1000);\n    \n    // Fetch all relevant buckets\n    const allTrades = [];\n    let bucketsRead = 0;\n    \n    for (const bucketKey of index) {\n      // Extract date from key to check if within window\n      const match = bucketKey.match(/trades_bucket_(\\d{4})-(\\d{2})-(\\d{2})-(\\d{2})/);\n      if (!match) continue;\n      \n      const bucketDate = new Date(Date.UTC(\n        parseInt(match[1]),\n        parseInt(match[2]) - 1,\n        parseInt(match[3]),\n        parseInt(match[4])\n      ));\n      \n      // Skip buckets outside our window\n      if (bucketDate.getTime() < cutoffTime - (60 * 60 * 1000)) continue; // 1hr buffer\n      \n      const bucketTrades = await env.SIGNALS_CACHE.get(bucketKey, { type: 'json' });\n      if (bucketTrades && Array.isArray(bucketTrades)) {\n        // Filter trades within time window\n        const validTrades = bucketTrades.filter(t => (t.ts * 1000) >= cutoffTime);\n        allTrades.push(...validTrades);\n        bucketsRead++;\n      }\n    }\n    \n    // Convert back to API format\n    const formattedTrades = allTrades.map(t => ({\n      timestamp: t.ts,\n      slug: t.slug,\n      eventSlug: t.eventSlug,\n      title: t.title,\n      outcome: t.outcome,\n      side: t.side,\n      price: t.price,\n      size: t.size,\n      proxyWallet: t.proxyWallet,\n      icon: t.icon\n    }));\n    \n    // Sort by timestamp descending (newest first)\n    formattedTrades.sort((a, b) => b.timestamp - a.timestamp);\n    \n    return {\n      trades: formattedTrades,\n      fromKV: true,\n      bucketsRead,\n      totalTrades: formattedTrades.length\n    };\n    \n  } catch (e) {\n    console.error('Error getting accumulated trades:', e);\n    return { trades: [], fromKV: false, error: e.message };\n  }\n}\n\n// Get poll stats\nexport async function getPollStats(env) {\n  if (!env.SIGNALS_CACHE) {\n    return null;\n  }\n  \n  try {\n    const stats = await env.SIGNALS_CACHE.get(TRADES_KV_KEYS.POLL_STATS, { type: 'json' });\n    const lastPoll = await env.SIGNALS_CACHE.get(TRADES_KV_KEYS.LAST_POLL);\n    const index = await env.SIGNALS_CACHE.get(TRADES_KV_KEYS.TRADE_INDEX, { type: 'json' }) || [];\n    \n    return {\n      ...stats,\n      lastPollTimestamp: lastPoll ? parseInt(lastPoll) : null,\n      activeBuckets: index.length,\n      bucketKeys: index.slice(-10) // Last 10 bucket keys for debugging\n    };\n  } catch (e) {\n    return { error: e.message };\n  }\n}\n\n// Clear all accumulated trades (for testing/reset)\nexport async function clearAccumulatedTrades(env) {\n  if (!env.SIGNALS_CACHE) {\n    return { success: false, error: 'No KV storage' };\n  }\n  \n  try {\n    const index = await env.SIGNALS_CACHE.get(TRADES_KV_KEYS.TRADE_INDEX, { type: 'json' }) || [];\n    \n    // Delete all buckets\n    for (const key of index) {\n      await env.SIGNALS_CACHE.delete(key);\n    }\n    \n    // Clear index and stats\n    await env.SIGNALS_CACHE.delete(TRADES_KV_KEYS.TRADE_INDEX);\n    await env.SIGNALS_CACHE.delete(TRADES_KV_KEYS.LAST_POLL);\n    await env.SIGNALS_CACHE.delete(TRADES_KV_KEYS.POLL_STATS);\n    \n    return {\n      success: true,\n      bucketsDeleted: index.length\n    };\n  } catch (e) {\n    return { success: false, error: e.message };\n  }\n}\n", "// ============================================================\n// BETTING-SPLITS.JS - VSiN/DraftKings Public Betting Data\n// v1.1.0 - FIXED: Proper HTML scraping for VSiN betting splits\n// ============================================================\n\n// VSiN provides DraftKings betting splits data\n// Data updates every 5 minutes and shows:\n// - % of Bets (ticket count - mostly public/recreational)\n// - % Handle (money wagered - includes sharp/whale action)\n\nconst VSIN_BASE = 'https://www.vsin.com';\n\n// Cache duration\nconst CACHE_DURATION = {\n  SPLITS: 5 * 60, // 5 minutes (matches VSiN update frequency)\n};\n\n// Sport URL paths on VSiN\nconst SPORT_PATHS = {\n  nba: '/betting-splits/nba/',\n  nfl: '/betting-splits/nfl/',\n  ncaab: '/betting-splits/ncaab/',\n  cbb: '/betting-splits/ncaab/',\n  ncaaf: '/betting-splits/ncaaf/',\n  cfb: '/betting-splits/ncaaf/',\n  nhl: '/betting-splits/nhl/',\n  mlb: '/betting-splits/mlb/',\n};\n\n// ============================================================\n// MAIN: Fetch Betting Splits\n// ============================================================\n\nexport async function getBettingSplits(env, sport) {\n  const normalizedSport = sport.toLowerCase();\n  const sportPath = SPORT_PATHS[normalizedSport];\n  \n  if (!sportPath) {\n    return { \n      success: false, \n      error: `Sport '${sport}' not supported`,\n      supportedSports: Object.keys(SPORT_PATHS)\n    };\n  }\n  \n  // Check cache first\n  const cacheKey = `betting_splits_${normalizedSport}`;\n  if (env.SIGNALS_CACHE) {\n    try {\n      const cached = await env.SIGNALS_CACHE.get(cacheKey, { type: 'json' });\n      if (cached && cached.data) {\n        const age = Date.now() - cached.timestamp;\n        if (age < CACHE_DURATION.SPLITS * 1000) {\n          console.log(`Betting splits cache HIT for ${sport} (age: ${Math.round(age/1000)}s)`);\n          return { ...cached.data, fromCache: true, cacheAge: Math.round(age/1000) };\n        }\n      }\n    } catch (e) {\n      console.error('Cache read error:', e.message);\n    }\n  }\n  \n  try {\n    // Scrape VSiN HTML page\n    const splits = await scrapeVSiNPage(normalizedSport, sportPath);\n    \n    const result = {\n      success: true,\n      sport: normalizedSport,\n      source: 'vsin-draftkings',\n      timestamp: new Date().toISOString(),\n      gamesCount: splits?.length || 0,\n      games: splits || [],\n      updateFrequency: '5 minutes'\n    };\n    \n    // Cache result if we got data\n    if (env.SIGNALS_CACHE && splits && splits.length > 0) {\n      try {\n        await env.SIGNALS_CACHE.put(cacheKey, JSON.stringify({\n          data: result,\n          timestamp: Date.now()\n        }), { expirationTtl: CACHE_DURATION.SPLITS + 60 });\n      } catch (e) {\n        console.error('Cache write error:', e.message);\n      }\n    }\n    \n    return result;\n    \n  } catch (e) {\n    console.error('Betting splits fetch error:', e);\n    return { \n      success: false, \n      error: e.message,\n      sport: normalizedSport\n    };\n  }\n}\n\n// ============================================================\n// VSiN HTML Scraper\n// ============================================================\n\nasync function scrapeVSiNPage(sport, sportPath) {\n  const url = `${VSIN_BASE}${sportPath}`;\n  \n  console.log(`Scraping VSiN: ${url}`);\n  \n  const response = await fetch(url, {\n    headers: {\n      'Accept': 'text/html,application/xhtml+xml',\n      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n      'Accept-Language': 'en-US,en;q=0.9',\n    }\n  });\n  \n  if (!response.ok) {\n    console.log(`VSiN returned ${response.status}`);\n    return [];\n  }\n  \n  const html = await response.text();\n  \n  // Parse the HTML to extract betting splits data\n  return parseVSiNHTML(html, sport);\n}\n\n// ============================================================\n// HTML Parser - Extract betting splits from VSiN page\n// ============================================================\n\nfunction parseVSiNHTML(html, sport) {\n  const games = [];\n  \n  try {\n    // VSiN uses a table structure for betting splits\n    // Look for game rows with betting percentages\n    \n    // Pattern 1: Look for data in JSON embedded in script tags\n    const jsonMatch = html.match(/window\\.__INITIAL_STATE__\\s*=\\s*({[\\s\\S]*?});/);\n    if (jsonMatch) {\n      try {\n        const data = JSON.parse(jsonMatch[1]);\n        if (data.bettingSplits || data.games) {\n          return parseVSiNJSON(data, sport);\n        }\n      } catch (e) {\n        console.log('Failed to parse embedded JSON:', e.message);\n      }\n    }\n    \n    // Pattern 2: Look for Next.js data\n    const nextDataMatch = html.match(/<script id=\"__NEXT_DATA__\"[^>]*>([\\s\\S]*?)<\\/script>/);\n    if (nextDataMatch) {\n      try {\n        const nextData = JSON.parse(nextDataMatch[1]);\n        if (nextData.props?.pageProps?.games || nextData.props?.pageProps?.bettingSplits) {\n          return parseNextJSData(nextData.props.pageProps, sport);\n        }\n      } catch (e) {\n        console.log('Failed to parse Next.js data:', e.message);\n      }\n    }\n    \n    // Pattern 3: Parse HTML table structure\n    // Look for betting-splits-table or similar\n    const tableGames = parseHTMLTable(html, sport);\n    if (tableGames.length > 0) {\n      return tableGames;\n    }\n    \n    // Pattern 4: Look for game cards/rows with regex\n    const cardGames = parseGameCards(html, sport);\n    if (cardGames.length > 0) {\n      return cardGames;\n    }\n    \n    console.log('No betting splits data found in HTML');\n    return [];\n    \n  } catch (e) {\n    console.error('HTML parse error:', e.message);\n    return [];\n  }\n}\n\n// Parse VSiN JSON structure\nfunction parseVSiNJSON(data, sport) {\n  const games = [];\n  const gamesData = data.bettingSplits?.games || data.games || [];\n  \n  for (const game of gamesData) {\n    games.push({\n      gameId: game.id || game.gameId || `${game.awayTeam}-${game.homeTeam}`,\n      homeTeam: game.homeTeam || game.home?.name,\n      awayTeam: game.awayTeam || game.away?.name,\n      gameTime: game.gameTime || game.startTime,\n      spread: {\n        home: {\n          line: game.spread?.home?.line || game.homeSpread,\n          betsPercent: game.spread?.home?.betsPercent || game.homeSpreadBets,\n          handlePercent: game.spread?.home?.handlePercent || game.homeSpreadHandle\n        },\n        away: {\n          line: game.spread?.away?.line || game.awaySpread,\n          betsPercent: game.spread?.away?.betsPercent || game.awaySpreadBets,\n          handlePercent: game.spread?.away?.handlePercent || game.awaySpreadHandle\n        }\n      },\n      moneyline: {\n        home: {\n          betsPercent: game.moneyline?.home?.betsPercent || game.homeMLBets,\n          handlePercent: game.moneyline?.home?.handlePercent || game.homeMLHandle\n        },\n        away: {\n          betsPercent: game.moneyline?.away?.betsPercent || game.awayMLBets,\n          handlePercent: game.moneyline?.away?.handlePercent || game.awayMLHandle\n        }\n      },\n      total: {\n        line: game.total?.line || game.totalLine,\n        over: {\n          betsPercent: game.total?.over?.betsPercent || game.overBets,\n          handlePercent: game.total?.over?.handlePercent || game.overHandle\n        },\n        under: {\n          betsPercent: game.total?.under?.betsPercent || game.underBets,\n          handlePercent: game.total?.under?.handlePercent || game.underHandle\n        }\n      }\n    });\n  }\n  \n  return games;\n}\n\n// Parse Next.js data structure\nfunction parseNextJSData(pageProps, sport) {\n  const games = [];\n  const gamesData = pageProps.games || pageProps.bettingSplits || [];\n  \n  for (const game of gamesData) {\n    games.push({\n      gameId: game.id || `${game.away_team}-${game.home_team}`,\n      homeTeam: game.home_team || game.homeTeam,\n      awayTeam: game.away_team || game.awayTeam,\n      gameTime: game.game_time || game.gameTime,\n      spread: {\n        home: {\n          line: game.home_spread_line,\n          betsPercent: game.home_spread_bets_pct,\n          handlePercent: game.home_spread_handle_pct\n        },\n        away: {\n          line: game.away_spread_line,\n          betsPercent: game.away_spread_bets_pct,\n          handlePercent: game.away_spread_handle_pct\n        }\n      },\n      moneyline: {\n        home: {\n          betsPercent: game.home_ml_bets_pct,\n          handlePercent: game.home_ml_handle_pct\n        },\n        away: {\n          betsPercent: game.away_ml_bets_pct,\n          handlePercent: game.away_ml_handle_pct\n        }\n      },\n      total: {\n        line: game.total_line,\n        over: {\n          betsPercent: game.over_bets_pct,\n          handlePercent: game.over_handle_pct\n        },\n        under: {\n          betsPercent: game.under_bets_pct,\n          handlePercent: game.under_handle_pct\n        }\n      }\n    });\n  }\n  \n  return games;\n}\n\n// Parse HTML table structure\nfunction parseHTMLTable(html, sport) {\n  const games = [];\n  \n  // Look for table rows with team names and percentages\n  // VSiN typically has: Team | Spread | Bets% | Handle% | ML | Bets% | Handle%\n  \n  // Match game blocks - look for patterns like \"Lakers vs Celtics\" or team names with percentages\n  const gameBlockRegex = /<tr[^>]*class=\"[^\"]*game[^\"]*\"[^>]*>([\\s\\S]*?)<\\/tr>/gi;\n  const blocks = html.match(gameBlockRegex) || [];\n  \n  for (const block of blocks) {\n    const game = parseGameBlock(block);\n    if (game) {\n      games.push(game);\n    }\n  }\n  \n  return games;\n}\n\n// Parse individual game card/row from HTML\nfunction parseGameCards(html, sport) {\n  const games = [];\n  \n  // Look for percentage patterns near team names\n  // Pattern: TeamName followed by numbers like \"45%\" or \"55%\"\n  const percentPattern = /(\\d{1,3})%/g;\n  \n  // Find sections that look like game data\n  // This is a fallback pattern matcher\n  const teamPatterns = {\n    nba: /(Lakers|Celtics|Warriors|Heat|Nets|Knicks|Bulls|Suns|Mavericks|Bucks|76ers|Clippers|Nuggets|Grizzlies|Cavaliers|Hawks|Hornets|Pacers|Magic|Pistons|Raptors|Wizards|Rockets|Spurs|Thunder|Timberwolves|Pelicans|Kings|Blazers|Jazz)/gi,\n    nfl: /(Chiefs|Bills|Eagles|49ers|Cowboys|Dolphins|Lions|Ravens|Bengals|Jaguars|Chargers|Jets|Patriots|Broncos|Raiders|Steelers|Browns|Colts|Titans|Texans|Vikings|Packers|Bears|Saints|Buccaneers|Falcons|Panthers|Commanders|Giants|Cardinals|Rams|Seahawks)/gi,\n    nhl: /(Bruins|Panthers|Hurricanes|Devils|Rangers|Maple Leafs|Lightning|Islanders|Capitals|Penguins|Senators|Red Wings|Sabres|Flyers|Blue Jackets|Oilers|Stars|Jets|Avalanche|Wild|Blues|Predators|Knights|Kings|Flames|Canucks|Kraken|Sharks|Coyotes|Ducks|Blackhawks)/gi,\n  };\n  \n  // For now, return empty if we can't find structured data\n  // The HTML parsing would need to be customized based on VSiN's actual HTML structure\n  return games;\n}\n\n// Parse a single game block\nfunction parseGameBlock(blockHtml) {\n  // Extract team names\n  const teamMatch = blockHtml.match(/>([A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*)</g);\n  if (!teamMatch || teamMatch.length < 2) return null;\n  \n  // Extract percentages\n  const percentages = [];\n  const percentMatch = blockHtml.match(/(\\d{1,3})%/g);\n  if (percentMatch) {\n    for (const p of percentMatch) {\n      percentages.push(parseInt(p));\n    }\n  }\n  \n  // Need at least 4 percentages (spread bets/handle for each team)\n  if (percentages.length < 4) return null;\n  \n  const teams = teamMatch.map(t => t.replace(/[><]/g, '').trim());\n  \n  return {\n    gameId: `${teams[0]}-${teams[1]}`,\n    awayTeam: teams[0],\n    homeTeam: teams[1],\n    spread: {\n      away: {\n        betsPercent: percentages[0],\n        handlePercent: percentages[1]\n      },\n      home: {\n        betsPercent: percentages[2] || (100 - percentages[0]),\n        handlePercent: percentages[3] || (100 - percentages[1])\n      }\n    }\n  };\n}\n\n// ============================================================\n// SHARP MONEY ANALYSIS\n// ============================================================\n\n/**\n * Analyze games for sharp money indicators\n * Sharp money = when handle% diverges significantly from bets%\n */\nexport function analyzeSharpMoney(games) {\n  const sharpGames = [];\n  \n  for (const game of games) {\n    const sharpSignals = [];\n    \n    // Check spread\n    if (game.spread) {\n      const homeSpreadDiff = (game.spread.home?.handlePercent || 0) - (game.spread.home?.betsPercent || 0);\n      const awaySpreadDiff = (game.spread.away?.handlePercent || 0) - (game.spread.away?.betsPercent || 0);\n      \n      // 15%+ divergence = sharp money signal\n      if (Math.abs(homeSpreadDiff) >= 15) {\n        sharpSignals.push({\n          market: 'spread',\n          side: homeSpreadDiff > 0 ? 'home' : 'away',\n          team: homeSpreadDiff > 0 ? game.homeTeam : game.awayTeam,\n          divergence: Math.abs(homeSpreadDiff),\n          betsPercent: homeSpreadDiff > 0 ? game.spread.home?.betsPercent : game.spread.away?.betsPercent,\n          handlePercent: homeSpreadDiff > 0 ? game.spread.home?.handlePercent : game.spread.away?.handlePercent,\n          strength: Math.abs(homeSpreadDiff) >= 25 ? 'strong' : 'moderate'\n        });\n      }\n    }\n    \n    // Check moneyline\n    if (game.moneyline) {\n      const homeMLDiff = (game.moneyline.home?.handlePercent || 0) - (game.moneyline.home?.betsPercent || 0);\n      \n      if (Math.abs(homeMLDiff) >= 15) {\n        sharpSignals.push({\n          market: 'moneyline',\n          side: homeMLDiff > 0 ? 'home' : 'away',\n          team: homeMLDiff > 0 ? game.homeTeam : game.awayTeam,\n          divergence: Math.abs(homeMLDiff),\n          betsPercent: homeMLDiff > 0 ? game.moneyline.home?.betsPercent : game.moneyline.away?.betsPercent,\n          handlePercent: homeMLDiff > 0 ? game.moneyline.home?.handlePercent : game.moneyline.away?.handlePercent,\n          strength: Math.abs(homeMLDiff) >= 25 ? 'strong' : 'moderate'\n        });\n      }\n    }\n    \n    // Check total\n    if (game.total) {\n      const overDiff = (game.total.over?.handlePercent || 0) - (game.total.over?.betsPercent || 0);\n      \n      if (Math.abs(overDiff) >= 15) {\n        sharpSignals.push({\n          market: 'total',\n          side: overDiff > 0 ? 'over' : 'under',\n          divergence: Math.abs(overDiff),\n          line: game.total.line,\n          betsPercent: overDiff > 0 ? game.total.over?.betsPercent : game.total.under?.betsPercent,\n          handlePercent: overDiff > 0 ? game.total.over?.handlePercent : game.total.under?.handlePercent,\n          strength: Math.abs(overDiff) >= 25 ? 'strong' : 'moderate'\n        });\n      }\n    }\n    \n    if (sharpSignals.length > 0) {\n      sharpGames.push({\n        gameId: game.gameId,\n        homeTeam: game.homeTeam,\n        awayTeam: game.awayTeam,\n        gameTime: game.gameTime,\n        sharpSignals,\n        strongestSignal: sharpSignals.reduce((a, b) => a.divergence > b.divergence ? a : b)\n      });\n    }\n  }\n  \n  // Sort by strongest divergence\n  sharpGames.sort((a, b) => b.strongestSignal.divergence - a.strongestSignal.divergence);\n  \n  return sharpGames;\n}\n\n// ============================================================\n// REVERSE LINE MOVEMENT DETECTION\n// ============================================================\n\n/**\n * Detect reverse line movement\n * RLM = line moves opposite to public betting direction\n * Requires current line and opening line comparison\n */\nexport function detectReverseLineMovement(games, lineHistory = {}) {\n  const rlmGames = [];\n  \n  for (const game of games) {\n    const gameHistory = lineHistory[game.gameId];\n    if (!gameHistory) continue;\n    \n    const openingSpread = gameHistory.openingSpread;\n    const currentSpread = game.spread?.home?.line;\n    \n    if (openingSpread === undefined || currentSpread === undefined) continue;\n    \n    const lineMove = currentSpread - openingSpread;\n    const publicSide = (game.spread?.home?.betsPercent || 0) > 50 ? 'home' : 'away';\n    const publicPercent = Math.max(game.spread?.home?.betsPercent || 0, game.spread?.away?.betsPercent || 0);\n    \n    // RLM: Line moves toward the less popular side\n    // If public is on home (>60%) but line moves toward away (home spread increases)\n    const isRLM = (publicSide === 'home' && lineMove > 0) || (publicSide === 'away' && lineMove < 0);\n    \n    if (isRLM && publicPercent >= 60 && Math.abs(lineMove) >= 0.5) {\n      rlmGames.push({\n        gameId: game.gameId,\n        homeTeam: game.homeTeam,\n        awayTeam: game.awayTeam,\n        openingSpread,\n        currentSpread,\n        lineMove,\n        publicSide,\n        publicPercent,\n        sharpSide: publicSide === 'home' ? 'away' : 'home',\n        strength: publicPercent >= 70 ? 'strong' : 'moderate'\n      });\n    }\n  }\n  \n  return rlmGames;\n}\n", "// ============================================================\n// SHARP-LINES.JS - Pinnacle/Sharp Book Line Comparison\n// v1.0.0 - Compare soft books vs sharp books for edge detection\n// ============================================================\n\n// The Odds API includes Pinnacle (sharpest book) and soft books (DK, FD, etc.)\n// Strategy: When soft books differ significantly from Pinnacle, there's potential edge\n\nimport { ODDS_API_BASE, SPORT_KEY_MAP } from './config.js';\n\nconst CACHE_DURATION = {\n  ODDS: 5 * 60,      // 5 minutes for odds comparison\n  HISTORY: 60 * 60,  // 1 hour for line history\n};\n\n// Sharp vs Soft book classification\nconst BOOK_TIERS = {\n  sharp: ['pinnacle', 'circa', 'bookmaker', 'betcris', 'betonline'],\n  soft: ['draftkings', 'fanduel', 'betmgm', 'caesars', 'pointsbet', 'wynnbet', 'espnbet', 'fanatics']\n};\n\n// ============================================================\n// MAIN: Get Sharp vs Soft Book Comparison\n// ============================================================\n\n/**\n * Fetch odds from multiple books and compare sharp vs soft lines\n * @param {Object} env - Environment with API keys\n * @param {string} sport - Sport code (nba, nfl, ncaab, etc.)\n * @returns {Object} - Games with sharp/soft line comparison\n */\nexport async function getSharpLineComparison(env, sport) {\n  const sportKey = SPORT_KEY_MAP[sport];\n  if (!sportKey) {\n    return { success: false, error: `Sport '${sport}' not supported` };\n  }\n  \n  if (!env.ODDS_API_KEY) {\n    return { success: false, error: 'ODDS_API_KEY not configured' };\n  }\n  \n  const cacheKey = `sharp_lines_${sport}`;\n  \n  // Check cache\n  if (env.SIGNALS_CACHE) {\n    try {\n      const cached = await env.SIGNALS_CACHE.get(cacheKey, { type: 'json' });\n      if (cached && cached.data) {\n        const age = Date.now() - cached.timestamp;\n        if (age < CACHE_DURATION.ODDS * 1000) {\n          return { ...cached.data, fromCache: true, cacheAge: Math.round(age/1000) };\n        }\n      }\n    } catch (e) {}\n  }\n  \n  try {\n    // Fetch odds from all US + Pinnacle bookmakers\n    const url = `${ODDS_API_BASE}/sports/${sportKey}/odds/?apiKey=${env.ODDS_API_KEY}&regions=us,eu&markets=h2h,spreads,totals&oddsFormat=american&bookmakers=pinnacle,draftkings,fanduel,betmgm,caesars,betonline`;\n    \n    const response = await fetch(url);\n    if (!response.ok) {\n      const errorText = await response.text();\n      return { success: false, error: `Odds API error: ${response.status}`, details: errorText };\n    }\n    \n    const games = await response.json();\n    \n    // Process each game\n    const processedGames = games.map(game => processGameForSharpLines(game));\n    \n    // Sort by edge potential\n    processedGames.sort((a, b) => (b.maxEdge || 0) - (a.maxEdge || 0));\n    \n    const result = {\n      success: true,\n      sport,\n      sportKey,\n      timestamp: new Date().toISOString(),\n      gamesCount: processedGames.length,\n      gamesWithEdge: processedGames.filter(g => g.maxEdge >= 2).length,\n      games: processedGames\n    };\n    \n    // Cache result\n    if (env.SIGNALS_CACHE) {\n      try {\n        await env.SIGNALS_CACHE.put(cacheKey, JSON.stringify({\n          data: result,\n          timestamp: Date.now()\n        }), { expirationTtl: CACHE_DURATION.ODDS + 60 });\n      } catch (e) {}\n    }\n    \n    return result;\n    \n  } catch (e) {\n    console.error('Sharp lines fetch error:', e);\n    return { success: false, error: e.message };\n  }\n}\n\n/**\n * Process a single game for sharp/soft line comparison\n */\nfunction processGameForSharpLines(game) {\n  const result = {\n    id: game.id,\n    homeTeam: game.home_team,\n    awayTeam: game.away_team,\n    commenceTime: game.commence_time,\n    pinnacle: null,\n    consensus: null,\n    edges: [],\n    maxEdge: 0\n  };\n  \n  if (!game.bookmakers || game.bookmakers.length === 0) {\n    return result;\n  }\n  \n  // Find Pinnacle (sharp baseline)\n  const pinnacle = game.bookmakers.find(b => b.key === 'pinnacle');\n  \n  // Get soft books\n  const softBooks = game.bookmakers.filter(b => \n    BOOK_TIERS.soft.includes(b.key)\n  );\n  \n  if (!pinnacle && softBooks.length === 0) {\n    return result;\n  }\n  \n  // Process each market (h2h, spreads, totals)\n  const markets = ['h2h', 'spreads', 'totals'];\n  \n  for (const marketKey of markets) {\n    const pinnacleMarket = pinnacle?.markets?.find(m => m.key === marketKey);\n    \n    for (const softBook of softBooks) {\n      const softMarket = softBook.markets?.find(m => m.key === marketKey);\n      \n      if (!softMarket) continue;\n      \n      // Compare each outcome\n      for (const softOutcome of softMarket.outcomes) {\n        const pinnacleOutcome = pinnacleMarket?.outcomes?.find(o => o.name === softOutcome.name);\n        \n        // Calculate edge vs Pinnacle if available\n        if (pinnacleOutcome) {\n          const edge = calculateEdge(softOutcome.price, pinnacleOutcome.price);\n          \n          if (Math.abs(edge) >= 2) {\n            const edgeInfo = {\n              market: marketKey,\n              book: softBook.key,\n              outcome: softOutcome.name,\n              softOdds: softOutcome.price,\n              pinnacleOdds: pinnacleOutcome.price,\n              edge: edge,\n              betOn: edge > 0 ? 'soft' : 'pinnacle',\n              point: softOutcome.point || null,\n              pinnaclePoint: pinnacleOutcome.point || null\n            };\n            \n            result.edges.push(edgeInfo);\n            result.maxEdge = Math.max(result.maxEdge, Math.abs(edge));\n          }\n        }\n      }\n    }\n    \n    // Store Pinnacle as baseline\n    if (pinnacleMarket) {\n      result.pinnacle = result.pinnacle || {};\n      result.pinnacle[marketKey] = {\n        outcomes: pinnacleMarket.outcomes.map(o => ({\n          name: o.name,\n          price: o.price,\n          point: o.point,\n          impliedProb: americanToProb(o.price)\n        }))\n      };\n    }\n  }\n  \n  // Calculate consensus line from soft books\n  result.consensus = calculateConsensus(game.bookmakers, softBooks);\n  \n  return result;\n}\n\n/**\n * Calculate edge between two odds\n * Positive = soft book offers better odds than Pinnacle\n * Negative = Pinnacle offers better odds\n */\nfunction calculateEdge(softOdds, pinnacleOdds) {\n  const softProb = americanToProb(softOdds);\n  const pinnacleProb = americanToProb(pinnacleOdds);\n  \n  // Edge = (Pinnacle implied prob) - (Soft book implied prob)\n  // Positive edge means soft book is giving you better odds than the \"true\" line\n  return Math.round((pinnacleProb - softProb) * 100 * 10) / 10;\n}\n\n/**\n * Convert American odds to implied probability\n */\nfunction americanToProb(odds) {\n  if (odds >= 100) {\n    return 100 / (odds + 100);\n  } else {\n    return Math.abs(odds) / (Math.abs(odds) + 100);\n  }\n}\n\n/**\n * Calculate consensus line from soft books\n */\nfunction calculateConsensus(allBooks, softBooks) {\n  const consensus = {};\n  const markets = ['h2h', 'spreads', 'totals'];\n  \n  for (const marketKey of markets) {\n    const outcomeOdds = {};\n    \n    for (const book of softBooks) {\n      const market = book.markets?.find(m => m.key === marketKey);\n      if (!market) continue;\n      \n      for (const outcome of market.outcomes) {\n        if (!outcomeOdds[outcome.name]) {\n          outcomeOdds[outcome.name] = [];\n        }\n        outcomeOdds[outcome.name].push({\n          odds: outcome.price,\n          point: outcome.point,\n          book: book.key\n        });\n      }\n    }\n    \n    // Calculate average odds for each outcome\n    consensus[marketKey] = {};\n    for (const [name, oddsArray] of Object.entries(outcomeOdds)) {\n      const avgOdds = Math.round(oddsArray.reduce((sum, o) => sum + o.odds, 0) / oddsArray.length);\n      const avgPoint = oddsArray[0]?.point !== undefined \n        ? Math.round(oddsArray.reduce((sum, o) => sum + (o.point || 0), 0) / oddsArray.length * 10) / 10\n        : null;\n      \n      consensus[marketKey][name] = {\n        avgOdds,\n        avgPoint,\n        impliedProb: Math.round(americanToProb(avgOdds) * 100),\n        books: oddsArray.length\n      };\n    }\n  }\n  \n  return consensus;\n}\n\n// ============================================================\n// LINE MOVEMENT TRACKING\n// ============================================================\n\n/**\n * Track and store line movement over time\n * @param {Object} env - Environment with KV\n * @param {string} gameId - Unique game identifier\n * @param {Object} currentOdds - Current odds data\n */\nexport async function trackLineMovement(env, gameId, currentOdds) {\n  if (!env.SIGNALS_CACHE) return null;\n  \n  const key = `line_movement_${gameId}`;\n  \n  try {\n    // Get existing history\n    const existing = await env.SIGNALS_CACHE.get(key, { type: 'json' }) || { history: [] };\n    \n    // Add current snapshot\n    existing.history.push({\n      timestamp: new Date().toISOString(),\n      odds: currentOdds\n    });\n    \n    // Keep only last 24 hours\n    const cutoff = Date.now() - 24 * 60 * 60 * 1000;\n    existing.history = existing.history.filter(h => \n      new Date(h.timestamp).getTime() > cutoff\n    );\n    \n    // Store updated history\n    await env.SIGNALS_CACHE.put(key, JSON.stringify(existing), {\n      expirationTtl: 24 * 60 * 60 + 3600 // 25 hours\n    });\n    \n    return existing;\n    \n  } catch (e) {\n    console.error('Line tracking error:', e.message);\n    return null;\n  }\n}\n\n/**\n * Get line movement history for a game\n */\nexport async function getLineMovement(env, gameId) {\n  if (!env.SIGNALS_CACHE) return null;\n  \n  const key = `line_movement_${gameId}`;\n  \n  try {\n    const data = await env.SIGNALS_CACHE.get(key, { type: 'json' });\n    if (!data || !data.history || data.history.length < 2) {\n      return null;\n    }\n    \n    // Calculate movement\n    const first = data.history[0];\n    const last = data.history[data.history.length - 1];\n    \n    return {\n      gameId,\n      snapshots: data.history.length,\n      firstSeen: first.timestamp,\n      lastUpdate: last.timestamp,\n      opening: first.odds,\n      current: last.odds,\n      movement: calculateMovement(first.odds, last.odds),\n      history: data.history\n    };\n    \n  } catch (e) {\n    console.error('Get line movement error:', e.message);\n    return null;\n  }\n}\n\n/**\n * Calculate how much the line has moved\n */\nfunction calculateMovement(opening, current) {\n  const movement = {\n    spread: null,\n    total: null,\n    moneyline: null\n  };\n  \n  // Compare spread\n  if (opening?.spread?.home?.point && current?.spread?.home?.point) {\n    movement.spread = {\n      homeOpen: opening.spread.home.point,\n      homeCurrent: current.spread.home.point,\n      change: current.spread.home.point - opening.spread.home.point,\n      direction: current.spread.home.point > opening.spread.home.point ? 'away' : 'home'\n    };\n  }\n  \n  // Compare total\n  if (opening?.total?.over?.point && current?.total?.over?.point) {\n    movement.total = {\n      open: opening.total.over.point,\n      current: current.total.over.point,\n      change: current.total.over.point - opening.total.over.point,\n      direction: current.total.over.point > opening.total.over.point ? 'up' : 'down'\n    };\n  }\n  \n  // Compare moneyline\n  if (opening?.moneyline?.home?.price && current?.moneyline?.home?.price) {\n    const openProb = americanToProb(opening.moneyline.home.price);\n    const currentProb = americanToProb(current.moneyline.home.price);\n    \n    movement.moneyline = {\n      homeOpen: opening.moneyline.home.price,\n      homeCurrent: current.moneyline.home.price,\n      probChange: Math.round((currentProb - openProb) * 100),\n      direction: currentProb > openProb ? 'home' : 'away'\n    };\n  }\n  \n  return movement;\n}\n\n// ============================================================\n// STEAM MOVE DETECTION\n// ============================================================\n\n/**\n * Detect steam moves (sudden coordinated sharp action)\n * Steam = multiple books move the same direction within minutes\n * @param {Object} lineHistory - Line movement history\n */\nexport function detectSteamMove(lineHistory) {\n  if (!lineHistory || !lineHistory.history || lineHistory.history.length < 3) {\n    return null;\n  }\n  \n  const steamMoves = [];\n  \n  // Look for rapid movement in short time windows (5-15 minutes)\n  for (let i = 1; i < lineHistory.history.length; i++) {\n    const prev = lineHistory.history[i - 1];\n    const curr = lineHistory.history[i];\n    \n    const timeDiff = new Date(curr.timestamp).getTime() - new Date(prev.timestamp).getTime();\n    const minutesDiff = timeDiff / 60000;\n    \n    // Look for moves within 15-minute window\n    if (minutesDiff <= 15) {\n      const movement = calculateMovement(prev.odds, curr.odds);\n      \n      // Check for significant spread movement (0.5+ points)\n      if (movement.spread && Math.abs(movement.spread.change) >= 0.5) {\n        steamMoves.push({\n          type: 'spread',\n          timestamp: curr.timestamp,\n          minutesElapsed: Math.round(minutesDiff),\n          change: movement.spread.change,\n          direction: movement.spread.direction,\n          isSteam: minutesDiff <= 5 && Math.abs(movement.spread.change) >= 1\n        });\n      }\n      \n      // Check for significant total movement (1+ points)\n      if (movement.total && Math.abs(movement.total.change) >= 1) {\n        steamMoves.push({\n          type: 'total',\n          timestamp: curr.timestamp,\n          minutesElapsed: Math.round(minutesDiff),\n          change: movement.total.change,\n          direction: movement.total.direction,\n          isSteam: minutesDiff <= 5 && Math.abs(movement.total.change) >= 1.5\n        });\n      }\n      \n      // Check for significant ML movement (3%+ implied prob)\n      if (movement.moneyline && Math.abs(movement.moneyline.probChange) >= 3) {\n        steamMoves.push({\n          type: 'moneyline',\n          timestamp: curr.timestamp,\n          minutesElapsed: Math.round(minutesDiff),\n          probChange: movement.moneyline.probChange,\n          direction: movement.moneyline.direction,\n          isSteam: minutesDiff <= 5 && Math.abs(movement.moneyline.probChange) >= 5\n        });\n      }\n    }\n  }\n  \n  const steamCount = steamMoves.filter(m => m.isSteam).length;\n  \n  return {\n    detected: steamCount > 0,\n    steamMoves: steamMoves.filter(m => m.isSteam),\n    allMoves: steamMoves,\n    steamCount,\n    totalMoves: steamMoves.length\n  };\n}\n\n// ============================================================\n// CLOSING LINE VALUE (CLV) TRACKING\n// ============================================================\n\n/**\n * Compare entry odds to closing line to measure CLV\n * Beating the closing line is the best indicator of +EV betting\n * @param {number} entryOdds - American odds when bet was placed\n * @param {number} closingOdds - Final odds before game starts\n */\nexport function calculateCLV(entryOdds, closingOdds) {\n  const entryProb = americanToProb(entryOdds);\n  const closingProb = americanToProb(closingOdds);\n  \n  // CLV = closing probability - entry probability\n  // Positive CLV = you got better odds than the market closed at\n  const clv = Math.round((closingProb - entryProb) * 100 * 10) / 10;\n  \n  return {\n    entryOdds,\n    closingOdds,\n    entryProb: Math.round(entryProb * 100),\n    closingProb: Math.round(closingProb * 100),\n    clv,\n    beatClosing: clv > 0,\n    description: clv > 0 \n      ? `Beat closing line by ${clv}% (good +EV indicator)`\n      : `Missed closing line by ${Math.abs(clv)}%`\n  };\n}\n\n// ============================================================\n// EXPORTS\n// ============================================================\n\nexport default {\n  getSharpLineComparison,\n  trackLineMovement,\n  getLineMovement,\n  detectSteamMove,\n  calculateCLV,\n  americanToProb\n};\n", "// ============================================================\n// EDGE-DETECTOR.JS - Multi-Source Edge Detection Engine\n// v1.0.0 - Combines Polymarket, Betting Splits, Sharp Lines\n// ============================================================\n\n// This module combines multiple data sources to generate \"Edge Scores\"\n// for each game, identifying the best betting opportunities\n\nimport { getBettingSplits, analyzeSharpMoney, detectReverseLineMovement } from './betting-splits.js';\nimport { getSharpLineComparison, detectSteamMove, getLineMovement } from './sharp-lines.js';\nimport { getOddsComparison } from './odds-api.js';\n\n// Edge score weights\nconst EDGE_WEIGHTS = {\n  // Sharp money signals (from betting splits)\n  SHARP_MONEY_STRONG: 30,\n  SHARP_MONEY_MODERATE: 15,\n  \n  // Reverse line movement\n  RLM_STRONG: 25,\n  RLM_MODERATE: 12,\n  \n  // Pinnacle vs soft book divergence\n  PINNACLE_EDGE_LARGE: 20,  // 5%+ edge\n  PINNACLE_EDGE_MEDIUM: 10, // 3-5% edge\n  PINNACLE_EDGE_SMALL: 5,   // 2-3% edge\n  \n  // Steam moves\n  STEAM_MOVE: 35,\n  RAPID_LINE_MOVE: 15,\n  \n  // Polymarket divergence from Vegas\n  POLY_EDGE_HUGE: 25,       // 10%+ difference\n  POLY_EDGE_LARGE: 15,      // 5-10% difference\n  POLY_EDGE_MEDIUM: 8,      // 3-5% difference\n  \n  // Multiple signal confirmation\n  MULTI_SIGNAL_BONUS: 20,   // When 3+ signals agree\n  DUAL_SIGNAL_BONUS: 10,    // When 2 signals agree\n};\n\n// Confidence thresholds\nconst CONFIDENCE_LEVELS = {\n  HIGH: 70,      // Strong recommendation\n  MEDIUM: 50,    // Worth considering\n  LOW: 30,       // Monitor\n  NOISE: 0       // Below threshold\n};\n\n// ============================================================\n// MAIN: Run Full Edge Detection\n// ============================================================\n\n/**\n * Run comprehensive edge detection for a sport\n * Combines all data sources and generates edge scores\n */\nexport async function runEdgeDetection(env, sport) {\n  const startTime = Date.now();\n  \n  try {\n    console.log(`Starting edge detection for ${sport}...`);\n    \n    // Fetch all data sources in parallel\n    const [\n      vegasPolyComparison,\n      sharpLines,\n      bettingSplits\n    ] = await Promise.all([\n      getOddsComparison(env, sport).catch(e => ({ success: false, error: e.message })),\n      getSharpLineComparison(env, sport).catch(e => ({ success: false, error: e.message })),\n      getBettingSplits(env, sport).catch(e => ({ success: false, error: e.message }))\n    ]);\n    \n    console.log(`Data fetched: Vegas/Poly=${vegasPolyComparison.success}, Sharp=${sharpLines.success}, Splits=${bettingSplits.success}`);\n    \n    // Build unified game list\n    const games = buildUnifiedGameList(\n      vegasPolyComparison.games || [],\n      sharpLines.games || [],\n      bettingSplits.games || []\n    );\n    \n    // Analyze sharp money in betting splits\n    const sharpMoneyGames = bettingSplits.success \n      ? analyzeSharpMoney(bettingSplits.games || [])\n      : [];\n    \n    // Calculate edge scores for each game\n    const edgeGames = games.map(game => \n      calculateEdgeScore(game, sharpMoneyGames, sharpLines.games || [])\n    );\n    \n    // Sort by edge score (highest first)\n    edgeGames.sort((a, b) => b.edgeScore - a.edgeScore);\n    \n    // Extract top opportunities\n    const topEdges = edgeGames\n      .filter(g => g.edgeScore >= CONFIDENCE_LEVELS.MEDIUM)\n      .slice(0, 10);\n    \n    // Generate summary\n    const summary = generateSummary(edgeGames, topEdges);\n    \n    return {\n      success: true,\n      sport,\n      timestamp: new Date().toISOString(),\n      processingTime: Date.now() - startTime,\n      dataSources: {\n        vegasPolymarket: vegasPolyComparison.success,\n        sharpLines: sharpLines.success,\n        bettingSplits: bettingSplits.success\n      },\n      summary,\n      topEdges,\n      allGames: edgeGames.map(g => ({\n        ...g,\n        // Remove verbose nested data for cleaner response\n        sharpLinesDetail: undefined,\n        bettingSplitsDetail: undefined\n      }))\n    };\n    \n  } catch (e) {\n    console.error('Edge detection error:', e);\n    return { \n      success: false, \n      error: e.message,\n      processingTime: Date.now() - startTime\n    };\n  }\n}\n\n/**\n * Build unified game list from multiple sources\n */\nfunction buildUnifiedGameList(vegasGames, sharpGames, splitsGames) {\n  const gamesMap = new Map();\n  \n  // Add Vegas/Poly games as base\n  for (const game of vegasGames) {\n    const key = createGameKey(game.homeTeam, game.awayTeam);\n    gamesMap.set(key, {\n      ...game,\n      sources: ['vegas', 'polymarket']\n    });\n  }\n  \n  // Merge sharp lines data\n  for (const game of sharpGames) {\n    const key = createGameKey(game.homeTeam, game.awayTeam);\n    if (gamesMap.has(key)) {\n      const existing = gamesMap.get(key);\n      existing.sharpLinesDetail = game;\n      existing.sources.push('sharp');\n    } else {\n      gamesMap.set(key, {\n        homeTeam: game.homeTeam,\n        awayTeam: game.awayTeam,\n        commenceTime: game.commenceTime,\n        sharpLinesDetail: game,\n        sources: ['sharp']\n      });\n    }\n  }\n  \n  // Merge betting splits data\n  for (const game of splitsGames) {\n    const key = createGameKey(game.homeTeam, game.awayTeam);\n    if (gamesMap.has(key)) {\n      const existing = gamesMap.get(key);\n      existing.bettingSplitsDetail = game;\n      existing.sources.push('splits');\n    } else {\n      gamesMap.set(key, {\n        homeTeam: game.homeTeam,\n        awayTeam: game.awayTeam,\n        bettingSplitsDetail: game,\n        sources: ['splits']\n      });\n    }\n  }\n  \n  return Array.from(gamesMap.values());\n}\n\n/**\n * Create consistent game key for matching\n */\nfunction createGameKey(home, away) {\n  // Normalize team names for matching\n  const normalize = (name) => name?.toLowerCase()\n    .replace(/[^a-z0-9]/g, '')\n    .replace(/(university|college|state|tech)/g, '')\n    .trim() || '';\n  \n  return `${normalize(away)}-${normalize(home)}`;\n}\n\n/**\n * Calculate comprehensive edge score for a game\n */\nfunction calculateEdgeScore(game, sharpMoneyGames, sharpLinesGames) {\n  const signals = [];\n  let totalScore = 0;\n  let sharpSide = null;\n  let confidence = 'low';\n  \n  // 1. Check Polymarket vs Vegas edge\n  if (game.edge) {\n    const homeEdge = game.edge.home || 0;\n    const awayEdge = game.edge.away || 0;\n    const maxPolyEdge = Math.max(Math.abs(homeEdge), Math.abs(awayEdge));\n    \n    if (maxPolyEdge >= 10) {\n      totalScore += EDGE_WEIGHTS.POLY_EDGE_HUGE;\n      signals.push({\n        type: 'polymarket_divergence',\n        strength: 'huge',\n        edge: maxPolyEdge,\n        side: homeEdge > awayEdge ? game.homeTeam : game.awayTeam\n      });\n      sharpSide = sharpSide || (homeEdge > awayEdge ? 'home' : 'away');\n    } else if (maxPolyEdge >= 5) {\n      totalScore += EDGE_WEIGHTS.POLY_EDGE_LARGE;\n      signals.push({\n        type: 'polymarket_divergence',\n        strength: 'large',\n        edge: maxPolyEdge,\n        side: homeEdge > awayEdge ? game.homeTeam : game.awayTeam\n      });\n      sharpSide = sharpSide || (homeEdge > awayEdge ? 'home' : 'away');\n    } else if (maxPolyEdge >= 3) {\n      totalScore += EDGE_WEIGHTS.POLY_EDGE_MEDIUM;\n      signals.push({\n        type: 'polymarket_divergence',\n        strength: 'medium',\n        edge: maxPolyEdge\n      });\n    }\n  }\n  \n  // 2. Check sharp money signals (from betting splits)\n  const sharpGame = sharpMoneyGames.find(g => \n    createGameKey(g.homeTeam, g.awayTeam) === createGameKey(game.homeTeam, game.awayTeam)\n  );\n  \n  if (sharpGame && sharpGame.sharpSignals) {\n    for (const signal of sharpGame.sharpSignals) {\n      if (signal.isStrong) {\n        totalScore += EDGE_WEIGHTS.SHARP_MONEY_STRONG;\n        signals.push({\n          type: 'sharp_money',\n          strength: 'strong',\n          market: signal.type,\n          sharpSide: signal.sharpSide,\n          divergence: signal.sharpStrength\n        });\n        sharpSide = sharpSide || (signal.sharpSide === game.homeTeam ? 'home' : 'away');\n      } else {\n        totalScore += EDGE_WEIGHTS.SHARP_MONEY_MODERATE;\n        signals.push({\n          type: 'sharp_money',\n          strength: 'moderate',\n          market: signal.type,\n          sharpSide: signal.sharpSide,\n          divergence: signal.sharpStrength\n        });\n      }\n    }\n  }\n  \n  // 3. Check Pinnacle vs soft book edges\n  if (game.sharpLinesDetail && game.sharpLinesDetail.edges) {\n    const pinnacleEdges = game.sharpLinesDetail.edges;\n    const maxPinEdge = Math.max(...pinnacleEdges.map(e => Math.abs(e.edge)), 0);\n    \n    if (maxPinEdge >= 5) {\n      totalScore += EDGE_WEIGHTS.PINNACLE_EDGE_LARGE;\n      const bestEdge = pinnacleEdges.find(e => Math.abs(e.edge) === maxPinEdge);\n      signals.push({\n        type: 'pinnacle_divergence',\n        strength: 'large',\n        edge: maxPinEdge,\n        market: bestEdge?.market,\n        outcome: bestEdge?.outcome,\n        book: bestEdge?.book\n      });\n    } else if (maxPinEdge >= 3) {\n      totalScore += EDGE_WEIGHTS.PINNACLE_EDGE_MEDIUM;\n      signals.push({\n        type: 'pinnacle_divergence',\n        strength: 'medium',\n        edge: maxPinEdge\n      });\n    } else if (maxPinEdge >= 2) {\n      totalScore += EDGE_WEIGHTS.PINNACLE_EDGE_SMALL;\n      signals.push({\n        type: 'pinnacle_divergence',\n        strength: 'small',\n        edge: maxPinEdge\n      });\n    }\n  }\n  \n  // 4. Check for signal agreement (multiple sources pointing same direction)\n  const uniqueSignalTypes = new Set(signals.map(s => s.type));\n  if (uniqueSignalTypes.size >= 3) {\n    totalScore += EDGE_WEIGHTS.MULTI_SIGNAL_BONUS;\n    signals.push({\n      type: 'confirmation',\n      strength: 'triple',\n      description: '3+ independent signals agree'\n    });\n    confidence = 'high';\n  } else if (uniqueSignalTypes.size >= 2) {\n    totalScore += EDGE_WEIGHTS.DUAL_SIGNAL_BONUS;\n    signals.push({\n      type: 'confirmation',\n      strength: 'dual',\n      description: '2 independent signals agree'\n    });\n    confidence = 'medium';\n  }\n  \n  // Determine confidence level\n  if (totalScore >= CONFIDENCE_LEVELS.HIGH) {\n    confidence = 'high';\n  } else if (totalScore >= CONFIDENCE_LEVELS.MEDIUM) {\n    confidence = 'medium';\n  } else if (totalScore >= CONFIDENCE_LEVELS.LOW) {\n    confidence = 'low';\n  }\n  \n  // Generate recommendation\n  const recommendation = generateRecommendation(game, signals, sharpSide, confidence);\n  \n  return {\n    homeTeam: game.homeTeam,\n    awayTeam: game.awayTeam,\n    commenceTime: game.commenceTime,\n    edgeScore: Math.min(100, Math.round(totalScore)),\n    confidence,\n    signalCount: signals.length,\n    signals,\n    sharpSide,\n    recommendation,\n    vegas: game.vegas,\n    polymarket: game.polymarket,\n    edge: game.edge\n  };\n}\n\n/**\n * Generate human-readable recommendation\n */\nfunction generateRecommendation(game, signals, sharpSide, confidence) {\n  if (signals.length === 0) {\n    return {\n      action: 'PASS',\n      summary: 'No significant edges detected',\n      details: null\n    };\n  }\n  \n  const sharpTeam = sharpSide === 'home' ? game.homeTeam : \n                    sharpSide === 'away' ? game.awayTeam : null;\n  \n  // Analyze signals\n  const hasPolyEdge = signals.some(s => s.type === 'polymarket_divergence');\n  const hasSharpMoney = signals.some(s => s.type === 'sharp_money');\n  const hasPinnacleEdge = signals.some(s => s.type === 'pinnacle_divergence');\n  const hasConfirmation = signals.some(s => s.type === 'confirmation');\n  \n  let action = 'MONITOR';\n  let summary = '';\n  const details = [];\n  \n  if (confidence === 'high') {\n    action = 'STRONG';\n    summary = `Strong edge on ${sharpTeam || 'undetermined side'}`;\n  } else if (confidence === 'medium') {\n    action = 'CONSIDER';\n    summary = `Moderate edge detected`;\n  } else {\n    summary = 'Minor edge signals';\n  }\n  \n  // Build detail strings\n  if (hasPolyEdge) {\n    const polySignal = signals.find(s => s.type === 'polymarket_divergence');\n    details.push(`Polymarket ${polySignal.strength} divergence (${polySignal.edge}% vs Vegas)`);\n  }\n  \n  if (hasSharpMoney) {\n    const sharpSignal = signals.find(s => s.type === 'sharp_money');\n    details.push(`Sharp money on ${sharpSignal.sharpSide} (${sharpSignal.divergence}% handle vs bets divergence)`);\n  }\n  \n  if (hasPinnacleEdge) {\n    const pinSignal = signals.find(s => s.type === 'pinnacle_divergence');\n    details.push(`Pinnacle edge: ${pinSignal.edge}% vs soft books on ${pinSignal.market}`);\n  }\n  \n  if (hasConfirmation) {\n    const confSignal = signals.find(s => s.type === 'confirmation');\n    details.push(confSignal.description);\n  }\n  \n  return {\n    action,\n    summary,\n    betSide: sharpTeam,\n    details\n  };\n}\n\n/**\n * Generate overall summary\n */\nfunction generateSummary(allGames, topEdges) {\n  return {\n    totalGames: allGames.length,\n    gamesWithEdge: allGames.filter(g => g.edgeScore >= CONFIDENCE_LEVELS.LOW).length,\n    highConfidence: allGames.filter(g => g.confidence === 'high').length,\n    mediumConfidence: allGames.filter(g => g.confidence === 'medium').length,\n    topOpportunities: topEdges.map(g => ({\n      game: `${g.awayTeam} @ ${g.homeTeam}`,\n      score: g.edgeScore,\n      confidence: g.confidence,\n      recommendation: g.recommendation.summary\n    }))\n  };\n}\n\n// ============================================================\n// QUICK EDGE CHECK (Lightweight version)\n// ============================================================\n\n/**\n * Quick edge check without full data fetch\n * Uses cached data when available\n */\nexport async function quickEdgeCheck(env, sport) {\n  // Just check for cached edge data\n  const cacheKey = `edge_detection_${sport}`;\n  \n  if (env.SIGNALS_CACHE) {\n    try {\n      const cached = await env.SIGNALS_CACHE.get(cacheKey, { type: 'json' });\n      if (cached && cached.data) {\n        const age = Date.now() - cached.timestamp;\n        if (age < 10 * 60 * 1000) { // 10 minute cache\n          return { ...cached.data, fromCache: true };\n        }\n      }\n    } catch (e) {}\n  }\n  \n  // Run full detection if no cache\n  const result = await runEdgeDetection(env, sport);\n  \n  // Cache result\n  if (env.SIGNALS_CACHE && result.success) {\n    try {\n      await env.SIGNALS_CACHE.put(cacheKey, JSON.stringify({\n        data: result,\n        timestamp: Date.now()\n      }), { expirationTtl: 660 }); // 11 minutes\n    } catch (e) {}\n  }\n  \n  return result;\n}\n\n// ============================================================\n// EXPORTS\n// ============================================================\n\nexport default {\n  runEdgeDetection,\n  quickEdgeCheck,\n  EDGE_WEIGHTS,\n  CONFIDENCE_LEVELS\n};\n", "// ============================================================\n// INDEX.JS - Main Router for Polymarket Scanner\n// v18.9.0 - Winning Focus: Track winners, prune losers, sports priority\n// ============================================================\n\nimport { corsHeaders, VERSION, SPORT_KEY_MAP, KV_KEYS } from './config.js';\nimport { runScan, getRecentSignals, getSignal, getPendingSignalsCount, getTrackedWalletsCount } from './signals.js';\nimport { getWalletStats, getWalletLeaderboard, getTrackedWallets, pruneLosingWallets, clearTradeBuckets, fullKVCleanup, deduplicateWalletBets, getWalletPnL } from './wallets.js';\nimport { getOddsComparison, getGameScores, getGameOdds } from './odds-api.js';\nimport { processSettledSignals } from './settlement.js';\nimport { getFactorStats, getAIRecommendation, updateFactorStats, getDiscoveredPatterns, getFactorCombos, hasStrongCombo } from './learning.js';\nimport { pollAndStoreTrades, getAccumulatedTrades, getPollStats, clearAccumulatedTrades } from './trades.js';\n\n// Polymarket API functions\nimport { \n  getSportsMarketsWithPrices, \n  getMarketBySlug,\n  getMarkets,\n  getMidpoint,\n  getMidpoints,\n  getOrderBook,\n  getPrice,\n  getLastTradePrice,\n  getRecentTrades\n} from './polymarket-api.js';\n\n// NEW: Edge Detection imports\nimport { runEdgeDetection, quickEdgeCheck } from './edge-detector.js';\nimport { getBettingSplits, analyzeSharpMoney } from './betting-splits.js';\nimport { getSharpLineComparison, getLineMovement, trackLineMovement, detectSteamMove, calculateCLV } from './sharp-lines.js';\n\nexport default {\n  // Scheduled cron handler - runs every minute to accumulate trades\n  async scheduled(event, env, ctx) {\n    console.log(\"Cron triggered:\", event.cron);\n    \n    try {\n      // ALWAYS poll for trades first (this runs every minute)\n      const pollResult = await pollAndStoreTrades(env);\n      console.log(\"Trade poll result:\", pollResult);\n      \n      // Run settlement check less frequently (check if it's been >10 minutes)\n      let settlementResults = null;\n      const lastSettlement = await env.SIGNALS_CACHE?.get('last_settlement_run');\n      const lastSettlementTime = lastSettlement ? new Date(lastSettlement).getTime() : 0;\n      const minutesSinceSettlement = (Date.now() - lastSettlementTime) / 60000;\n      \n      if (minutesSinceSettlement > 10) {\n        settlementResults = await processSettledSignals(env);\n        console.log(\"Settlement results:\", settlementResults);\n        await env.SIGNALS_CACHE?.put('last_settlement_run', new Date().toISOString());\n      }\n      \n      // Store cron stats\n      if (env.SIGNALS_CACHE) {\n        try {\n          await env.SIGNALS_CACHE.put(KV_KEYS.LAST_CRON_RUN, new Date().toISOString());\n          await env.SIGNALS_CACHE.put(KV_KEYS.CRON_STATS, JSON.stringify({\n            lastRun: new Date().toISOString(),\n            tradePoll: pollResult,\n            settlement: settlementResults\n          }));\n        } catch (e) {\n          console.log('KV write failed (quota?):', e.message);\n        }\n      }\n      \n    } catch (e) {\n      console.error(\"Cron error:\", e.message);\n    }\n  },\n  \n  // HTTP request handler\n  async fetch(request, env, ctx) {\n    const url = new URL(request.url);\n    const path = url.pathname;\n    \n    // Handle CORS preflight\n    if (request.method === \"OPTIONS\") {\n      return new Response(null, { headers: corsHeaders });\n    }\n    \n    try {\n      // ============ SCAN ENDPOINTS ============\n      \n      if (path === \"/scan\" || path === \"/api/scan\") {\n        const hours = parseInt(url.searchParams.get(\"hours\") || \"48\");\n        const minScore = parseInt(url.searchParams.get(\"minScore\") || \"40\");\n        const sportsOnly = url.searchParams.get(\"sportsOnly\") === \"true\" || url.searchParams.get(\"sports\") === \"true\";\n        const debug = url.searchParams.get(\"debug\") === \"true\";\n        \n        const result = await runScan(hours, minScore, env, { \n          sportsOnly, \n          includeDebug: debug \n        });\n        return jsonResponse(result);\n      }\n      \n      if (path === \"/scan/sports\" || path === \"/sports/scan\") {\n        const hours = parseInt(url.searchParams.get(\"hours\") || \"48\");\n        const minScore = parseInt(url.searchParams.get(\"minScore\") || \"40\");\n        const debug = url.searchParams.get(\"debug\") === \"true\";\n        \n        const result = await runScan(hours, minScore, env, { \n          sportsOnly: true, \n          includeDebug: debug \n        });\n        \n        // Return sports signals with top 15 priority\n        return jsonResponse({\n          ...result,\n          signals: result.sportsSignals || result.signals?.slice(0, 15) || [],\n          allSportsSignals: result.signals,\n          topSportsCount: (result.sportsSignals || []).length\n        });\n      }\n      \n      // NEW: Top 15 sports props endpoint\n      if (path === \"/scan/sports/top15\" || path === \"/sports/top15\") {\n        const result = await runScan(48, 30, env, { sportsOnly: true });\n        \n        // Filter to ONLY signals with winning wallets or high confidence\n        const topSignals = (result.sportsSignals || result.signals || [])\n          .filter(s => s.hasWinningWallet || s.confidence >= 65)\n          .slice(0, 15);\n        \n        return jsonResponse({\n          success: true,\n          signals: topSignals,\n          totalSportsSignals: (result.signals || []).length,\n          signalsWithWinners: topSignals.filter(s => s.hasWinningWallet).length,\n          avgConfidence: topSignals.length > 0 \n            ? Math.round(topSignals.reduce((sum, s) => sum + s.confidence, 0) / topSignals.length)\n            : 0\n        });\n      }\n      \n      if (path === \"/signals/recent\") {\n        const limit = parseInt(url.searchParams.get(\"limit\") || \"20\");\n        const signals = await getRecentSignals(env, limit);\n        return jsonResponse({ success: true, signals });\n      }\n      \n      if (path.startsWith(\"/signal/\")) {\n        const signalId = path.split(\"/\")[2];\n        const signal = await getSignal(env, signalId);\n        return jsonResponse({ success: !!signal, signal });\n      }\n      \n      // ============ EDGE DETECTION ENDPOINTS (NEW!) ============\n      \n      // Full edge detection - combines all data sources\n      if (path === \"/edge/detect\" || path.match(/^\\/edge\\/detect\\/[a-z]+$/i)) {\n        const sport = path.split(\"/\")[3] || url.searchParams.get(\"sport\") || \"nba\";\n        const result = await runEdgeDetection(env, sport);\n        return jsonResponse(result);\n      }\n      \n      // Quick edge check (uses cache when available)\n      if (path === \"/edge/quick\" || path.match(/^\\/edge\\/quick\\/[a-z]+$/i)) {\n        const sport = path.split(\"/\")[3] || url.searchParams.get(\"sport\") || \"nba\";\n        const result = await quickEdgeCheck(env, sport);\n        return jsonResponse(result);\n      }\n      \n      // Betting splits (DraftKings public money flow)\n      if (path === \"/edge/splits\" || path.match(/^\\/edge\\/splits\\/[a-z]+$/i)) {\n        const sport = path.split(\"/\")[3] || url.searchParams.get(\"sport\") || \"nba\";\n        const result = await getBettingSplits(env, sport);\n        \n        // Optionally analyze for sharp money\n        if (url.searchParams.get(\"analyze\") === \"true\" && result.success) {\n          const analysis = analyzeSharpMoney(result.games || []);\n          return jsonResponse({\n            ...result,\n            sharpMoneyGames: analysis,\n            sharpGamesCount: analysis.length\n          });\n        }\n        \n        return jsonResponse(result);\n      }\n      \n      // Sharp line comparison (Pinnacle vs soft books)\n      if (path === \"/edge/sharp\" || path.match(/^\\/edge\\/sharp\\/[a-z]+$/i)) {\n        const sport = path.split(\"/\")[3] || url.searchParams.get(\"sport\") || \"nba\";\n        const result = await getSharpLineComparison(env, sport);\n        return jsonResponse(result);\n      }\n      \n      // Line movement tracking\n      if (path.startsWith(\"/edge/movement/\")) {\n        const gameId = path.split(\"/\")[3];\n        \n        if (request.method === \"POST\") {\n          const body = await request.json();\n          const result = await trackLineMovement(env, gameId, body.odds);\n          return jsonResponse({ success: true, result });\n        } else {\n          const history = await getLineMovement(env, gameId);\n          \n          if (history) {\n            const steamMoves = detectSteamMove(history);\n            return jsonResponse({ \n              success: true, \n              ...history,\n              steamAnalysis: steamMoves\n            });\n          }\n          \n          return jsonResponse({ success: false, error: \"No line history for game\" });\n        }\n      }\n      \n      // CLV calculator\n      if (path === \"/edge/clv\") {\n        const entryOdds = parseFloat(url.searchParams.get(\"entry\"));\n        const closingOdds = parseFloat(url.searchParams.get(\"closing\"));\n        \n        if (isNaN(entryOdds) || isNaN(closingOdds)) {\n          return jsonResponse({ \n            success: false, \n            error: \"Provide entry and closing odds as query params (American format)\",\n            example: \"/edge/clv?entry=-110&closing=-125\"\n          }, 400);\n        }\n        \n        const clv = calculateCLV(entryOdds, closingOdds);\n        return jsonResponse({ success: true, ...clv });\n      }\n      \n      // ============ POLYMARKET API ENDPOINTS ============\n      \n      if (path === \"/polymarket/sports\" || path.match(/^\\/polymarket\\/sports\\/[a-z]+$/i)) {\n        const sport = path.split(\"/\")[3] || url.searchParams.get(\"sport\") || \"nba\";\n        const result = await getSportsMarketsWithPrices(env, sport);\n        return jsonResponse(result);\n      }\n      \n      if (path === \"/polymarket/markets\") {\n        const limit = parseInt(url.searchParams.get(\"limit\") || \"100\");\n        const offset = parseInt(url.searchParams.get(\"offset\") || \"0\");\n        const tag_slug = url.searchParams.get(\"tag\") || url.searchParams.get(\"tag_slug\");\n        const active = url.searchParams.get(\"active\") !== \"false\";\n        const closed = url.searchParams.get(\"closed\") === \"true\";\n        \n        const result = await getMarkets(env, { limit, offset, tag_slug, active, closed });\n        return jsonResponse(result);\n      }\n      \n      if (path.startsWith(\"/polymarket/market/\")) {\n        const slug = path.split(\"/\").slice(3).join(\"/\");\n        const result = await getMarketBySlug(env, slug);\n        return jsonResponse(result);\n      }\n      \n      if (path.startsWith(\"/polymarket/midpoint/\")) {\n        const tokenId = path.split(\"/\")[3];\n        const result = await getMidpoint(env, tokenId);\n        return jsonResponse(result);\n      }\n      \n      if (path === \"/polymarket/midpoints\") {\n        const tokenIds = url.searchParams.get(\"token_ids\")?.split(\",\") || [];\n        if (tokenIds.length === 0) {\n          return jsonResponse({ error: \"token_ids parameter required\" }, 400);\n        }\n        const results = await getMidpoints(env, tokenIds);\n        return jsonResponse({ success: true, midpoints: results });\n      }\n      \n      if (path.startsWith(\"/polymarket/book/\")) {\n        const tokenId = path.split(\"/\")[3];\n        const result = await getOrderBook(env, tokenId);\n        return jsonResponse(result);\n      }\n      \n      if (path.startsWith(\"/polymarket/price/\")) {\n        const tokenId = path.split(\"/\")[3];\n        const side = url.searchParams.get(\"side\") || \"BUY\";\n        const result = await getPrice(env, tokenId, side);\n        return jsonResponse(result);\n      }\n      \n      if (path.startsWith(\"/polymarket/last-trade/\")) {\n        const tokenId = path.split(\"/\")[3];\n        const result = await getLastTradePrice(env, tokenId);\n        return jsonResponse(result);\n      }\n      \n      if (path === \"/polymarket/trades\") {\n        const limit = parseInt(url.searchParams.get(\"limit\") || \"100\");\n        const market = url.searchParams.get(\"market\");\n        const result = await getRecentTrades(env, { limit, market });\n        return jsonResponse(result);\n      }\n      \n      // ============ TRADE ACCUMULATION ENDPOINTS ============\n      \n      if (path === \"/trades/poll\") {\n        const result = await pollAndStoreTrades(env);\n        return jsonResponse(result);\n      }\n      \n      if (path === \"/trades/stats\") {\n        const stats = await getPollStats(env);\n        return jsonResponse({ success: true, ...stats });\n      }\n      \n      if (path === \"/trades/accumulated\") {\n        const hours = parseInt(url.searchParams.get(\"hours\") || \"48\");\n        const result = await getAccumulatedTrades(env, hours);\n        return jsonResponse({\n          success: true,\n          fromKV: result.fromKV,\n          totalTrades: result.trades?.length || 0,\n          bucketsRead: result.bucketsRead || 0,\n          oldestTrade: result.trades?.length > 0 \n            ? new Date(result.trades[result.trades.length - 1].timestamp * 1000).toISOString()\n            : null,\n          newestTrade: result.trades?.length > 0\n            ? new Date(result.trades[0].timestamp * 1000).toISOString()\n            : null,\n          sampleTrades: result.trades?.slice(0, 5).map(t => ({\n            title: t.title,\n            size: t.size,\n            price: t.price,\n            time: new Date(t.timestamp * 1000).toISOString()\n          }))\n        });\n      }\n      \n      if (path === \"/trades/clear\" && request.method === \"POST\") {\n        const authHeader = request.headers.get(\"Authorization\");\n        if (authHeader !== \"Bearer polymarket-admin-2026\") {\n          return jsonResponse({ error: \"Unauthorized\" }, 401);\n        }\n        const result = await clearAccumulatedTrades(env);\n        return jsonResponse(result);\n      }\n      \n      // ============ WALLET ENDPOINTS ============\n      \n      if (path === \"/wallets/leaderboard\") {\n        const limit = parseInt(url.searchParams.get(\"limit\") || \"20\");\n        const wallets = await getWalletLeaderboard(env, limit);\n        return jsonResponse({ \n          success: true, \n          wallets,\n          count: wallets.length,\n          message: wallets.length === 0 ? \"No wallet data available yet.\" : null\n        });\n      }\n      \n      if (path.startsWith(\"/wallet/\") && (path.endsWith(\"/stats\") || path.split(\"/\").length === 3)) {\n        const address = path.split(\"/\")[2];\n        const stats = await getWalletStats(env, address);\n        return jsonResponse({ success: !!stats, ...stats });\n      }\n      \n      if (path.startsWith(\"/wallet/\") && path.endsWith(\"/pnl\")) {\n        const address = path.split(\"/\")[2];\n        const pnlData = await getWalletPnL(env, address);\n        return jsonResponse(pnlData);\n      }\n      \n      // ============ ODDS ENDPOINTS ============\n      \n      if (path === \"/odds/compare-all\") {\n        const sport = url.searchParams.get(\"sport\") || \"nba\";\n        const result = await getOddsComparison(env, sport);\n        return jsonResponse(result);\n      }\n      \n      // Debug endpoint to test Polymarket market fetching\n      if (path === \"/debug/poly-markets\") {\n        const sport = url.searchParams.get(\"sport\") || \"nba\";\n        try {\n          const polyMarkets = await getSportsMarketsWithPrices(env, sport);\n          return jsonResponse({\n            success: true,\n            sport,\n            marketsFound: polyMarkets?.markets?.length || 0,\n            fromCache: polyMarkets?.fromCache || false,\n            source: polyMarkets?.source || 'unknown',\n            seriesId: polyMarkets?.seriesId || null,\n            eventsCount: polyMarkets?.eventsCount || 0,\n            sampleMarkets: (polyMarkets?.markets || []).slice(0, 5).map(m => ({\n              slug: m.slug,\n              eventSlug: m.eventSlug,\n              eventTitle: m.eventTitle,\n              question: m.question,\n              outcomes: m.outcomes,\n              outcomePrices: m.outcomePrices,\n              yesPrice: m.yesPrice,\n              noPrice: m.noPrice,\n              gameStartTime: m.gameStartTime\n            })),\n            error: polyMarkets?.error || null\n          });\n        } catch (e) {\n          return jsonResponse({ success: false, error: e.message, stack: e.stack });\n        }\n      }\n      \n      // Debug: show raw /sports metadata from Gamma API\n      if (path === \"/debug/sports-meta\") {\n        try {\n          const response = await fetch(`https://gamma-api.polymarket.com/sports`);\n          const data = await response.json();\n          return jsonResponse({ success: true, status: response.status, data });\n        } catch (e) {\n          return jsonResponse({ success: false, error: e.message });\n        }\n      }\n      \n      // Debug: test raw events fetch for a series_id\n      if (path === \"/debug/events-raw\") {\n        const seriesId = url.searchParams.get(\"series_id\") || \"10345\";\n        try {\n          const response = await fetch(\n            `https://gamma-api.polymarket.com/events?series_id=${seriesId}&active=true&closed=false&limit=10&order=startTime&ascending=true`\n          );\n          const data = await response.json();\n          return jsonResponse({\n            success: true,\n            seriesId,\n            status: response.status,\n            eventsReturned: Array.isArray(data) ? data.length : 'not array',\n            sampleEvents: (Array.isArray(data) ? data : []).slice(0, 3).map(e => ({\n              id: e.id,\n              slug: e.slug,\n              title: e.title,\n              startDate: e.startDate,\n              marketsCount: e.markets?.length || 0,\n              sampleMarket: e.markets?.[0] ? {\n                question: e.markets[0].question,\n                slug: e.markets[0].slug,\n                outcomes: e.markets[0].outcomes,\n                outcomePrices: e.markets[0].outcomePrices\n              } : null\n            }))\n          });\n        } catch (e) {\n          return jsonResponse({ success: false, error: e.message });\n        }\n      }\n      \n      if (path === \"/odds/compare\") {\n        const sport = url.searchParams.get(\"sport\") || \"nba\";\n        const sportKey = SPORT_KEY_MAP[sport.toLowerCase()];\n        \n        if (!sportKey) {\n          return jsonResponse({ error: `Unknown sport: ${sport}` }, 400);\n        }\n        \n        const odds = await getGameOdds(env, sportKey);\n        return jsonResponse({ success: true, sport, odds });\n      }\n      \n      if (path === \"/odds/scores\") {\n        const sport = url.searchParams.get(\"sport\") || \"nba\";\n        const sportKey = SPORT_KEY_MAP[sport.toLowerCase()];\n        \n        if (!sportKey) {\n          return jsonResponse({ error: `Unknown sport: ${sport}` }, 400);\n        }\n        \n        const scores = await getGameScores(env, sportKey);\n        return jsonResponse({ success: true, sport, scores });\n      }\n      \n      // ============ LEARNING/AI ENDPOINTS ============\n      \n      if (path === \"/learning/stats\") {\n        const stats = await getFactorStats(env);\n        \n        // Get additional context\n        let pendingSignals = 0;\n        let trackedWallets = 0;\n        let marketTypeStats = {};\n        let volumeBrackets = {};\n        \n        if (env.SIGNALS_CACHE) {\n          try {\n            const pending = await env.SIGNALS_CACHE.get(KV_KEYS.PENDING_SIGNALS, { type: 'json' }) || [];\n            pendingSignals = pending.length;\n            \n            const walletIndex = await env.SIGNALS_CACHE.get('tracked_wallet_index', { type: 'json' }) || [];\n            trackedWallets = walletIndex.length;\n            \n            marketTypeStats = await env.SIGNALS_CACHE.get('market_type_stats', { type: 'json' }) || {};\n            volumeBrackets = await env.SIGNALS_CACHE.get('volume_brackets', { type: 'json' }) || {};\n          } catch (e) {\n            console.error('Error fetching learning context:', e.message);\n          }\n        }\n        \n        // Calculate totals\n        let totalWins = 0;\n        let totalLosses = 0;\n        Object.values(stats).forEach(factor => {\n          totalWins += factor.wins || 0;\n          totalLosses += factor.losses || 0;\n        });\n        \n        return jsonResponse({ \n          success: true, \n          stats,\n          pendingSignals,\n          trackedWallets,\n          summary: {\n            totalSignalsProcessed: totalWins + totalLosses,\n            overallWinRate: (totalWins + totalLosses) > 0 \n              ? Math.round((totalWins / (totalWins + totalLosses)) * 100) \n              : 0,\n            totalWins,\n            totalLosses,\n            factorCount: Object.keys(stats).length\n          },\n          marketTypeStats,\n          volumeBrackets,\n          // Factor descriptions for frontend display\n          factorDescriptions: {\n            // Whale size\n            whaleSize100k: 'Largest single bet > $100K',\n            whaleSize50k: 'Largest single bet $50K-$100K',\n            whaleSize25k: 'Largest single bet $25K-$50K',\n            whaleSize15k: 'Largest single bet $15K-$25K',\n            whaleSize8k: 'Largest single bet $8K-$15K',\n            whaleSize5k: 'Largest single bet $5K-$8K',\n            whaleSize3k: 'Largest single bet $3K-$5K',\n            // Volume\n            volumeHuge: 'Total market volume > $500K',\n            volumeModerate: 'Total market volume $50K-$100K',\n            volumeNotable: 'Total market volume $100K-$500K',\n            vol_100k_plus: 'Signal volume over $100K',\n            vol_50k_100k: 'Signal volume $50K-$100K',\n            vol_25k_50k: 'Signal volume $25K-$50K',\n            vol_10k_25k: 'Signal volume $10K-$25K',\n            vol_under_10k: 'Signal volume under $10K',\n            // Concentration\n            concentrated: 'Betting heavily concentrated (>70% one direction)',\n            coordinated: 'Multiple wallets betting same direction within minutes',\n            // Directional odds (IMPROVEMENT #4)\n            buyDeepLongshot: 'Buying at <15% (deep longshot)',\n            buyLongshot: 'Buying at 15-25% (longshot)',\n            buyUnderdog: 'Buying at 25-40% (underdog)',\n            buyFavorite: 'Buying at 70-85% (favorite)',\n            buyHeavyFavorite: 'Buying at 85%+ (heavy favorite)',\n            // Legacy odds\n            extremeOdds: 'Entry price < 20% or > 80% (legacy)',\n            moderateLongshot: 'Betting on longshot (20-40% odds)',\n            moderateFavorite: 'Betting on favorite (60-80% odds)',\n            // Event timing (IMPROVEMENT #5)\n            betDuringEvent: 'Bet placed during/after event start (live)',\n            betLast2Hours: 'Bet placed within 2 hours of event',\n            betSameDay: 'Bet placed same day (2-6h before)',\n            betDayBefore: 'Bet placed day before event',\n            betEarlyDays: 'Bet placed 1-3 days before event',\n            betVeryEarly: 'Bet placed 3+ days before event',\n            // Wallets\n            winningWallet: 'Signal includes wallet with 55%+ win rate',\n            freshWhale5k: 'New wallet betting $5K+ (< 5 prior bets)',\n            freshWhale10k: 'New wallet betting $10K+ (< 5 prior bets)',\n            // Market types\n            'sports-nba': 'NBA basketball game',\n            'sports-nfl': 'NFL football game',\n            'sports-nhl': 'NHL hockey game',\n            'sports-ncaab': 'NCAA basketball game',\n            'sports-mma': 'MMA/UFC fight',\n            'sports-other': 'Other sports market',\n            'sports-futures': 'Futures/Championship market',\n            crypto: 'Cryptocurrency market',\n            politics: 'Political market',\n            other: 'Other market type',\n            // Wallet count\n            single_wallet: 'Single wallet signal',\n            two_wallets: 'Two wallets in signal',\n            few_wallets_3_5: '3-5 wallets in signal',\n            many_wallets_6_plus: '6+ wallets in signal',\n            // Time of day\n            morning_5_12: 'Signal detected 5am-12pm ET',\n            afternoon_12_17: 'Signal detected 12pm-5pm ET',\n            evening_17_22: 'Signal detected 5pm-10pm ET',\n            night_22_5: 'Signal detected 10pm-5am ET',\n            // Days\n            day_monday: 'Signal detected on Monday',\n            day_tuesday: 'Signal detected on Tuesday',\n            day_wednesday: 'Signal detected on Wednesday',\n            day_thursday: 'Signal detected on Thursday',\n            day_friday: 'Signal detected on Friday',\n            day_saturday: 'Signal detected on Saturday',\n            day_sunday: 'Signal detected on Sunday',\n          }\n        });\n      }\n      \n      if (path === \"/learning/fades\") {\n        const stats = await getFactorStats(env);\n        \n        const fadeFactors = Object.entries(stats)\n          .filter(([name, data]) => {\n            const total = (data.wins || 0) + (data.losses || 0);\n            return total >= 5 && data.winRate < 45;\n          })\n          .map(([name, data]) => ({\n            factor: name,\n            winRate: data.winRate,\n            record: `${data.wins}W-${data.losses}L`,\n            recommendation: 'FADE'\n          }))\n          .sort((a, b) => a.winRate - b.winRate);\n        \n        return jsonResponse({ \n          success: true, \n          fades: fadeFactors,\n          message: fadeFactors.length > 0 \n            ? `Found ${fadeFactors.length} factors to fade` \n            : 'No fade candidates yet'\n        });\n      }\n      \n      // ============================================================\n      // NEW: Factor Combo Tracking Endpoint\n      // ============================================================\n      if (path === \"/learning/combos\") {\n        const combos = await getFactorCombos(env);\n        return jsonResponse({ \n          success: true, \n          ...combos,\n          message: combos.bestCombos.length > 0 \n            ? `Found ${combos.bestCombos.length} strong combos, ${combos.worstCombos.length} weak combos`\n            : 'Need more settled signals to identify combos'\n        });\n      }\n      \n      // ============================================================\n      // NEW: Alert Check Endpoint (for Twilio integration)\n      // ============================================================\n      if (path === \"/alerts/check\") {\n        const alerts = [];\n        \n        // Get recent signals\n        const recentSignals = await getRecentSignals(env, 50);\n        const factorStats = await getFactorStats(env);\n        \n        for (const signal of recentSignals) {\n          const alertReasons = [];\n          let priority = 'LOW';\n          \n          // Check 1: Elite wallet betting\n          if (signal.hasWinningWallet && signal.largestBet >= 25000) {\n            alertReasons.push(`\uD83C\uDFC6 Elite wallet bet $${signal.largestBet.toLocaleString()}`);\n            priority = 'HIGH';\n          }\n          \n          // Check 2: High-performing factor combo\n          const factors = signal.scoreBreakdown?.map(f => f.factor) || [];\n          const hasVolumeHuge = factors.includes('volumeHuge');\n          const hasFreshWhale = factors.includes('freshWhale5k');\n          \n          if (hasVolumeHuge && hasFreshWhale) {\n            alertReasons.push('\uD83D\uDD25 High-prob combo: volumeHuge + freshWhale5k');\n            priority = 'CRITICAL';\n          } else if (hasVolumeHuge) {\n            alertReasons.push('\uD83D\uDCC8 volumeHuge factor (88% historical WR)');\n            if (priority === 'LOW') priority = 'MEDIUM';\n          }\n          \n          // Check 3: AI score is very high\n          if (signal.aiScore && signal.aiScore >= 80) {\n            alertReasons.push(`\uD83E\uDD16 High AI Score: ${signal.aiScore}`);\n            if (priority === 'LOW') priority = 'MEDIUM';\n          }\n          \n          // Only create alert if we have reasons\n          if (alertReasons.length > 0) {\n            alerts.push({\n              id: signal.id,\n              type: priority === 'CRITICAL' ? 'HIGH_PROBABILITY_COMBO' : \n                    priority === 'HIGH' ? 'ELITE_WALLET_BET' : 'NOTABLE_SIGNAL',\n              priority,\n              market: signal.marketTitle,\n              direction: signal.direction,\n              price: signal.displayPrice,\n              amount: signal.largestBet,\n              reasons: alertReasons,\n              aiScore: signal.aiScore,\n              confidence: signal.confidence,\n              timestamp: signal.firstTradeTime\n            });\n          }\n        }\n        \n        // Sort by priority\n        const priorityOrder = { CRITICAL: 0, HIGH: 1, MEDIUM: 2, LOW: 3 };\n        alerts.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);\n        \n        return jsonResponse({\n          success: true,\n          alerts: alerts.slice(0, 20),  // Top 20 alerts\n          totalAlerts: alerts.length,\n          criticalCount: alerts.filter(a => a.priority === 'CRITICAL').length,\n          highCount: alerts.filter(a => a.priority === 'HIGH').length\n        });\n      }\n      \n      if (path === \"/learning/patterns\") {\n        const patterns = await getDiscoveredPatterns(env);\n        return jsonResponse({ success: true, patterns });\n      }\n      \n      if (path === \"/learning/recommendation\") {\n        const recommendation = await getAIRecommendation(env);\n        return jsonResponse({ success: true, recommendation });\n      }\n      \n      if (path === \"/learning/leaderboard\") {\n        const limit = parseInt(url.searchParams.get(\"limit\") || \"50\");\n        const wallets = await getWalletLeaderboard(env, limit);\n        \n        const leaderboardData = wallets.map(w => ({\n          address: w.address,\n          tier: w.tier || 'NEW',\n          winRate: w.winRate || 0,\n          wins: w.wins || 0,\n          losses: w.losses || 0,\n          pending: w.pending || 0,\n          totalBets: w.totalBets || 0,\n          record: `${w.wins || 0}W-${w.losses || 0}L`,\n          currentStreak: w.currentStreak || 0,\n          bestStreak: w.bestStreak || 0,\n          totalVolume: w.totalVolume || 0,\n          profitLoss: w.profitLoss || 0,\n          lastBetAt: w.lastBetAt\n        }));\n        \n        return jsonResponse({\n          success: true,\n          leaderboard: leaderboardData,\n          totalTracked: leaderboardData.length,\n          tierCounts: {\n            insider: leaderboardData.filter(w => w.tier === 'INSIDER').length,\n            elite: leaderboardData.filter(w => w.tier === 'ELITE').length,\n            strong: leaderboardData.filter(w => w.tier === 'STRONG').length\n          }\n        });\n      }\n      \n      // ============ DEBUG ENDPOINTS ============\n      \n      if (path === \"/debug/wallets\") {\n        if (!env.SIGNALS_CACHE) {\n          return jsonResponse({ success: false, error: \"No cache\" });\n        }\n        \n        const walletIndex = await getTrackedWallets(env);\n        return jsonResponse({\n          success: true,\n          totalInIndex: walletIndex.length,\n          sampleAddresses: walletIndex.slice(0, 10)\n        });\n      }\n      \n      if (path === \"/settlement/run\") {\n        const results = await processSettledSignals(env);\n        return jsonResponse({ success: true, results });\n      }\n      \n      if (path === \"/cron-status\") {\n        if (!env.SIGNALS_CACHE) {\n          return jsonResponse({ success: false, error: \"No cache\" });\n        }\n        \n        const lastRun = await env.SIGNALS_CACHE.get(KV_KEYS.LAST_CRON_RUN);\n        const stats = await env.SIGNALS_CACHE.get(KV_KEYS.CRON_STATS, { type: \"json\" });\n        const pollStats = await getPollStats(env);\n        \n        return jsonResponse({\n          success: true,\n          lastRun,\n          stats,\n          pollStats,\n          minutesSinceRun: lastRun ? Math.round((Date.now() - new Date(lastRun).getTime()) / 60000) : null\n        });\n      }\n      \n      // ============ ADMIN ENDPOINTS ============\n      \n      // NEW: Prune losing wallets (keep only winners)\n      if (path === \"/admin/prune-losers\" && request.method === \"POST\") {\n        const authHeader = request.headers.get(\"Authorization\");\n        if (authHeader !== \"Bearer polymarket-admin-2026\") {\n          return jsonResponse({ error: \"Unauthorized\" }, 401);\n        }\n        \n        try {\n          const result = await pruneLosingWallets(env);\n          return jsonResponse({ \n            success: true, \n            message: `Pruned ${result.pruned} losing wallets, kept ${result.kept} winners`,\n            ...result\n          });\n        } catch (error) {\n          return jsonResponse({ error: error.message }, 500);\n        }\n      }\n      \n      // NEW: Clear trade buckets (free memory)\n      if (path === \"/admin/clear-buckets\" && request.method === \"POST\") {\n        const authHeader = request.headers.get(\"Authorization\");\n        if (authHeader !== \"Bearer polymarket-admin-2026\") {\n          return jsonResponse({ error: \"Unauthorized\" }, 401);\n        }\n        \n        try {\n          const result = await clearTradeBuckets(env);\n          return jsonResponse({ \n            success: true, \n            message: `Cleared ${result.cleared} trade buckets`,\n            ...result\n          });\n        } catch (error) {\n          return jsonResponse({ error: error.message }, 500);\n        }\n      }\n      \n      // NEW: Full cleanup (buckets + losers)\n      if (path === \"/admin/full-cleanup\" && request.method === \"POST\") {\n        const authHeader = request.headers.get(\"Authorization\");\n        if (authHeader !== \"Bearer polymarket-admin-2026\") {\n          return jsonResponse({ error: \"Unauthorized\" }, 401);\n        }\n        \n        try {\n          const result = await fullKVCleanup(env);\n          return jsonResponse({ \n            success: true, \n            message: \"Full cleanup complete\",\n            ...result\n          });\n        } catch (error) {\n          return jsonResponse({ error: error.message }, 500);\n        }\n      }\n      \n      // NEW: Deduplicate wallet bets (fix inflated win/loss records)\n      if (path === \"/admin/dedupe-wallets\" && request.method === \"POST\") {\n        const authHeader = request.headers.get(\"Authorization\");\n        if (authHeader !== \"Bearer polymarket-admin-2026\") {\n          return jsonResponse({ error: \"Unauthorized\" }, 401);\n        }\n        \n        try {\n          const result = await deduplicateWalletBets(env);\n          return jsonResponse({ \n            success: true, \n            message: `Deduped ${result.walletsProcessed} wallets, removed ${result.duplicatesRemoved} duplicate bets`,\n            ...result\n          });\n        } catch (error) {\n          return jsonResponse({ error: error.message }, 500);\n        }\n      }\n      \n      if (path === \"/admin/reset-wallets\" && request.method === \"POST\") {\n        const authHeader = request.headers.get(\"Authorization\");\n        if (authHeader !== \"Bearer polymarket-admin-2026\") {\n          return jsonResponse({ error: \"Unauthorized\" }, 401);\n        }\n        \n        try {\n          await env.SIGNALS_CACHE.delete(\"tracked_wallet_index\");\n          return jsonResponse({ \n            success: true, \n            message: \"Wallet index cleared.\"\n          });\n        } catch (error) {\n          return jsonResponse({ error: error.message }, 500);\n        }\n      }\n      \n      if (path === \"/admin/clear-cache\" && request.method === \"POST\") {\n        const authHeader = request.headers.get(\"Authorization\");\n        if (authHeader !== \"Bearer polymarket-admin-2026\") {\n          return jsonResponse({ error: \"Unauthorized\" }, 401);\n        }\n        \n        try {\n          const keysToDelete = [\n            'gamma_markets_all_100_0',\n            'sports_markets_nba', 'sports_markets_ncaa-cbb', 'sports_markets_nfl', 'sports_markets_nhl',\n            'odds_comparison_v2_nba', 'odds_comparison_v2_ncaab', 'odds_comparison_v2_nfl', 'odds_comparison_v2_nhl',\n            'edge_detection_nba', 'edge_detection_nfl', 'edge_detection_ncaab',\n            'betting_splits_nba', 'betting_splits_nfl', 'betting_splits_ncaab',\n            'sharp_lines_nba', 'sharp_lines_nfl', 'sharp_lines_ncaab'\n          ];\n          \n          const deleted = [];\n          for (const key of keysToDelete) {\n            try {\n              await env.SIGNALS_CACHE.delete(key);\n              deleted.push(key);\n            } catch (e) {}\n          }\n          \n          return jsonResponse({ \n            success: true, \n            message: \"All caches cleared\",\n            deletedKeys: deleted\n          });\n        } catch (error) {\n          return jsonResponse({ error: error.message }, 500);\n        }\n      }\n      \n      // ============ HEALTH/INFO ============\n      \n      if (path === \"/\" || path === \"/health\") {\n        return jsonResponse({\n          status: \"ok\",\n          version: VERSION,\n          endpoints: {\n            scanner: [\n              \"GET /scan - Run signal scan\",\n              \"GET /scan/sports - Sports-only scan\",\n              \"GET /signals/recent - Get recent signals\"\n            ],\n            edgeDetection: [\n              \"GET /edge/detect/:sport - Full edge detection (combines all sources)\",\n              \"GET /edge/quick/:sport - Quick edge check (cached)\",\n              \"GET /edge/splits/:sport - DraftKings betting splits (public money flow)\",\n              \"GET /edge/sharp/:sport - Pinnacle vs soft book comparison\",\n              \"GET /edge/movement/:gameId - Line movement tracking\",\n              \"GET /edge/clv?entry=X&closing=Y - Calculate closing line value\"\n            ],\n            polymarket: [\n              \"GET /polymarket/sports/:sport - Real-time sports prices\",\n              \"GET /polymarket/markets - List all markets\",\n              \"GET /polymarket/market/:slug - Get market by slug\"\n            ],\n            vegasComparison: [\n              \"GET /odds/compare-all?sport=nba - Vegas vs Polymarket\",\n              \"GET /odds/scores?sport=nba - Game scores\"\n            ],\n            wallets: [\n              \"GET /wallets/leaderboard - Wallet leaderboard\",\n              \"GET /wallet/:address/stats - Wallet stats\"\n            ],\n            learning: [\n              \"GET /learning/stats - Factor statistics\",\n              \"GET /learning/fades - Fade recommendations\"\n            ]\n          }\n        });\n      }\n      \n      // 404\n      return jsonResponse({ error: \"Not found\", path }, 404);\n      \n    } catch (e) {\n      return jsonResponse({ error: e.message, stack: e.stack }, 500);\n    }\n  }\n};\n\n// Helper function for JSON responses\nfunction jsonResponse(data, status = 200) {\n  return new Response(JSON.stringify(data), {\n    status,\n    headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n  });\n}\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"/home/project/src/index.js\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"/home/project/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"/home/project/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"/home/project/src/index.js\";\n\t\t\t\tconst MIDDLEWARE_TEST_INJECT = \"__INJECT_FOR_TESTING_WRANGLER_MIDDLEWARE__\";\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"/home/project/.wrangler/tmp/bundle-C8BKd5/middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"/home/project/node_modules/wrangler/templates/middleware/common.ts\";\nimport type { WorkerEntrypointConstructor } from \"/home/project/.wrangler/tmp/bundle-C8BKd5/middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"/home/project/.wrangler/tmp/bundle-C8BKd5/middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": "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",
  "names": ["roi", "key", "totalWeight", "result", "dirTeam", "didWin", "outcome", "profitPct", "CACHE_DURATION", "CACHE_DURATION", "americanToProb"]
}
